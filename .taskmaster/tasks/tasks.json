{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Initialize Tauri 2.x Project with Rust Backend",
        "description": "Set up the foundational Tauri 2.x project structure with Rust backend and configure the basic build system.",
        "details": "1. Install Tauri CLI: `npm create tauri-app@latest` or `cargo install tauri-cli`\n2. Initialize new Tauri 2.x project with React/TypeScript template:\n   ```bash\n   npm create tauri-app@latest . -- --template react-ts\n   ```\n3. Configure Cargo.toml with required dependencies:\n   ```toml\n   [dependencies]\n   tauri = { version = \"2\", features = [\"devtools\"] }\n   tokio = { version = \"1\", features = [\"full\"] }\n   serde = { version = \"1\", features = [\"derive\"] }\n   serde_json = \"1\"\n   serde_yaml = \"0.9\"\n   zip = \"0.6\"\n   chrono = { version = \"0.4\", features = [\"serde\"] }\n   tempfile = \"3\"\n   thiserror = \"1\"\n   ```\n4. Create the directory structure:\n   ```\n   src-tauri/src/\n   ├── main.rs\n   ├── lib.rs\n   ├── commands/mod.rs\n   ├── project/mod.rs\n   ```\n5. Configure tauri.conf.json with app identifier, window settings, and build configuration\n6. Set up basic main.rs with Tauri builder initialization",
        "testStrategy": "1. Verify `cargo build` completes without errors\n2. Verify `npm run tauri dev` launches the application window\n3. Check that Tauri DevTools are accessible in development mode\n4. Validate all dependencies resolve correctly",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Tauri CLI and Initialize Project with React-TypeScript Template",
            "description": "Install the Tauri CLI globally and create a new Tauri 2.x project using the React-TypeScript template in the current directory.",
            "dependencies": [],
            "details": "Execute `npm create tauri-app@latest . -- --template react-ts` to initialize the project. This will create the basic project structure including src-tauri/ directory with Rust code, src/ directory with React frontend, package.json, and vite.config.ts. If prompted for package manager, select npm. Ensure Node.js 18+ and Rust 1.70+ are installed before running. The template will create main.rs with basic Tauri initialization and a simple React App.tsx component.",
            "status": "done",
            "testStrategy": "Verify that src-tauri/ and src/ directories are created. Check that package.json contains @tauri-apps/api and @tauri-apps/cli dependencies. Verify Cargo.toml exists in src-tauri/ with tauri dependency.",
            "parentId": "undefined",
            "updatedAt": "2026-01-26T17:00:29.712Z"
          },
          {
            "id": 2,
            "title": "Configure Cargo.toml with Required Rust Dependencies",
            "description": "Update the src-tauri/Cargo.toml file to include all required dependencies for the ModOne application.",
            "dependencies": [
              1
            ],
            "details": "Edit src-tauri/Cargo.toml to add the following dependencies: tauri = { version = \"2\", features = [\"devtools\"] }, tokio = { version = \"1\", features = [\"full\"] }, serde = { version = \"1\", features = [\"derive\"] }, serde_json = \"1\", serde_yaml = \"0.9\", zip = \"0.6\", chrono = { version = \"0.4\", features = [\"serde\"] }, tempfile = \"3\", thiserror = \"1\". These dependencies provide async runtime (tokio), serialization (serde), YAML config support (serde_yaml), ZIP archive handling (zip), timestamp management (chrono), temp file handling (tempfile), and error handling (thiserror).",
            "status": "done",
            "testStrategy": "Run `cargo check` in src-tauri/ directory to verify all dependencies resolve correctly. Ensure no version conflicts or missing features errors.",
            "parentId": "undefined",
            "updatedAt": "2026-01-26T17:01:21.721Z"
          },
          {
            "id": 3,
            "title": "Create Rust Module Directory Structure",
            "description": "Set up the organized Rust module structure with commands/ and project/ directories and their mod.rs files.",
            "dependencies": [
              1
            ],
            "details": "Create the following directory structure under src-tauri/src/: commands/mod.rs (empty module for future Tauri commands), project/mod.rs (empty module for project management logic). Create src-tauri/src/lib.rs to serve as the library entry point that will export public modules. Update main.rs to include `mod commands;` and `mod project;` declarations. The lib.rs file should contain placeholder comments indicating where future module exports will be added. This structure follows Rust conventions for organizing a medium-sized application.",
            "status": "done",
            "testStrategy": "Run `cargo build` to verify the module structure compiles. Check that mod.rs files exist in both commands/ and project/ directories.",
            "parentId": "undefined",
            "updatedAt": "2026-01-26T17:02:03.042Z"
          },
          {
            "id": 4,
            "title": "Configure tauri.conf.json with App Settings",
            "description": "Update the Tauri configuration file with the ModOne application identifier, window settings, and build configuration.",
            "dependencies": [
              1
            ],
            "details": "Edit src-tauri/tauri.conf.json to configure: identifier as \"com.modone.app\", productName as \"ModOne\", window title as \"ModOne\", default window size (width: 1280, height: 800), minimum window size (width: 800, height: 600), enable window decorations, allow resizing. In the build section, configure beforeDevCommand as \"npm run dev\" and beforeBuildCommand as \"npm run build\". Set the devUrl to the Vite dev server URL (http://localhost:1420). Enable devtools in development mode. Configure file associations for .mop files if supported by Tauri 2.x config.",
            "status": "done",
            "testStrategy": "Run `npm run tauri dev` and verify the window opens with the correct title and dimensions. Check that the window is resizable and respects minimum size constraints.",
            "parentId": "undefined",
            "updatedAt": "2026-01-26T17:02:26.482Z"
          },
          {
            "id": 5,
            "title": "Set Up Basic main.rs with Tauri Builder Initialization",
            "description": "Configure the main.rs entry point with proper Tauri builder initialization, state management setup, and invoke handler registration.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Update src-tauri/src/main.rs to: 1) Add #![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")] for Windows builds, 2) Import necessary modules with `mod commands;` and `mod project;`, 3) Configure the Tauri Builder with .setup() hook for initialization logging, 4) Add placeholder .manage() for future state management (ProjectManager wrapped in Mutex), 5) Set up .invoke_handler(tauri::generate_handler![]) ready for command registration, 6) Add basic error handling for the build().run() call. Include comments indicating where future commands and state will be registered.",
            "status": "done",
            "testStrategy": "Run `npm run tauri dev` to verify the application launches without errors. Check console/terminal for setup hook logging. Verify the React frontend loads in the Tauri window. Test that DevTools are accessible in development mode (right-click > Inspect or keyboard shortcut).",
            "parentId": "undefined",
            "updatedAt": "2026-01-26T17:04:08.894Z"
          }
        ],
        "updatedAt": "2026-01-26T17:04:08.894Z"
      },
      {
        "id": "2",
        "title": "Configure Frontend with React 18 and TypeScript",
        "description": "Set up the React 18 frontend with TypeScript, Tailwind CSS for styling, and Zustand for state management.",
        "details": "1. Install frontend dependencies:\n   ```bash\n   npm install react@18 react-dom@18 zustand tailwindcss postcss autoprefixer\n   npm install -D @types/react @types/react-dom typescript @tauri-apps/api\n   ```\n2. Initialize Tailwind CSS:\n   ```bash\n   npx tailwindcss init -p\n   ```\n3. Configure tailwind.config.js with content paths\n4. Create TypeScript configuration (tsconfig.json) with strict mode\n5. Set up src/ directory structure:\n   ```\n   src/\n   ├── App.tsx\n   ├── main.tsx\n   ├── index.css (Tailwind imports)\n   ├── components/\n   ├── hooks/\n   ├── stores/\n   │   └── projectStore.ts\n   └── types/\n       └── project.ts\n   ```\n6. Create base App.tsx component with Tailwind styling\n7. Configure Zustand store for project state management:\n   ```typescript\n   interface ProjectStore {\n     currentProject: ProjectData | null;\n     isModified: boolean;\n     recentProjects: RecentProject[];\n     setProject: (project: ProjectData | null) => void;\n     setModified: (modified: boolean) => void;\n   }\n   ```",
        "testStrategy": "1. Verify `npm run dev` starts the Vite development server\n2. Check Tailwind CSS classes apply correctly to components\n3. Test Zustand store state updates in React DevTools\n4. Validate TypeScript compilation with no type errors",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Additional Frontend Dependencies (Zustand, Tailwind CSS)",
            "description": "Install Zustand for state management and Tailwind CSS with PostCSS/Autoprefixer for styling on top of the React-TypeScript template from Task 1.",
            "dependencies": [],
            "details": "After Task 1 completes, the Tauri React-TypeScript template will have React 18 and basic TypeScript already configured. Run `npm install zustand` to add the state management library. Then install Tailwind CSS and its peer dependencies with `npm install -D tailwindcss postcss autoprefixer`. Verify @tauri-apps/api is already installed from the template; if not, add it with `npm install @tauri-apps/api`. The template should already include @types/react and @types/react-dom as dev dependencies.",
            "status": "done",
            "testStrategy": "Run `npm list zustand tailwindcss postcss autoprefixer` to verify all packages are installed. Check package.json contains the new dependencies with correct versions.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T02:42:58.345Z"
          },
          {
            "id": 2,
            "title": "Initialize and Configure Tailwind CSS",
            "description": "Initialize Tailwind CSS configuration and set up the base styles with proper content paths for the Tauri React project.",
            "dependencies": [
              1
            ],
            "details": "Run `npx tailwindcss init -p` to generate tailwind.config.js and postcss.config.js files. Update tailwind.config.js to include content paths: `content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}']`. Create or update src/index.css with Tailwind directives: `@tailwind base; @tailwind components; @tailwind utilities;`. Ensure main.tsx imports this CSS file. Add custom theme extensions if needed for ModOne branding (colors, fonts). Configure darkMode option as 'class' for future dark mode support.",
            "status": "done",
            "testStrategy": "Start the dev server with `npm run dev` and add a test Tailwind class (e.g., `className=\"bg-blue-500 text-white p-4\"`) to App.tsx. Verify the styles render correctly in the browser.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T02:42:58.353Z"
          },
          {
            "id": 3,
            "title": "Configure TypeScript with Strict Mode and Path Aliases",
            "description": "Update the TypeScript configuration with strict type checking enabled and configure path aliases for cleaner imports.",
            "dependencies": [
              1
            ],
            "details": "The template provides a base tsconfig.json. Update it to enable strict mode: `\"strict\": true, \"noImplicitAny\": true, \"strictNullChecks\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true`. Add path aliases for cleaner imports: `\"paths\": { \"@/*\": [\"./src/*\"], \"@components/*\": [\"./src/components/*\"], \"@hooks/*\": [\"./src/hooks/*\"], \"@stores/*\": [\"./src/stores/*\"], \"@types/*\": [\"./src/types/*\"], \"@services/*\": [\"./src/services/*\"] }`. Update vite.config.ts to resolve these aliases using vite-tsconfig-paths plugin or manual alias configuration.",
            "status": "done",
            "testStrategy": "Run `npx tsc --noEmit` to verify TypeScript compiles without errors. Test a path alias import works correctly. Verify strict mode catches type errors in intentionally incorrect test code.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T02:42:58.358Z"
          },
          {
            "id": 4,
            "title": "Create Frontend Directory Structure and Type Definitions",
            "description": "Set up the organized src/ directory structure with components, hooks, stores, services, and types directories, including base type definitions for the project.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create the directory structure: src/components/ (UI components), src/hooks/ (custom React hooks), src/stores/ (Zustand stores), src/services/ (API/Tauri service layer), src/types/ (TypeScript type definitions). Create src/types/project.ts with core type definitions: `export type PlcManufacturer = 'LS' | 'Mitsubishi' | 'Siemens'; export interface ProjectSettings { name: string; description: string; createdAt: string; updatedAt: string; } export interface PlcSettings { manufacturer: PlcManufacturer; model: string; scanTimeMs: number; } export interface ProjectData { config: ProjectConfig; isModified: boolean; } export interface RecentProject { name: string; path: string; lastOpened: string; }` and additional interfaces matching the Rust types from Task 3.",
            "status": "done",
            "testStrategy": "Verify all directories exist with proper structure. Import types in a test file and verify TypeScript recognizes them. Check path aliases work with the new directories.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T02:42:58.364Z"
          },
          {
            "id": 5,
            "title": "Implement Zustand Project Store and Base App Component",
            "description": "Create the Zustand store for project state management and update the base App.tsx component with Tailwind styling and store integration.",
            "dependencies": [
              4
            ],
            "details": "Create src/stores/projectStore.ts with Zustand: `import { create } from 'zustand'; import type { ProjectData, RecentProject } from '@types/project'; interface ProjectStore { currentProject: ProjectData | null; isModified: boolean; recentProjects: RecentProject[]; isLoading: boolean; error: string | null; setProject: (project: ProjectData | null) => void; setModified: (modified: boolean) => void; setRecentProjects: (projects: RecentProject[]) => void; setLoading: (loading: boolean) => void; setError: (error: string | null) => void; reset: () => void; } export const useProjectStore = create<ProjectStore>((set) => ({ currentProject: null, isModified: false, recentProjects: [], isLoading: false, error: null, setProject: (project) => set({ currentProject: project, isModified: false }), setModified: (modified) => set({ isModified: modified }), setRecentProjects: (projects) => set({ recentProjects: projects }), setLoading: (loading) => set({ isLoading: loading }), setError: (error) => set({ error }), reset: () => set({ currentProject: null, isModified: false, error: null }) }));` Update App.tsx with Tailwind classes and basic layout structure for the ModOne application shell.",
            "status": "done",
            "testStrategy": "Verify the Zustand store initializes correctly by checking initial state values. Test each action updates state properly. Use React DevTools with Zustand devtools to inspect state changes. Verify App.tsx renders with Tailwind styles applied.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T02:42:58.370Z"
          }
        ],
        "updatedAt": "2026-01-27T02:42:58.370Z"
      },
      {
        "id": "3",
        "title": "Define ProjectConfig and YAML Schema Types",
        "description": "Create Rust structs and TypeScript types for the config.yml schema including project settings, PLC configuration, and Modbus parameters.",
        "details": "1. Create Rust types in src-tauri/src/project/config.rs:\n   ```rust\n   use serde::{Deserialize, Serialize};\n   use chrono::{DateTime, Utc};\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub struct ProjectConfig {\n       pub version: String,\n       pub project: ProjectSettings,\n       pub plc: PlcSettings,\n       pub modbus: ModbusSettings,\n       pub memory_map: MemoryMapSettings,\n   }\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub struct ProjectSettings {\n       pub name: String,\n       pub description: String,\n       pub created_at: DateTime<Utc>,\n       pub updated_at: DateTime<Utc>,\n   }\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub struct PlcSettings {\n       pub manufacturer: PlcManufacturer,\n       pub model: String,\n       pub scan_time_ms: u32,\n   }\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub enum PlcManufacturer {\n       LS, Mitsubishi, Siemens\n   }\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub struct ModbusSettings {\n       pub tcp: ModbusTcpSettings,\n       pub rtu: ModbusRtuSettings,\n   }\n   // ... TCP and RTU settings structs\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub struct MemoryMapSettings {\n       pub coil_start: u16,\n       pub coil_count: u16,\n       pub discrete_input_start: u16,\n       pub discrete_input_count: u16,\n       pub holding_register_start: u16,\n       pub holding_register_count: u16,\n       pub input_register_start: u16,\n       pub input_register_count: u16,\n   }\n   ```\n2. Create mirror TypeScript types in src/types/project.ts:\n   ```typescript\n   export interface ProjectConfig {\n     version: string;\n     project: ProjectSettings;\n     plc: PlcSettings;\n     modbus: ModbusSettings;\n     memory_map: MemoryMapSettings;\n   }\n   // ... matching interfaces\n   ```\n3. Implement Default trait for ProjectConfig with sensible defaults\n4. Add validation methods for config values",
        "testStrategy": "1. Unit test YAML serialization/deserialization roundtrip in Rust\n2. Test default config generation produces valid YAML\n3. Test validation catches invalid values (negative ports, invalid enum variants)\n4. Verify TypeScript types match Rust struct serialization output",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Rust config.rs Module with Core ProjectConfig Struct",
            "description": "Create the src-tauri/src/project/config.rs file with the main ProjectConfig struct and its nested ProjectSettings, including serde derives for YAML serialization.",
            "dependencies": [],
            "details": "Create src-tauri/src/project/config.rs with the following structures: 1) Add imports for serde::{Deserialize, Serialize} and chrono::{DateTime, Utc}. 2) Define ProjectConfig struct with fields: version (String), project (ProjectSettings), plc (PlcSettings), modbus (ModbusSettings), memory_map (MemoryMapSettings). 3) Define ProjectSettings struct with fields: name (String), description (String), created_at (DateTime<Utc>), updated_at (DateTime<Utc>). All structs should derive Serialize, Deserialize, Clone, and Debug. Add #[serde(rename_all = \"snake_case\")] where appropriate to match YAML field naming convention from the PRD config.yml schema.",
            "status": "done",
            "testStrategy": "Run `cargo check` to verify the struct definitions compile. Write a simple test that creates a ProjectConfig instance and verifies all fields are accessible.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:16:20.222Z"
          },
          {
            "id": 2,
            "title": "Define PlcSettings Struct and PlcManufacturer Enum",
            "description": "Add the PlcSettings struct and PlcManufacturer enum to config.rs to handle PLC configuration including manufacturer, model, and scan time settings.",
            "dependencies": [
              1
            ],
            "details": "In src-tauri/src/project/config.rs, add: 1) PlcManufacturer enum with variants LS, Mitsubishi, and Siemens - derive Serialize, Deserialize, Clone, Debug, PartialEq. Add #[serde(rename_all = \"PascalCase\")] or explicit rename attributes to match YAML format (\"LS\", \"Mitsubishi\", \"Siemens\"). 2) PlcSettings struct with fields: manufacturer (PlcManufacturer), model (String), scan_time_ms (u32). Include serde attributes for snake_case serialization to match config.yml schema. Consider adding a FromStr implementation for PlcManufacturer to support parsing from string input in Tauri commands.",
            "status": "done",
            "testStrategy": "Write unit tests to verify PlcManufacturer serializes to correct YAML strings. Test deserialization from YAML string representation. Verify scan_time_ms accepts reasonable values.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:16:20.230Z"
          },
          {
            "id": 3,
            "title": "Implement ModbusSettings with TCP and RTU Configuration Structs",
            "description": "Create ModbusSettings struct with nested ModbusTcpSettings and ModbusRtuSettings structs to handle both Modbus communication protocols as defined in the PRD.",
            "dependencies": [
              1
            ],
            "details": "In src-tauri/src/project/config.rs, add: 1) ModbusSettings struct with fields: tcp (ModbusTcpSettings), rtu (ModbusRtuSettings). 2) ModbusTcpSettings struct with fields: enabled (bool), port (u16), unit_id (u8). 3) ModbusRtuSettings struct with fields: enabled (bool), com_port (String), baud_rate (u32), parity (Parity enum or String), stop_bits (u8). 4) Optionally create Parity enum with variants None, Even, Odd for type safety. All structs derive Serialize, Deserialize, Clone, Debug. Use #[serde(rename_all = \"snake_case\")] to match the YAML schema from PRD (tcp.enabled, rtu.com_port, etc.).",
            "status": "done",
            "testStrategy": "Write unit tests to serialize ModbusSettings to YAML and verify output matches PRD schema format. Test deserialization from sample YAML config. Verify port is within valid range 0-65535.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:16:20.236Z"
          },
          {
            "id": 4,
            "title": "Add MemoryMapSettings Struct and Implement Default Trait for ProjectConfig",
            "description": "Create MemoryMapSettings struct for Modbus memory mapping configuration and implement the Default trait for all config structs with sensible production defaults.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "In src-tauri/src/project/config.rs: 1) Create MemoryMapSettings struct with u16 fields: coil_start, coil_count, discrete_input_start, discrete_input_count, holding_register_start, holding_register_count, input_register_start, input_register_count. 2) Implement Default trait for all structs with values matching PRD defaults: version=\"1.0\", scan_time_ms=10, tcp.port=502, tcp.unit_id=1, tcp.enabled=true, rtu.enabled=false, rtu.baud_rate=9600, all memory counts=1000, all starts=0. 3) For ProjectSettings default, use empty strings for name/description and Utc::now() for timestamps. 4) Export config module from project/mod.rs (create mod.rs if needed with `pub mod config;`).",
            "status": "done",
            "testStrategy": "Test that ProjectConfig::default() produces valid configuration. Serialize default config to YAML and verify it matches PRD example. Test that all numeric defaults are within valid ranges.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:16:20.243Z"
          },
          {
            "id": 5,
            "title": "Create TypeScript Mirror Types in src/types/project.ts",
            "description": "Create TypeScript interfaces in the frontend that mirror the Rust structs to ensure type-safe communication between Tauri backend and React frontend.",
            "dependencies": [
              4
            ],
            "details": "Create or update src/types/project.ts with: 1) PlcManufacturer type as union literal: type PlcManufacturer = 'LS' | 'Mitsubishi' | 'Siemens'. 2) ProjectConfig interface with fields: version (string), project (ProjectSettings), plc (PlcSettings), modbus (ModbusSettings), memory_map (MemoryMapSettings). 3) ProjectSettings interface: name (string), description (string), created_at (string - ISO8601), updated_at (string). 4) PlcSettings interface: manufacturer (PlcManufacturer), model (string), scan_time_ms (number). 5) ModbusSettings, ModbusTcpSettings, ModbusRtuSettings interfaces matching Rust structs. 6) MemoryMapSettings interface with all u16 fields as number type. Use snake_case for property names to match Rust serde serialization. Export all types. If the file already exists from Task 2, extend it with these additional interfaces.",
            "status": "done",
            "testStrategy": "Verify TypeScript compiles without errors using `npx tsc --noEmit`. Create a sample object matching ProjectConfig interface and verify it type-checks correctly. Compare field names with Rust struct serialization output to ensure they match.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:16:20.314Z"
          }
        ],
        "updatedAt": "2026-01-27T03:16:20.314Z"
      },
      {
        "id": "4",
        "title": "Implement .mop ZIP Archive Handler",
        "description": "Create the MopFile module to handle ZIP compression/decompression of .mop project files with proper directory structure.",
        "details": "1. Create src-tauri/src/project/mop_file.rs:\n   ```rust\n   use std::path::{Path, PathBuf};\n   use std::fs::{self, File};\n   use std::io::{Read, Write};\n   use zip::{ZipArchive, ZipWriter, write::FileOptions};\n   use tempfile::TempDir;\n   use thiserror::Error;\n\n   #[derive(Error, Debug)]\n   pub enum MopFileError {\n       #[error(\"IO error: {0}\")]\n       Io(#[from] std::io::Error),\n       #[error(\"ZIP error: {0}\")]\n       Zip(#[from] zip::result::ZipError),\n       #[error(\"Invalid .mop structure: {0}\")]\n       InvalidStructure(String),\n       #[error(\"Config parse error: {0}\")]\n       ConfigParse(#[from] serde_yaml::Error),\n   }\n\n   pub struct MopFile {\n       pub temp_dir: TempDir,\n       pub source_path: Option<PathBuf>,\n   }\n\n   impl MopFile {\n       /// Extract .mop file to temporary directory\n       pub fn open(path: &Path) -> Result<Self, MopFileError>;\n\n       /// Create new .mop structure in temporary directory\n       pub fn create_new() -> Result<Self, MopFileError>;\n\n       /// Save to .mop file (ZIP compress)\n       pub fn save(&self, path: &Path) -> Result<(), MopFileError>;\n\n       /// Get path to config.yml\n       pub fn config_path(&self) -> PathBuf;\n\n       /// Get path to plc_csv directory\n       pub fn plc_csv_dir(&self) -> PathBuf;\n\n       /// Validate .mop structure\n       fn validate_structure(&self) -> Result<(), MopFileError>;\n   }\n   ```\n2. Implement recursive ZIP extraction preserving directory structure\n3. Implement recursive ZIP compression of temp directory\n4. Create helper methods for accessing subdirectories:\n   - modone/config.yml\n   - plc_csv/\n   - one_canvas/\n   - mod_server_memory.csv\n   - scenario.csv\n5. Handle file encoding (UTF-8 for text files)\n6. Implement cleanup on Drop for temporary directory",
        "testStrategy": "1. Test creating new .mop file with default structure\n2. Test opening existing .mop file and verifying extracted contents\n3. Test save/load roundtrip preserves all files and directory structure\n4. Test error handling for corrupted ZIP files\n5. Test error handling for missing required files (config.yml)\n6. Verify temporary directory cleanup on MopFile drop",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create mop_file.rs Module with Error Types and MopFile Struct",
            "description": "Create the src-tauri/src/project/mop_file.rs file with MopFileError enum using thiserror and the base MopFile struct with TempDir and source_path fields.",
            "dependencies": [],
            "details": "Create src-tauri/src/project/mop_file.rs with the following: 1) Add imports for std::path::{Path, PathBuf}, std::fs::{self, File}, std::io::{Read, Write, BufReader, BufWriter}, zip::{ZipArchive, ZipWriter, write::SimpleFileOptions}, tempfile::TempDir, and thiserror::Error. 2) Define MopFileError enum with variants: Io(#[from] std::io::Error), Zip(#[from] zip::result::ZipError), InvalidStructure(String), ConfigParse(#[from] serde_yaml::Error). 3) Define MopFile struct with fields: temp_dir (TempDir), source_path (Option<PathBuf>). 4) Add constants for required paths: MODONE_DIR=\"modone\", CONFIG_FILE=\"modone/config.yml\", PLC_CSV_DIR=\"plc_csv\", ONE_CANVAS_DIR=\"one_canvas\", MOD_SERVER_MEMORY_FILE=\"mod_server_memory.csv\", SCENARIO_FILE=\"scenario.csv\". 5) Export this module from project/mod.rs with `pub mod mop_file;`. Note: zip crate version 0.6+ uses SimpleFileOptions instead of FileOptions.",
            "status": "done",
            "testStrategy": "Run `cargo check` in src-tauri/ to verify the struct and error definitions compile. Verify TempDir and PathBuf types are correctly imported. Test that MopFileError variants can be constructed manually.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:31:01.106Z"
          },
          {
            "id": 2,
            "title": "Implement create_new() and Helper Path Methods",
            "description": "Implement the MopFile::create_new() constructor to initialize a new .mop structure in a temporary directory with all required subdirectories and empty files.",
            "dependencies": [
              1
            ],
            "details": "In mop_file.rs, implement: 1) MopFile::create_new() -> Result<Self, MopFileError> that creates a TempDir, then creates the directory structure: modone/, plc_csv/, one_canvas/. Create empty placeholder files: mod_server_memory.csv, scenario.csv with UTF-8 BOM or header if appropriate. Do NOT create config.yml here - it will be created by ProjectManager with actual values. 2) Add helper methods: config_path(&self) -> PathBuf returns temp_dir.path().join(\"modone/config.yml\"), plc_csv_dir(&self) -> PathBuf returns temp_dir.path().join(\"plc_csv\"), one_canvas_dir(&self) -> PathBuf returns temp_dir.path().join(\"one_canvas\"), mod_server_memory_path(&self) -> PathBuf, scenario_path(&self) -> PathBuf. 3) Add root_path(&self) -> &Path helper returning temp_dir.path(). Use fs::create_dir_all for nested directory creation.",
            "status": "done",
            "testStrategy": "Write unit test that calls create_new() and verifies all directories exist using fs::metadata(). Check that helper path methods return correct absolute paths. Verify the TempDir is created in system temp location.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:31:01.114Z"
          },
          {
            "id": 3,
            "title": "Implement open() for ZIP Extraction with Recursive Directory Support",
            "description": "Implement MopFile::open(path) to extract a .mop ZIP file to a temporary directory, preserving the complete directory structure recursively.",
            "dependencies": [
              1
            ],
            "details": "Implement MopFile::open(path: &Path) -> Result<Self, MopFileError>: 1) Create TempDir for extraction target. 2) Open the .mop file using File::open and create ZipArchive::new(BufReader::new(file)). 3) Iterate through all entries with archive.by_index(i): a) For directories (name ends with '/'), create with fs::create_dir_all. b) For files, ensure parent directory exists, then create file and copy contents. c) Preserve UTF-8 encoding by reading as bytes and writing bytes directly. 4) Handle path traversal security by checking that extracted paths don't escape temp_dir using Path::starts_with(). 5) Store source_path as Some(path.to_path_buf()). 6) Call validate_structure() before returning. Important: Handle both forward slash and backslash in ZIP entry names for cross-platform compatibility.",
            "status": "done",
            "testStrategy": "Create a test .mop file manually with known structure, extract it using open(), verify all files and directories exist at expected locations. Test that file contents are preserved byte-for-byte. Test error handling with a corrupted ZIP file.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:31:01.121Z"
          },
          {
            "id": 4,
            "title": "Implement save() for Recursive ZIP Compression",
            "description": "Implement MopFile::save(path) to compress the temporary directory contents into a .mop ZIP archive, preserving the complete directory structure.",
            "dependencies": [
              2
            ],
            "details": "Implement MopFile::save(&self, path: &Path) -> Result<(), MopFileError>: 1) Create output file with File::create and wrap in ZipWriter::new(BufWriter::new(file)). 2) Create a recursive helper function add_directory_to_zip(zip: &mut ZipWriter, base_path: &Path, current_path: &Path) that: a) Uses fs::read_dir to iterate entries. b) For directories, adds them to ZIP with trailing slash and recurses. c) For files, reads contents and adds with correct relative path. 3) Use SimpleFileOptions::default().compression_method(zip::CompressionMethod::Deflated) for compression. 4) Calculate relative paths from temp_dir root for ZIP entry names. 5) Use forward slashes in ZIP paths for cross-platform compatibility. 6) Call zip.finish() to finalize the archive. 7) Update source_path to Some(path.to_path_buf()) after successful save.",
            "status": "done",
            "testStrategy": "Create a MopFile with create_new(), add some test files to its directories, call save(), then open the saved .mop with open() and verify all contents match. Test save/load roundtrip preserves file contents and directory structure exactly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:31:01.129Z"
          },
          {
            "id": 5,
            "title": "Implement validate_structure() and Ensure TempDir Cleanup on Drop",
            "description": "Implement structure validation to check for required files/directories in the .mop archive, and verify that TempDir automatically cleans up when MopFile is dropped.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement validate_structure(&self) -> Result<(), MopFileError>: 1) Check that modone/ directory exists using self.temp_dir.path().join(\"modone\").is_dir(). 2) Optionally check for config.yml existence (may be lenient for new projects). 3) Return Err(MopFileError::InvalidStructure(message)) with descriptive message if validation fails, e.g., \"Missing required directory: modone/\". 4) TempDir from tempfile crate automatically implements Drop to clean up the directory - no manual implementation needed. 5) Add a test to verify cleanup: create MopFile, get temp path, drop MopFile, verify path no longer exists. 6) Consider adding a validate_config() method that attempts to parse config.yml and returns the result. 7) Add #[derive(Debug)] to MopFile for debugging purposes. Note: TempDir's drop behavior is automatic - just ensure temp_dir field is not leaked.",
            "status": "done",
            "testStrategy": "Test validate_structure() catches missing modone/ directory. Test with valid structure passes validation. Create MopFile in a scope, capture temp path, exit scope, verify directory is deleted. Test that opening invalid .mop without modone/ returns appropriate InvalidStructure error.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:31:01.136Z"
          }
        ],
        "updatedAt": "2026-01-27T03:31:01.136Z"
      },
      {
        "id": "5",
        "title": "Implement Project Manager State",
        "description": "Create the ProjectManager struct to maintain the current project state, handle lifecycle events, and coordinate between subsystems.",
        "details": "1. Create src-tauri/src/project/mod.rs with ProjectManager:\n   ```rust\n   use std::sync::{Arc, Mutex};\n   use std::path::PathBuf;\n   use chrono::{DateTime, Utc};\n\n   pub struct ProjectManager {\n       current: Option<LoadedProject>,\n       recent_projects: Vec<RecentProject>,\n       auto_save_enabled: bool,\n       auto_save_interval_secs: u64,\n   }\n\n   pub struct LoadedProject {\n       pub mop_file: MopFile,\n       pub config: ProjectConfig,\n       pub is_modified: bool,\n       pub canvas_data: Option<CanvasData>,\n       pub scenario_data: Option<ScenarioData>,\n       pub memory_snapshot: Option<MemorySnapshot>,\n   }\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub struct RecentProject {\n       pub name: String,\n       pub path: PathBuf,\n       pub last_opened: DateTime<Utc>,\n   }\n\n   impl ProjectManager {\n       pub fn new() -> Self;\n       pub fn create_project(&mut self, name: String, path: PathBuf, plc: PlcSettings) -> Result<ProjectInfo>;\n       pub fn open_project(&mut self, path: PathBuf) -> Result<ProjectData>;\n       pub fn save_project(&mut self, path: Option<PathBuf>) -> Result<()>;\n       pub fn close_project(&mut self) -> Result<()>;\n       pub fn mark_modified(&mut self);\n       pub fn get_recent_projects(&self) -> Vec<RecentProject>;\n       fn add_to_recent(&mut self, project: &RecentProject);\n       fn persist_recent_projects(&self) -> Result<()>;\n   }\n   ```\n2. Use Arc<Mutex<ProjectManager>> for thread-safe state in Tauri\n3. Store recent projects in app data directory\n4. Implement modified flag tracking for unsaved changes warning\n5. Create placeholder structs for CanvasData, ScenarioData, MemorySnapshot (to be implemented in later units)",
        "testStrategy": "1. Test project creation initializes correct state\n2. Test open/close lifecycle transitions\n3. Test recent projects list updates and persists\n4. Test modified flag behavior\n5. Test concurrent access safety with Arc<Mutex>\n6. Test save with modified data updates timestamp",
        "priority": "high",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Placeholder Data Types and LoadedProject Struct",
            "description": "Define placeholder structs for CanvasData, ScenarioData, and MemorySnapshot that will be implemented in later units, along with the LoadedProject struct that holds the currently open project state.",
            "dependencies": [],
            "details": "In src-tauri/src/project/mod.rs, add the following placeholder types with derive macros: 1) CanvasData struct with a single Option<serde_json::Value> field called 'data' to hold arbitrary canvas state until Unit 5 implements the real structure. 2) ScenarioData struct with Option<serde_json::Value> field for scenario editor data (Unit 6). 3) MemorySnapshot struct with Option<serde_json::Value> field for Modbus memory state (Unit 3). 4) Define LoadedProject struct with fields: mop_file (MopFile from mop_file.rs), config (ProjectConfig from config.rs), is_modified (bool), canvas_data (Option<CanvasData>), scenario_data (Option<ScenarioData>), memory_snapshot (Option<MemorySnapshot>). All structs should derive Debug and Clone where possible. LoadedProject cannot derive Clone due to MopFile containing TempDir. Add comments indicating which unit will fully implement each placeholder.",
            "status": "done",
            "testStrategy": "Run `cargo check` to verify all struct definitions compile. Create a test that instantiates LoadedProject with default/None values for optional fields. Verify the is_modified field can be set and read correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:20:15.160Z"
          },
          {
            "id": 2,
            "title": "Define RecentProject Struct and Persistence Methods",
            "description": "Create the RecentProject struct with serialization support and implement persistence to the application data directory using Tauri's path resolver.",
            "dependencies": [],
            "details": "In src-tauri/src/project/mod.rs, add: 1) RecentProject struct with fields: name (String), path (PathBuf), last_opened (DateTime<Utc>). Derive Serialize, Deserialize, Clone, Debug. 2) Create a private helper function get_recent_projects_path() -> Option<PathBuf> that returns the path to recent_projects.json in the app data directory. For now, use directories::ProjectDirs::from(\"com\", \"modone\", \"ModOne\") to get the config dir (add 'directories' crate to Cargo.toml, or use a hardcoded path as placeholder until Tauri's app_data_dir is available at runtime). 3) Create load_recent_projects() -> Vec<RecentProject> that reads and deserializes from the JSON file, returning empty vec if file doesn't exist. 4) Create save_recent_projects(projects: &[RecentProject]) -> Result<(), std::io::Error> that serializes and writes to the JSON file, creating parent directories if needed. Limit the list to 10 most recent projects.",
            "status": "done",
            "testStrategy": "Write unit tests for serialization roundtrip of RecentProject. Test load_recent_projects returns empty vec when file doesn't exist. Test save_recent_projects creates the file and parent directories. Test that saving more than 10 projects keeps only the 10 most recent.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:20:15.169Z"
          },
          {
            "id": 3,
            "title": "Create ProjectManager Struct with Constructor and Basic Accessors",
            "description": "Define the main ProjectManager struct with all required fields and implement the new() constructor that initializes state and loads recent projects from disk.",
            "dependencies": [
              1,
              2
            ],
            "details": "In src-tauri/src/project/mod.rs, add: 1) ProjectManager struct with fields: current (Option<LoadedProject>), recent_projects (Vec<RecentProject>), auto_save_enabled (bool, default true), auto_save_interval_secs (u64, default 300). 2) Implement ProjectManager::new() -> Self that initializes all fields with defaults and calls load_recent_projects() to populate the recent_projects field. 3) Add getter methods: get_current_project(&self) -> Option<&LoadedProject>, is_project_open(&self) -> bool, get_recent_projects(&self) -> &[RecentProject], is_modified(&self) -> bool (returns current project's is_modified or false if no project open). 4) Add mark_modified(&mut self) method that sets current project's is_modified to true if a project is open. 5) Ensure the module properly exports all public types with `pub use` statements for ProjectManager, LoadedProject, RecentProject, and placeholder types.",
            "status": "done",
            "testStrategy": "Test that ProjectManager::new() returns a manager with no current project. Test is_project_open() returns false initially. Test mark_modified() does nothing when no project is open. Test get_recent_projects() returns whatever was loaded from disk.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:20:15.175Z"
          },
          {
            "id": 4,
            "title": "Implement create_project, open_project, and close_project Methods",
            "description": "Implement the core project lifecycle methods that create new projects, open existing .mop files, and properly close/cleanup the current project.",
            "dependencies": [
              3
            ],
            "details": "Implement the following methods on ProjectManager: 1) create_project(&mut self, name: String, path: PathBuf, plc: PlcSettings) -> Result<ProjectInfo, MopFileError>: Create new MopFile with MopFile::create_new(), create ProjectConfig with provided name and plc settings using Utc::now() for timestamps, write config.yml to mop_file.config_path() using serde_yaml::to_writer, save the .mop file to path, set self.current to new LoadedProject with the mop_file and config, call add_to_recent(), return ProjectInfo with name, path, created_at. 2) open_project(&mut self, path: PathBuf) -> Result<ProjectData, MopFileError>: Call close_project() first if a project is open, open MopFile with MopFile::open(&path), read and parse config.yml using serde_yaml::from_reader, create LoadedProject with parsed config and is_modified=false, set self.current, call add_to_recent(), return ProjectData with config and None for optional data. 3) close_project(&mut self) -> Result<(), MopFileError>: If current is Some and is_modified, return an error indicating unsaved changes (or just clear - design choice). Set self.current to None. The MopFile's TempDir will auto-cleanup on drop. 4) Add private add_to_recent(&mut self, name: String, path: PathBuf) that creates RecentProject with Utc::now(), adds to front of recent_projects, removes duplicates by path, truncates to 10, calls save_recent_projects().",
            "status": "done",
            "testStrategy": "Test create_project creates a valid .mop file at the specified path. Test open_project successfully opens a previously created project. Test open_project with already open project closes the previous one first. Test close_project clears current project. Test recent projects list is updated after create and open operations.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:20:15.180Z"
          },
          {
            "id": 5,
            "title": "Implement save_project and Document Arc<Mutex> Usage Pattern",
            "description": "Implement the save_project method with 'Save As' support and add comprehensive documentation showing how to wrap ProjectManager in Arc<Mutex> for thread-safe Tauri state management.",
            "dependencies": [
              4
            ],
            "details": "1) Implement save_project(&mut self, path: Option<PathBuf>) -> Result<(), MopFileError>: If current is None, return error. If path is Some, use it (Save As), otherwise use current project's mop_file.source_path (must exist for regular Save). Update config.updated_at to Utc::now(). Write config.yml to mop_file.config_path(). Call mop_file.save(&save_path). If Save As, update mop_file.source_path and add_to_recent with new path. Set current.is_modified to false. 2) Add module-level documentation in mod.rs explaining the Arc<Mutex<ProjectManager>> pattern: show example code of how to create the manager, wrap it, and pass to Tauri's .manage(). Include example of acquiring lock in async command handler with map_err for PoisonError. 3) Create a public type alias: `pub type SharedProjectManager = Arc<Mutex<ProjectManager>>;` for convenience. 4) Add a helper constructor: `pub fn new_shared() -> SharedProjectManager { Arc::new(Mutex::new(ProjectManager::new())) }` for easy initialization in main.rs. 5) Update the config module import in mod.rs to properly re-export ProjectConfig and PlcSettings if needed.",
            "status": "done",
            "testStrategy": "Test save_project returns error when no project is open. Test save_project with None path uses original source path. Test save_project with Some path saves to new location (Save As). Test is_modified is set to false after successful save. Test updated_at timestamp is updated. Test concurrent access using Arc<Mutex> wrapper with multiple threads trying to mark_modified simultaneously.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:20:15.186Z"
          }
        ],
        "updatedAt": "2026-01-27T04:20:15.186Z"
      },
      {
        "id": "6",
        "title": "Implement Tauri Commands for Project CRUD",
        "description": "Create Tauri command handlers that expose project operations to the frontend including create, open, save, and close functionality.",
        "details": "1. Create src-tauri/src/commands/project.rs:\n   ```rust\n   use tauri::State;\n   use std::sync::Mutex;\n   use crate::project::{ProjectManager, ProjectInfo, ProjectData, RecentProject};\n\n   #[tauri::command]\n   pub async fn create_project(\n       state: State<'_, Mutex<ProjectManager>>,\n       name: String,\n       path: std::path::PathBuf,\n       plc_manufacturer: String,\n       plc_model: String,\n   ) -> Result<ProjectInfo, String> {\n       let mut manager = state.lock().map_err(|e| e.to_string())?;\n       manager.create_project(name, path, PlcSettings {\n           manufacturer: plc_manufacturer.parse()?,\n           model: plc_model,\n           scan_time_ms: 10,\n       }).map_err(|e| e.to_string())\n   }\n\n   #[tauri::command]\n   pub async fn open_project(\n       state: State<'_, Mutex<ProjectManager>>,\n       path: std::path::PathBuf,\n   ) -> Result<ProjectData, String>;\n\n   #[tauri::command]\n   pub async fn save_project(\n       state: State<'_, Mutex<ProjectManager>>,\n       path: Option<std::path::PathBuf>,\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn close_project(\n       state: State<'_, Mutex<ProjectManager>>,\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn get_recent_projects(\n       state: State<'_, Mutex<ProjectManager>>,\n   ) -> Result<Vec<RecentProject>, String>;\n   ```\n2. Register commands in main.rs:\n   ```rust\n   tauri::Builder::default()\n       .manage(Mutex::new(ProjectManager::new()))\n       .invoke_handler(tauri::generate_handler![\n           create_project,\n           open_project,\n           save_project,\n           close_project,\n           get_recent_projects,\n       ])\n   ```\n3. Create src-tauri/src/commands/mod.rs to export all commands\n4. Add proper error handling with meaningful error messages",
        "testStrategy": "1. Integration test: create_project creates valid .mop file\n2. Integration test: open_project loads and returns correct data\n3. Integration test: save_project persists changes to disk\n4. Integration test: close_project cleans up state\n5. Test error responses for invalid paths, missing files\n6. Test command registration with Tauri builder",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create commands/mod.rs Module Structure and project.rs File",
            "description": "Set up the Tauri commands module structure by creating src-tauri/src/commands/mod.rs and src-tauri/src/commands/project.rs with necessary imports.",
            "dependencies": [],
            "details": "Create src-tauri/src/commands/mod.rs with `pub mod project;` to export the project commands module. Create src-tauri/src/commands/project.rs with imports: `use tauri::State; use std::sync::Mutex; use std::path::PathBuf;` and import types from the project module: `use crate::project::{ProjectManager, ProjectConfig, RecentProject}; use crate::project::config::PlcSettings;`. Ensure main.rs includes `mod commands;` declaration. The file should be prepared for adding Tauri command handlers in subsequent subtasks.",
            "status": "done",
            "testStrategy": "Run `cargo check` in src-tauri/ to verify the module structure compiles without errors. Verify both mod.rs and project.rs files exist in the commands directory.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:22:02.343Z"
          },
          {
            "id": 2,
            "title": "Implement create_project Tauri Command Handler",
            "description": "Create the #[tauri::command] handler for create_project that accepts project parameters and delegates to ProjectManager::create_project.",
            "dependencies": [
              1
            ],
            "details": "In src-tauri/src/commands/project.rs, implement: `#[tauri::command] pub async fn create_project(state: State<'_, Mutex<ProjectManager>>, name: String, path: PathBuf, plc_manufacturer: String, plc_model: String) -> Result<ProjectInfo, String>`. Inside the handler: 1) Acquire the mutex lock with `state.lock().map_err(|e| format!(\"Lock error: {}\", e))?`. 2) Parse plc_manufacturer string into PlcManufacturer enum using FromStr or match statement. 3) Create PlcSettings with manufacturer, model, and default scan_time_ms of 10. 4) Call manager.create_project(name, path, plc_settings) and map_err to String for Tauri serialization. 5) Define or import ProjectInfo struct with fields: name (String), path (PathBuf), created_at (String ISO8601). Return the ProjectInfo on success.",
            "status": "done",
            "testStrategy": "Write unit test that mocks State<Mutex<ProjectManager>> and verifies create_project correctly parses parameters and calls the manager method. Test error handling for invalid plc_manufacturer values.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:22:02.351Z"
          },
          {
            "id": 3,
            "title": "Implement open_project and close_project Tauri Commands",
            "description": "Create the #[tauri::command] handlers for open_project to load existing .mop files and close_project to clean up the current project state.",
            "dependencies": [
              1
            ],
            "details": "In src-tauri/src/commands/project.rs, implement: 1) `#[tauri::command] pub async fn open_project(state: State<'_, Mutex<ProjectManager>>, path: PathBuf) -> Result<ProjectData, String>` - Acquire lock, call manager.open_project(path), map error to String, return ProjectData containing config and optional canvas/scenario/memory data. 2) `#[tauri::command] pub async fn close_project(state: State<'_, Mutex<ProjectManager>>) -> Result<(), String>` - Acquire lock, call manager.close_project(), return Ok(()) on success. Define ProjectData struct with fields: config (ProjectConfig), canvas_data (Option<serde_json::Value>), scenario_data (Option<serde_json::Value>), memory_snapshot (Option<serde_json::Value>), is_modified (bool). Ensure all return types derive Serialize for Tauri IPC.",
            "status": "done",
            "testStrategy": "Test open_project with valid .mop file path returns correctly structured ProjectData. Test close_project clears the current project state. Test error messages are descriptive for invalid paths or missing files.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:22:02.357Z"
          },
          {
            "id": 4,
            "title": "Implement save_project and get_recent_projects Tauri Commands",
            "description": "Create the #[tauri::command] handlers for save_project with Save/Save As support and get_recent_projects to retrieve the recent projects list.",
            "dependencies": [
              1
            ],
            "details": "In src-tauri/src/commands/project.rs, implement: 1) `#[tauri::command] pub async fn save_project(state: State<'_, Mutex<ProjectManager>>, path: Option<PathBuf>) -> Result<(), String>` - Acquire lock, call manager.save_project(path) where None means save to current path and Some(path) means Save As to new path. Map errors to descriptive strings like 'No project open to save' or 'Failed to write file: {reason}'. 2) `#[tauri::command] pub async fn get_recent_projects(state: State<'_, Mutex<ProjectManager>>) -> Result<Vec<RecentProject>, String>` - Acquire lock, call manager.get_recent_projects().to_vec() to clone the list, return it. Ensure RecentProject derives Serialize with fields: name, path, last_opened (all serializable).",
            "status": "done",
            "testStrategy": "Test save_project with None path saves to original location. Test save_project with Some path performs Save As. Test get_recent_projects returns the list in correct order (most recent first). Test error when saving with no project open.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:22:02.364Z"
          },
          {
            "id": 5,
            "title": "Register Commands in main.rs with Tauri Builder",
            "description": "Update src-tauri/src/main.rs to register the ProjectManager state and all project commands with the Tauri builder invoke handler.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Update src-tauri/src/main.rs to: 1) Import commands module with `mod commands;` and bring commands into scope: `use commands::project::{create_project, open_project, save_project, close_project, get_recent_projects};`. 2) Import ProjectManager: `use crate::project::ProjectManager;` and std::sync::Mutex. 3) In the Tauri builder chain, add `.manage(Mutex::new(ProjectManager::new()))` to register the shared state. 4) Update .invoke_handler to: `tauri::generate_handler![create_project, open_project, save_project, close_project, get_recent_projects]`. 5) Ensure the builder chain includes .run() with proper error handling. Add comment indicating commands are ready for frontend invocation via @tauri-apps/api invoke.",
            "status": "done",
            "testStrategy": "Run `cargo build` to verify all commands are correctly registered and compile. Run `npm run tauri dev` to verify the application starts without command registration errors. Test invoking a command from the frontend dev console to verify IPC works.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:22:02.370Z"
          }
        ],
        "updatedAt": "2026-01-27T04:22:02.370Z"
      },
      {
        "id": "7",
        "title": "Create Frontend Project Service and Hooks",
        "description": "Implement TypeScript service layer and React hooks for invoking Tauri commands and managing project state in the frontend.",
        "details": "1. Create src/services/projectService.ts:\n   ```typescript\n   import { invoke } from '@tauri-apps/api/core';\n   import type { ProjectInfo, ProjectData, RecentProject, PlcManufacturer } from '../types/project';\n\n   export const projectService = {\n     async createProject(name: string, path: string, plcManufacturer: PlcManufacturer, plcModel: string): Promise<ProjectInfo> {\n       return invoke('create_project', { name, path, plcManufacturer, plcModel });\n     },\n\n     async openProject(path: string): Promise<ProjectData> {\n       return invoke('open_project', { path });\n     },\n\n     async saveProject(path?: string): Promise<void> {\n       return invoke('save_project', { path });\n     },\n\n     async closeProject(): Promise<void> {\n       return invoke('close_project');\n     },\n\n     async getRecentProjects(): Promise<RecentProject[]> {\n       return invoke('get_recent_projects');\n     },\n   };\n   ```\n2. Create src/hooks/useProject.ts:\n   ```typescript\n   import { useCallback } from 'react';\n   import { useProjectStore } from '../stores/projectStore';\n   import { projectService } from '../services/projectService';\n\n   export function useProject() {\n     const { currentProject, setProject, setModified, recentProjects, setRecentProjects } = useProjectStore();\n\n     const createProject = useCallback(async (...args) => {\n       const info = await projectService.createProject(...args);\n       const data = await projectService.openProject(info.path);\n       setProject(data);\n       return info;\n     }, [setProject]);\n\n     const openProject = useCallback(async (path: string) => {\n       const data = await projectService.openProject(path);\n       setProject(data);\n       await refreshRecentProjects();\n       return data;\n     }, [setProject]);\n\n     // ... save, close, etc.\n\n     return { currentProject, createProject, openProject, saveProject, closeProject, recentProjects };\n   }\n   ```\n3. Update Zustand store with proper actions and state\n4. Add error handling with toast notifications or error boundaries",
        "testStrategy": "1. Mock Tauri invoke for unit testing service layer\n2. Test hook state transitions with React Testing Library\n3. Test error handling surfaces errors to UI\n4. Integration test with actual Tauri backend\n5. Test loading states during async operations",
        "priority": "medium",
        "dependencies": [
          "2",
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create projectService.ts with Tauri Invoke Wrappers",
            "description": "Create the src/services/projectService.ts file that wraps all Tauri backend commands for project CRUD operations using the @tauri-apps/api invoke function.",
            "dependencies": [],
            "details": "Create src/services/projectService.ts with the following implementation: 1) Import invoke from '@tauri-apps/api/core' and import types from '@/types/project': ProjectInfo, ProjectData, RecentProject, PlcManufacturer. 2) Define the projectService object with async methods: createProject(name: string, path: string, plcManufacturer: PlcManufacturer, plcModel: string) calls invoke('create_project', { name, path, plc_manufacturer: plcManufacturer, plc_model: plcModel }) - note snake_case for Rust parameters. openProject(path: string) calls invoke('open_project', { path }). saveProject(path?: string) calls invoke('save_project', { path: path ?? null }). closeProject() calls invoke('close_project'). getRecentProjects() calls invoke('get_recent_projects'). 3) Export the projectService object as named export. Ensure all return types are properly typed with Promise<T> matching the TypeScript types from Task 3.5.",
            "status": "done",
            "testStrategy": "Create a mock for @tauri-apps/api/core invoke function using vitest or jest. Test each service method calls invoke with correct command name and parameter structure. Verify parameter names use snake_case to match Rust command expectations. Test that return types are correctly inferred.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T07:41:56.022Z"
          },
          {
            "id": 2,
            "title": "Extend Zustand projectStore with Additional Actions",
            "description": "Update the existing Zustand projectStore from Task 2.5 to add additional actions needed for the useProject hook including clearError, setCurrentProjectPath, and refreshRecentProjects placeholder.",
            "dependencies": [
              1
            ],
            "details": "Update src/stores/projectStore.ts created in Task 2.5 to add: 1) Add currentProjectPath: string | null field to track the file path of the open project separately from project data. 2) Add setCurrentProjectPath: (path: string | null) => void action. 3) Add clearError: () => void action that sets error to null. 4) Modify the setProject action to also accept an optional path parameter and call setCurrentProjectPath. 5) Add updateConfig: (config: Partial<ProjectConfig>) => void action that merges config changes and sets isModified to true. 6) Consider adding a loadingOperation: string | null field to track which operation is loading (e.g., 'create', 'open', 'save') for more granular loading states. 7) Ensure all new actions are properly typed in the ProjectStore interface. The store should work with the types defined in Task 3.5.",
            "status": "done",
            "testStrategy": "Test setCurrentProjectPath updates the path correctly. Test clearError resets error to null. Test updateConfig merges partial config and sets isModified to true. Test setProject with path parameter updates both project and path. Verify initial state values for new fields.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T07:41:56.028Z"
          },
          {
            "id": 3,
            "title": "Implement useProject Hook with Core Operations",
            "description": "Create src/hooks/useProject.ts custom React hook that combines projectService calls with Zustand store updates for create, open, save, and close project operations.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create src/hooks/useProject.ts with: 1) Import useCallback from 'react', useProjectStore from '@/stores/projectStore', and projectService from '@/services/projectService'. 2) Export function useProject() that destructures needed state and actions from useProjectStore(). 3) Implement createProject callback: set loading true, call projectService.createProject(), then call projectService.openProject(info.path) to load the created project data, update store with setProject and setCurrentProjectPath, refresh recent projects, set loading false. Wrap in try/catch to setError on failure. 4) Implement openProject callback: set loading, call projectService.openProject(path), update store with project data and path, refresh recent projects, handle errors. 5) Implement saveProject callback: set loading, call projectService.saveProject(path), set isModified to false on success, handle errors. If path provided (Save As), update currentProjectPath. 6) Implement closeProject callback: check isModified first (could return boolean indicating unsaved changes), call projectService.closeProject(), reset store state. 7) Return object with: currentProject, currentProjectPath, isModified, isLoading, error, recentProjects, and all operation callbacks.",
            "status": "done",
            "testStrategy": "Mock projectService and useProjectStore for unit testing. Test createProject calls service then opens project and updates store. Test openProject updates store with returned data. Test saveProject with and without path parameter. Test closeProject resets store state. Test error handling sets error state and clears loading. Test loading state transitions for each operation.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T07:41:56.034Z"
          },
          {
            "id": 4,
            "title": "Add Recent Projects Management to useProject Hook",
            "description": "Extend the useProject hook with refreshRecentProjects, removeFromRecentProjects functionality and initialize recent projects on hook mount using useEffect.",
            "dependencies": [
              3
            ],
            "details": "In src/hooks/useProject.ts, add: 1) Import useEffect from 'react'. 2) Implement refreshRecentProjects callback that calls projectService.getRecentProjects() and updates store with setRecentProjects. Include error handling that doesn't throw but logs to console. 3) Add useEffect that calls refreshRecentProjects() on component mount (empty dependency array) to populate recent projects when the app starts. 4) Consider adding a removeFromRecentProjects(path: string) callback - this may require a new Tauri command in the backend, so for now create a placeholder that filters the local recentProjects state (note: this won't persist without backend support). 5) Add openRecentProject(recentProject: RecentProject) convenience callback that calls openProject(recentProject.path). 6) Ensure all callbacks use useCallback with proper dependencies to prevent unnecessary re-renders. 7) Export these new functions from the hook's return object.",
            "status": "done",
            "testStrategy": "Test refreshRecentProjects calls service and updates store. Test useEffect triggers refreshRecentProjects on mount. Test openRecentProject correctly calls openProject with the path. Test error in refreshRecentProjects is caught and logged but doesn't throw. Verify useCallback dependencies are correctly specified.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T07:41:56.040Z"
          },
          {
            "id": 5,
            "title": "Implement Error Handling with Toast Notification Support",
            "description": "Add comprehensive error handling to the useProject hook with user-friendly error messages and integrate with a toast notification system for surfacing errors to the UI.",
            "dependencies": [
              3
            ],
            "details": "Enhance src/hooks/useProject.ts with: 1) Create an ErrorHandler type or interface: { message: string, code?: string, recoverable?: boolean }. 2) Create a helper function formatError(error: unknown): string that handles Error objects, string errors, and Tauri command errors (which may have specific structure). Extract meaningful message from Tauri errors which come as strings from Rust. 3) Add optional onError callback parameter to useProject or use a simple toast notification pattern: create useToast hook stub in src/hooks/useToast.ts that exports showError(message: string), showSuccess(message: string) functions (implementations can be placeholder console.logs until a toast library is added in Task 8). 4) Wrap all try/catch blocks in the hook to: a) Call setError with formatted error message, b) Call showError with user-friendly message, c) Set loading to false. 5) Add specific error messages for common cases: 'Failed to create project', 'Failed to open project - file may be corrupted', 'Failed to save project', 'No project is currently open'. 6) Consider adding a retry mechanism for transient errors in saveProject. 7) Export clearError action from the hook for components to dismiss errors.",
            "status": "done",
            "testStrategy": "Test formatError handles different error types correctly. Test each operation surfaces errors through both setError and toast (when implemented). Test specific error messages appear for known error conditions. Test clearError resets error state. Test loading state is always set to false after error. Mock console.error to verify errors are logged for debugging.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T07:41:56.046Z"
          }
        ],
        "updatedAt": "2026-01-27T07:41:56.046Z"
      },
      {
        "id": "8",
        "title": "Build Project UI Components",
        "description": "Create React components for project creation dialog, open dialog, recent projects list, and unsaved changes warning.",
        "details": "1. Create src/components/NewProjectDialog.tsx:\n   ```typescript\n   interface NewProjectDialogProps {\n     isOpen: boolean;\n     onClose: () => void;\n     onCreated: (info: ProjectInfo) => void;\n   }\n   // Form fields: project name, save path (with folder picker), PLC manufacturer dropdown, PLC model input\n   // Use @tauri-apps/plugin-dialog for native folder picker\n   ```\n2. Create src/components/OpenProjectDialog.tsx:\n   - Use native file picker filtered to .mop files\n3. Create src/components/RecentProjectsList.tsx:\n   ```typescript\n   // Display recent projects with name, path, last opened date\n   // Click to open, right-click context menu for remove from list\n   ```\n4. Create src/components/UnsavedChangesDialog.tsx:\n   - Modal warning when closing with unsaved changes\n   - Options: Save, Don't Save, Cancel\n5. Create src/components/ProjectHeader.tsx:\n   - Display current project name\n   - Asterisk (*) indicator when modified\n6. Style all components with Tailwind CSS\n7. Add keyboard shortcuts (Ctrl+N, Ctrl+O, Ctrl+S)",
        "testStrategy": "1. Unit test each component renders correctly\n2. Test form validation in NewProjectDialog\n3. Test dialog open/close state management\n4. Test keyboard shortcuts trigger correct actions\n5. E2E test complete new project flow\n6. E2E test open from recent projects",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create NewProjectDialog Component with Form and Native Folder Picker",
            "description": "Build the NewProjectDialog React component with a modal form for creating new projects, including project name input, folder path selection with native picker, PLC manufacturer dropdown, and PLC model input field.",
            "dependencies": [],
            "details": "Create src/components/NewProjectDialog.tsx with the following implementation: 1) Define interface NewProjectDialogProps with isOpen, onClose, onCreated callbacks. 2) Import open from '@tauri-apps/plugin-dialog' for native folder picker. 3) Build form state using useState for: projectName (string), savePath (string), plcManufacturer (PlcManufacturer type: 'LS' | 'Mitsubishi' | 'Siemens'), plcModel (string). 4) Create selectFolder async handler that calls open({ directory: true, title: 'Select Project Folder' }) and updates savePath state. 5) Add form validation: projectName required and non-empty, savePath required, plcManufacturer required. 6) Create handleSubmit that calls useProject().createProject with form values, then calls onCreated callback with the result. 7) Style with Tailwind CSS: modal overlay with backdrop blur, centered dialog box with rounded corners, form layout with labels above inputs, primary/secondary button styling. 8) Include Cancel and Create buttons with proper disabled states during submission. 9) Add loading state with spinner during project creation.",
            "status": "done",
            "testStrategy": "Unit test component renders with isOpen=true. Test form validation prevents submission with empty fields. Test selectFolder updates savePath state. Mock @tauri-apps/plugin-dialog and verify open is called with correct options. Test onCreated callback receives project info after successful creation. Test onClose is called when Cancel is clicked.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T08:48:25.843Z"
          },
          {
            "id": 2,
            "title": "Create OpenProjectDialog and UnsavedChangesDialog Components",
            "description": "Build the OpenProjectDialog component using native file picker filtered to .mop files, and the UnsavedChangesDialog modal component that warns users when closing with unsaved changes offering Save, Don't Save, and Cancel options.",
            "dependencies": [
              1
            ],
            "details": "Create two components: 1) src/components/OpenProjectDialog.tsx: Simple wrapper that calls the native file picker immediately when triggered. Import open from '@tauri-apps/plugin-dialog'. Create async openProjectPicker function that calls open({ filters: [{ name: 'ModOne Project', extensions: ['mop'] }], multiple: false, title: 'Open Project' }). If user selects a file, call useProject().openProject(selectedPath). This component may not need visible UI - it can be a hook or trigger function. Consider creating useOpenProjectDialog hook that returns { openPicker: () => Promise<void> }. 2) src/components/UnsavedChangesDialog.tsx: Interface with isOpen, onSave, onDontSave, onCancel props. Modal with warning icon (exclamation triangle), message 'You have unsaved changes. Do you want to save before closing?', and three buttons: 'Save' (primary), 'Don't Save' (secondary/danger), 'Cancel' (tertiary). Style with Tailwind: warning/destructive color scheme, clear button hierarchy. Add isLoading state for Save button during save operation.",
            "status": "done",
            "testStrategy": "Test OpenProjectDialog triggers native picker with correct .mop filter. Mock dialog plugin and verify file selection calls openProject. Test UnsavedChangesDialog renders all three buttons. Test each button calls its respective callback. Test isOpen false hides the dialog. Test Save button shows loading state during save.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T08:48:25.851Z"
          },
          {
            "id": 3,
            "title": "Create RecentProjectsList Component with Context Menu",
            "description": "Build the RecentProjectsList component that displays recent projects with name, path, and last opened date, featuring click-to-open functionality and a right-click context menu for removing items from the list.",
            "dependencies": [],
            "details": "Create src/components/RecentProjectsList.tsx: 1) Define interface RecentProjectsListProps with optional onProjectOpen callback. 2) Use useProject() hook to get recentProjects array and openProject function. 3) Create list rendering with each item showing: project name (bold), truncated file path with ellipsis, relative time since last opened (e.g., '2 hours ago', 'Yesterday'). Consider using date-fns formatDistanceToNow or similar. 4) Add onClick handler for each item that calls openProject(project.path). 5) Implement right-click context menu using custom state management: onContextMenu handler sets contextMenuPosition {x, y} and selectedProject, render absolutely positioned menu with 'Open' and 'Remove from list' options. 6) Add click-outside handler to close context menu. 7) Style with Tailwind: list items with hover state (bg-gray-100), selected state for context menu target, context menu with shadow and rounded corners, proper spacing and typography. 8) Show empty state message 'No recent projects' when list is empty. 9) Add subtle animations for list item hover and context menu appearance.",
            "status": "done",
            "testStrategy": "Test component renders empty state when no recent projects. Test component renders project items with correct information. Test click on item calls openProject with correct path. Test right-click opens context menu at mouse position. Test clicking outside closes context menu. Test Remove from list option triggers removal (or placeholder action). Test relative time display is correct.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T08:48:25.857Z"
          },
          {
            "id": 4,
            "title": "Create ProjectHeader Component with Modified Indicator",
            "description": "Build the ProjectHeader component that displays the current project name with an asterisk indicator when there are unsaved modifications, styled to fit in the application header area.",
            "dependencies": [],
            "details": "Create src/components/ProjectHeader.tsx: 1) Use useProject() hook or useProjectStore() directly to access currentProject and isModified state. 2) Render project name from currentProject?.config?.project?.name or show 'No Project Open' when null. 3) Conditionally append asterisk (*) after project name when isModified is true: '{projectName}*'. 4) Style with Tailwind: appropriate font size for header (text-lg or text-xl), font weight (font-medium), proper text color contrasting with header background. 5) Consider adding subtle transition/animation when modified state changes. 6) Add optional onClick prop for potential 'project info' action. 7) Add tooltip on hover showing full project path if a project is open. 8) Consider responsive behavior - truncate long project names with ellipsis. 9) Export component with proper TypeScript typing. This component should be simple and focused - it's a display component with minimal logic.",
            "status": "done",
            "testStrategy": "Test component shows 'No Project Open' when currentProject is null. Test component displays project name when project is open. Test asterisk appears when isModified is true. Test asterisk disappears when isModified is false. Test tooltip shows project path on hover. Test truncation works for long project names.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T08:48:25.863Z"
          },
          {
            "id": 5,
            "title": "Implement Global Keyboard Shortcuts for Project Operations",
            "description": "Add global keyboard shortcuts (Ctrl+N for new project, Ctrl+O for open project, Ctrl+S for save project) using React event listeners that trigger the corresponding project operations and dialog openings.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create src/hooks/useKeyboardShortcuts.ts: 1) Import necessary hooks and the useProject hook. 2) Accept configuration object with callbacks: onNewProject, onOpenProject, onSaveProject. 3) Use useEffect to add 'keydown' event listener to document. 4) In handler, check for key combinations: (e.ctrlKey || e.metaKey) && e.key === 'n' for Ctrl+N/Cmd+N, similarly for 'o' and 's'. 5) Call e.preventDefault() to prevent browser default behavior (e.g., Ctrl+S saving page). 6) Call the appropriate callback based on detected shortcut. 7) Return cleanup function that removes event listener. 8) Create src/hooks/useProjectShortcuts.ts that uses useKeyboardShortcuts with project-specific implementations: Ctrl+N opens NewProjectDialog (requires managing dialog state), Ctrl+O triggers openPicker, Ctrl+S calls saveProject if project is open. 9) Alternative: Create a ProjectShortcutsProvider component that wraps the app and provides this functionality via context. 10) Consider adding Ctrl+Shift+S for 'Save As' functionality. 11) Add visual indicator in menus/buttons showing keyboard shortcuts (e.g., 'New Project (Ctrl+N)').",
            "status": "done",
            "testStrategy": "Test useKeyboardShortcuts hook adds event listener on mount and removes on unmount. Test Ctrl+N fires onNewProject callback. Test Ctrl+O fires onOpenProject callback. Test Ctrl+S fires onSaveProject callback. Test Cmd key works on Mac (metaKey). Test preventDefault is called to stop browser default. Test shortcuts don't fire when input fields are focused (optional - may need refinement). Integration test shortcuts work in the actual app context.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T08:48:25.868Z"
          }
        ],
        "updatedAt": "2026-01-27T08:48:25.868Z"
      },
      {
        "id": "9",
        "title": "Implement Auto-Save Functionality",
        "description": "Add automatic project saving with configurable interval, backup file creation, and recovery from interrupted saves.",
        "details": "1. Add auto-save configuration to ProjectConfig:\n   ```rust\n   pub struct AutoSaveSettings {\n       pub enabled: bool,\n       pub interval_secs: u64,  // default: 300 (5 minutes)\n       pub backup_count: u32,   // default: 3\n   }\n   ```\n2. Create src-tauri/src/project/auto_save.rs:\n   ```rust\n   use tokio::time::{interval, Duration};\n   use tokio::sync::mpsc;\n\n   pub struct AutoSaveManager {\n       interval: Duration,\n       enabled: bool,\n       cancel_tx: Option<mpsc::Sender<()>>,\n   }\n\n   impl AutoSaveManager {\n       pub fn start(&mut self, project_manager: Arc<Mutex<ProjectManager>>);\n       pub fn stop(&mut self);\n       pub fn update_interval(&mut self, secs: u64);\n       \n       async fn auto_save_loop(\n           manager: Arc<Mutex<ProjectManager>>,\n           interval: Duration,\n           mut cancel_rx: mpsc::Receiver<()>\n       );\n       \n       fn create_backup(path: &Path) -> Result<(), MopFileError>;\n   }\n   ```\n3. Create backup files with naming scheme: `project.mop.bak`, `project.mop.bak.1`, `project.mop.bak.2`\n4. Rotate backup files keeping only configured count\n5. Add Tauri commands for auto-save configuration:\n   ```rust\n   #[tauri::command]\n   async fn set_auto_save_enabled(enabled: bool) -> Result<(), String>;\n   \n   #[tauri::command]\n   async fn set_auto_save_interval(secs: u64) -> Result<(), String>;\n   ```\n6. Integrate with frontend settings UI\n7. Show subtle notification when auto-save occurs",
        "testStrategy": "1. Unit test backup file rotation logic\n2. Test auto-save triggers after configured interval\n3. Test auto-save disabled when no project open\n4. Test backup file recovery scenario\n5. Test stop/start when interval changes\n6. Integration test auto-save creates valid .mop file",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define AutoSaveSettings Struct and Integrate into ProjectConfig",
            "description": "Create the AutoSaveSettings struct in config.rs with enabled, interval_secs, and backup_count fields, and add it to the existing ProjectConfig structure.",
            "dependencies": [],
            "details": "In src-tauri/src/project/config.rs, add the AutoSaveSettings struct: `pub struct AutoSaveSettings { pub enabled: bool, pub interval_secs: u64, pub backup_count: u32 }`. Derive Serialize, Deserialize, Clone, Debug. Implement Default trait with enabled=true, interval_secs=300 (5 minutes), backup_count=3. Add `pub auto_save: AutoSaveSettings` field to ProjectConfig struct. Update ProjectConfig's Default implementation to include AutoSaveSettings::default(). Use #[serde(rename_all = \"snake_case\")] for YAML field naming consistency. Add corresponding TypeScript interface to src/types/project.ts: `interface AutoSaveSettings { enabled: boolean; interval_secs: number; backup_count: number; }`.",
            "status": "done",
            "testStrategy": "Unit test AutoSaveSettings::default() returns correct values (enabled=true, interval_secs=300, backup_count=3). Test YAML serialization/deserialization roundtrip preserves all values. Verify ProjectConfig with auto_save field serializes to valid YAML matching schema. TypeScript compilation should pass without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:33:54.661Z"
          },
          {
            "id": 2,
            "title": "Create AutoSaveManager Struct with Lifecycle Control",
            "description": "Implement src-tauri/src/project/auto_save.rs with AutoSaveManager struct that controls auto-save loop lifecycle using tokio async runtime and mpsc channels for start/stop/update operations.",
            "dependencies": [
              1
            ],
            "details": "Create src-tauri/src/project/auto_save.rs with imports: tokio::time::{interval, Duration}, tokio::sync::mpsc, std::sync::{Arc, Mutex}. Define AutoSaveManager struct with fields: interval (Duration), enabled (bool), cancel_tx (Option<mpsc::Sender<()>>), is_running (bool). Implement: new(settings: &AutoSaveSettings) -> Self constructor initializing from settings. start(&mut self, project_manager: Arc<Mutex<ProjectManager>>) creates mpsc::channel(1), stores sender in cancel_tx, spawns auto_save_loop as tokio::spawn task, sets is_running=true. If already running, call stop() first. stop(&mut self) sends () via cancel_tx if Some, sets is_running=false, clears cancel_tx to None. update_interval(&mut self, secs: u64, manager: Arc<Mutex<ProjectManager>>) updates interval and restarts if running. update_enabled(&mut self, enabled: bool). Export from project/mod.rs with `pub mod auto_save;`.",
            "status": "done",
            "testStrategy": "Test new() creates manager with correct interval from settings. Test start() sets is_running=true and creates cancel channel. Test stop() sends cancel signal and sets is_running=false. Test calling start() when already running stops previous loop. Test update_interval restarts the loop with new duration.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:33:54.668Z"
          },
          {
            "id": 3,
            "title": "Implement Auto-Save Loop and Backup File Rotation Logic",
            "description": "Create the core async auto_save_loop function that periodically saves the project when modified, and implement backup file rotation maintaining configurable number of backup copies with .mop.bak naming scheme.",
            "dependencies": [
              2
            ],
            "details": "In auto_save.rs, implement: async fn auto_save_loop(manager: Arc<Mutex<ProjectManager>>, interval_duration: Duration, mut cancel_rx: mpsc::Receiver<()>, backup_count: u32, app_handle: tauri::AppHandle) using tokio::select! to wait for either interval.tick() or cancel_rx.recv(). On tick: acquire lock, check if project open and is_modified=true, if so get source_path, call create_backup before save, then call save_project(None), emit 'auto-save-completed' event via app_handle. fn create_backup(project_path: &Path, backup_count: u32) -> Result<(), MopFileError>: rotate backups by iterating from backup_count-1 down to 0, renaming .bak.N to .bak.(N+1), then .bak to .bak.1 if exists, finally copy current file to .bak. Delete oldest backup exceeding count using fs::remove_file. Use std::fs::copy and std::fs::rename. Handle missing files gracefully with match on fs::metadata. Log operations for debugging.",
            "status": "done",
            "testStrategy": "Unit test backup rotation: create project.mop and existing .bak files, run create_backup, verify files renamed correctly. Test backup_count=3 keeps only 3 backups. Test auto_save_loop triggers save after interval with modified project. Test loop exits on cancel signal. Test no save when is_modified=false. Test no action when no project open.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:33:54.674Z"
          },
          {
            "id": 4,
            "title": "Add Tauri Commands for Auto-Save Configuration",
            "description": "Create Tauri command handlers for getting and setting auto-save settings (enabled, interval, backup_count), register AutoSaveManager as managed state, and integrate with ProjectManager.",
            "dependencies": [
              3
            ],
            "details": "In src-tauri/src/commands/project.rs add: #[tauri::command] async fn get_auto_save_settings(state: State<'_, Mutex<ProjectManager>>) -> Result<AutoSaveSettings, String> returning current settings from open project config or defaults. #[tauri::command] async fn set_auto_save_enabled(manager_state: State<'_, Mutex<ProjectManager>>, auto_save_state: State<'_, Mutex<AutoSaveManager>>, enabled: bool) -> Result<(), String> updating config and calling update_enabled. #[tauri::command] async fn set_auto_save_interval(manager_state: State<'_, Mutex<ProjectManager>>, auto_save_state: State<'_, Mutex<AutoSaveManager>>, secs: u64) -> Result<(), String> with validation (minimum 30 seconds). #[tauri::command] async fn set_backup_count(state: State<'_, Mutex<ProjectManager>>, count: u32) -> Result<(), String> with validation (1-10 range). Update main.rs: add .manage(Mutex::new(AutoSaveManager::new(&AutoSaveSettings::default()))) and register all commands in invoke_handler. Start auto-save when project opens, stop when closes.",
            "status": "done",
            "testStrategy": "Test get_auto_save_settings returns correct configuration. Test set_auto_save_enabled updates config and manager state. Test set_auto_save_interval rejects values below 30 seconds. Test set_backup_count rejects values outside 1-10 range. Verify commands registered without compilation errors. Test auto-save starts on project open and stops on close.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:33:54.680Z"
          },
          {
            "id": 5,
            "title": "Create Frontend Auto-Save Integration and Notification UI",
            "description": "Implement frontend service methods, useAutoSave hook for settings management, and a subtle toast notification component that displays when auto-save completes successfully.",
            "dependencies": [
              4
            ],
            "details": "Add to src/services/projectService.ts: getAutoSaveSettings(), setAutoSaveEnabled(enabled: boolean), setAutoSaveInterval(secs: number), setBackupCount(count: number) calling invoke with snake_case params. Create src/hooks/useAutoSave.ts exporting useAutoSave() hook that: fetches settings on mount with useEffect, provides updateEnabled/updateInterval/updateBackupCount functions, manages local state synced with backend, subscribes to 'auto-save-completed' event using listen from @tauri-apps/api/event. Create src/components/AutoSaveNotification.tsx: subtle toast positioned bottom-right with 'Project auto-saved' message and timestamp, uses useState for visibility, useEffect with 3-second setTimeout for auto-dismiss, Tailwind styling: bg-green-50 border-green-200 text-green-800, rounded-lg shadow-lg, animate-fade-in-out. Hook triggers notification visibility when event received. Export all for use in settings UI.",
            "status": "done",
            "testStrategy": "Test service methods call correct Tauri commands with proper snake_case parameters. Test useAutoSave hook fetches settings on mount. Test hook subscribes to auto-save-completed event. Test AutoSaveNotification renders when visible=true and auto-hides after 3 seconds. Test notification shows timestamp. Integration test: enable auto-save, modify project, wait for interval, verify notification appears and backup file created.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:34:57.354Z"
          }
        ],
        "updatedAt": "2026-01-27T04:34:57.354Z"
      },
      {
        "id": "10",
        "title": "Add Error Handling and Validation",
        "description": "Implement comprehensive error handling for corrupted files, invalid configurations, and provide user-friendly error messages with recovery options.",
        "details": "1. Create src-tauri/src/error.rs with unified error types:\n   ```rust\n   use thiserror::Error;\n\n   #[derive(Error, Debug, Serialize)]\n   #[serde(tag = \"type\", content = \"message\")]\n   pub enum ModOneError {\n       #[error(\"Project not found: {0}\")]\n       ProjectNotFound(String),\n       \n       #[error(\"Invalid .mop file: {0}\")]\n       InvalidMopFile(String),\n       \n       #[error(\"Configuration error: {0}\")]\n       ConfigError(String),\n       \n       #[error(\"IO error: {0}\")]\n       IoError(String),\n       \n       #[error(\"Project already open, close first\")]\n       ProjectAlreadyOpen,\n       \n       #[error(\"No project open\")]\n       NoProjectOpen,\n   }\n   ```\n2. Add validation to config.yml loading:\n   - Validate port ranges (0-65535)\n   - Validate memory map sizes and ranges\n   - Validate PLC manufacturer/model combinations\n3. Create recovery options for corrupted files:\n   - Attempt to extract readable portions\n   - Offer to open backup file if available\n4. Create src/components/ErrorBoundary.tsx for React error handling\n5. Create src/components/ErrorDialog.tsx for displaying errors:\n   ```typescript\n   interface ErrorDialogProps {\n     error: ModOneError;\n     onRetry?: () => void;\n     onIgnore?: () => void;\n     onClose: () => void;\n   }\n   ```\n6. Add frontend error type definitions matching Rust errors\n7. Implement error logging to file for debugging",
        "testStrategy": "1. Test each error type can be serialized to frontend\n2. Test corrupted ZIP file triggers InvalidMopFile error\n3. Test missing config.yml triggers appropriate error\n4. Test invalid config values caught by validation\n5. Test error dialog displays correct message and options\n6. Test recovery from backup file works\n7. E2E test error handling user flow",
        "priority": "medium",
        "dependencies": [
          "4",
          "6",
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Unified ModOneError Type in error.rs",
            "description": "Create src-tauri/src/error.rs with a comprehensive ModOneError enum using thiserror for error derivation and serde for frontend serialization, covering all project operation failure cases.",
            "dependencies": [],
            "details": "Create the error.rs module with the following implementation:\n\n1. Define ModOneError enum with thiserror and serde derives:\n   - #[derive(Error, Debug, Serialize)] with #[serde(tag = \"type\", content = \"message\")]\n   - ProjectNotFound(String) - when project path doesn't exist\n   - InvalidMopFile(String) - for corrupted/invalid ZIP archives\n   - ConfigError(String) - for YAML parsing failures\n   - ConfigValidationError { field: String, message: String } - for validation failures\n   - IoError(String) - for filesystem operations\n   - ProjectAlreadyOpen - when trying to open without closing current\n   - NoProjectOpen - for save/close without open project\n   - BackupNotFound - when recovery attempted but no backup exists\n   - RecoveryFailed(String) - when backup recovery fails\n\n2. Implement From traits for underlying error types:\n   - impl From<std::io::Error> for ModOneError\n   - impl From<zip::result::ZipError> for ModOneError\n   - impl From<serde_yaml::Error> for ModOneError\n\n3. Create type alias: pub type ModOneResult<T> = Result<T, ModOneError>\n\n4. Export the module in src-tauri/src/lib.rs or main.rs:\n   - pub mod error;\n   - pub use error::{ModOneError, ModOneResult};",
            "status": "done",
            "testStrategy": "Write unit tests verifying each error variant serializes to correct JSON with type/message structure. Test From implementations convert underlying errors correctly. Verify error messages are user-friendly and descriptive. Test ModOneResult type alias works with all error variants.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:48:19.575Z"
          },
          {
            "id": 2,
            "title": "Implement Configuration Validation Functions",
            "description": "Add comprehensive validation functions to the config module that validate port ranges, memory map settings, PLC manufacturer/model combinations, and all numeric bounds before accepting configuration values.",
            "dependencies": [
              1
            ],
            "details": "Create validation module and functions in src-tauri/src/project/validation.rs:\n\n1. Define ValidationError type that collects multiple validation issues:\n   - pub struct ValidationResult { errors: Vec<(String, String)> } // (field, message)\n   - impl ValidationResult with is_valid(), add_error(), to_config_error() methods\n\n2. Implement individual validators:\n   - validate_port(port: u16, field: &str) -> Option<String> - ensures 0-65535 range\n   - validate_baud_rate(rate: u32) - accepts standard values: 9600, 19200, 38400, 57600, 115200\n   - validate_memory_range(start: u16, count: u16, field: &str) - checks for overflow (start + count <= 65535)\n   - validate_scan_time(ms: u32) - ensures reasonable range (10-10000ms)\n   - validate_timeout(ms: u32) - ensures reasonable range (100-60000ms)\n\n3. Create composite validator:\n   - pub fn validate_project_config(config: &ProjectConfig) -> ModOneResult<()>\n   - Validates all fields and returns ConfigValidationError with aggregated messages if invalid\n\n4. Integrate validation into config loading:\n   - Call validate_project_config() in ProjectConfig::load() before returning\n   - Return ConfigValidationError on validation failure instead of silently accepting bad values\n\n5. Add validation to MopFile::open() flow to catch invalid configs early",
            "status": "done",
            "testStrategy": "Unit test each validator with valid boundary values, invalid values, and edge cases. Test validate_port rejects 65536. Test memory_map validates start+count overflow. Test baud_rate accepts all standard values. Test validate_config aggregates errors properly. Integration test that opening project with invalid config returns ConfigValidationError.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T12:49:55.226Z"
          },
          {
            "id": 3,
            "title": "Implement Corrupted File Recovery and Backup Detection",
            "description": "Create recovery utilities that detect available backup files, attempt to extract readable portions from corrupted .mop files, and provide options to recover from the most recent valid backup.",
            "dependencies": [
              1
            ],
            "details": "Create src-tauri/src/project/recovery.rs with recovery utilities:\n\n1. Implement backup discovery:\n   - pub fn find_backups(mop_path: &Path) -> Vec<BackupInfo>\n   - BackupInfo { path: PathBuf, timestamp: DateTime<Utc>, size: u64 }\n   - Search for .mop.bak, .mop.bak.1, .mop.bak.2, etc.\n   - Sort by modification time (most recent first)\n\n2. Implement .mop file integrity validation:\n   - pub fn validate_mop_integrity(path: &Path) -> MopIntegrityResult\n   - MopIntegrityResult { is_valid: bool, has_config: bool, has_modone_dir: bool, readable_files: Vec<String>, errors: Vec<String> }\n   - Check ZIP file can be opened\n   - Verify required structure (modone/ directory, config.yml)\n   - List which files are readable vs corrupted\n\n3. Implement partial recovery:\n   - pub fn attempt_partial_recovery(corrupted_path: &Path, output_dir: &Path) -> RecoveryResult\n   - Try to extract as many valid entries as possible from corrupted ZIP\n   - RecoveryResult { recovered_files: Vec<String>, failed_files: Vec<String>, created_default_config: bool }\n   - Create default config.yml if original is corrupted\n\n4. Implement backup recovery:\n   - pub fn recover_from_backup(backup_path: &Path, target_path: &Path) -> ModOneResult<()>\n   - Validate backup integrity before copying\n   - Copy backup to target location\n\n5. Add Tauri commands for recovery operations:\n   - #[tauri::command] get_available_backups(path: String)\n   - #[tauri::command] recover_project_from_backup(backup_path: String, target_path: String)",
            "status": "done",
            "testStrategy": "Create test .mop files with various corruption types: missing files, invalid ZIP header, valid ZIP but missing config.yml. Test find_backups returns correct files in order. Test partial_recovery extracts what's possible from partially corrupted ZIP. Test recover_from_backup successfully restores from valid backup. Test validate_mop_integrity catches all required structure issues.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T12:53:02.402Z"
          },
          {
            "id": 4,
            "title": "Create React Error Boundary and ErrorDialog Components",
            "description": "Implement src/components/ErrorBoundary.tsx for catching React render errors and src/components/ErrorDialog.tsx for displaying ModOne-specific errors with retry, ignore, and recovery options.",
            "dependencies": [
              1
            ],
            "details": "Create React error handling components:\n\n1. Create src/types/error.ts with frontend error types:\n   - Mirror Rust ModOneError enum as TypeScript discriminated union\n   - type ModOneError = { type: 'ProjectNotFound', message: string } | { type: 'InvalidMopFile', message: string } | ... etc.\n   - Create helper function isRecoverableError(error: ModOneError): boolean\n   - Create helper function getErrorTitle(error: ModOneError): string\n\n2. Create src/components/ErrorBoundary.tsx:\n   - Class component extending React.Component<Props, State>\n   - Implement getDerivedStateFromError and componentDidCatch\n   - Render fallback UI with error message and 'Reload Application' button\n   - Accept optional onError callback prop for logging\n   - Style with Tailwind for consistent look\n\n3. Create src/components/ErrorDialog.tsx:\n   - Props: { error: ModOneError | null, onRetry?: () => void, onIgnore?: () => void, onClose: () => void, onOpenBackup?: () => void }\n   - Modal dialog using Tailwind styling\n   - Display error type as title, message as content\n   - Show 'Retry' button if onRetry provided\n   - Show 'Ignore' button if onIgnore provided\n   - Show 'Open Backup' button for InvalidMopFile errors when onOpenBackup provided\n   - Always show 'Close' button\n\n4. Create src/hooks/useErrorHandler.ts:\n   - Custom hook managing error dialog state\n   - showError(error: ModOneError), clearError()\n   - Listen for Tauri 'modone-error' events\n   - Return { currentError, showError, clearError, ErrorDialogProps }",
            "status": "done",
            "testStrategy": "Test ErrorBoundary catches errors thrown by child components. Test fallback UI renders with error message. Test ErrorDialog renders correct buttons based on error type. Test onRetry/onIgnore/onClose callbacks fire when clicked. Test ConfigValidationError shows field name. Test InvalidMopFile error shows 'Open Backup' option.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T12:45:42.634Z"
          },
          {
            "id": 5,
            "title": "Implement Error Logging Service and Tauri Event Integration",
            "description": "Create file-based error logging in the Rust backend and integrate error propagation to frontend using Tauri events, enabling persistent debugging logs and real-time error notifications.",
            "dependencies": [
              1,
              4
            ],
            "details": "Create error logging and event system:\n\n1. Create src-tauri/src/logging.rs:\n   - pub fn initialize_logging(app_handle: &AppHandle) -> ModOneResult<()>\n   - Create logs directory in app data path\n   - Configure file-based logging with rotation (keep last 5 log files, max 10MB each)\n   - Use tracing or log crate for structured logging\n\n2. Implement error logging functions:\n   - pub fn log_error(error: &ModOneError, context: &str)\n   - Write JSON-formatted log entries: { timestamp, level, error_type, message, context }\n   - Include stack trace when available\n\n3. Create Tauri error event emission:\n   - Modify Tauri commands to emit 'modone-error' event on failures\n   - Event payload: { error: ModOneError, command: String, timestamp: String }\n   - Use app_handle.emit(\"modone-error\", payload)\n\n4. Add logging commands:\n   - #[tauri::command] get_log_path() -> String\n   - #[tauri::command] get_recent_errors() -> Vec<LogEntry>\n   - #[tauri::command] clear_logs()\n\n5. Update existing Tauri commands to use new error handling:\n   - Wrap all command results with error logging\n   - Emit error events before returning Err\n   - Use context strings to identify which operation failed\n\n6. Frontend integration:\n   - Update useErrorHandler to listen for 'modone-error' events\n   - Automatically display ErrorDialog when error event received\n   - Add 'View Logs' button in ErrorDialog that calls get_log_path and opens in file explorer",
            "status": "done",
            "testStrategy": "Test initialize_logging creates log directory and file. Test log_error writes properly formatted JSON entries. Test Tauri commands emit error events on failure. Test useErrorHandler receives events and updates state. Test openLogs command returns correct path. Integration test: trigger error, verify logged to file and displayed in UI.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T12:57:02.422Z"
          }
        ],
        "updatedAt": "2026-01-27T12:57:02.422Z"
      },
      {
        "id": "11",
        "title": "Create Main Application Shell with Menu Bar and Toolbar",
        "description": "Implement VSCode-style main application shell with MenuBar, Toolbar, and StatusBar components providing complete application chrome.",
        "details": "1. Create `src/components/layout/MainLayout.tsx` as the root layout component with CSS Grid structure:\n   ```typescript\n   // Grid layout: activity-bar | sidebar | main-content\n   // With header row for menu/toolbar and footer for status bar\n   ```\n\n2. Implement `src/components/layout/MenuBar.tsx`:\n   - File menu: New Project (Ctrl+N), Open Project (Ctrl+O), Save (Ctrl+S), Save As (Ctrl+Shift+S), Recent Projects submenu, Exit\n   - Edit menu: Undo (Ctrl+Z), Redo (Ctrl+Y), Cut/Copy/Paste, Preferences\n   - View menu: Toggle Sidebar (Ctrl+B), Toggle Panel submenu, Reset Layout, Zoom In/Out\n   - Simulation menu: Start (F5), Stop (Shift+F5), Pause (F6), Step (F10), Reset\n   - Modbus menu: Server Settings, Start Server, Stop Server, Connection Status\n   - Help menu: Documentation, About\n   - Use React state for menu open/close state\n   - Keyboard shortcut handling integration with useKeyboardShortcuts from Task 8\n\n3. Implement `src/components/layout/Toolbar.tsx`:\n   - Project group: New, Open, Save icons with tooltips\n   - Simulation group: Play, Pause, Stop, Step icons with disabled states\n   - View group: Panel toggle buttons for each panel type\n   - Use icon library (lucide-react or similar)\n   - Tailwind styling with hover/active states\n\n4. Implement `src/components/layout/StatusBar.tsx`:\n   - Left section: Simulation status indicator (Running/Stopped/Paused) with colored dot\n   - Center section: Scan time display (e.g., '10ms')\n   - Right section: Modbus connection status (TCP:502 Connected/Disconnected)\n   - Right section: Memory usage indicator (percentage or MB)\n   - Fixed height (24px), border-top separator\n\n5. Create `src/stores/layoutStore.ts` with Zustand:\n   ```typescript\n   interface LayoutStore {\n     menuOpen: string | null; // Currently open menu\n     simulationStatus: 'running' | 'stopped' | 'paused';\n     scanTime: number;\n     modbusConnected: boolean;\n     setMenuOpen: (menu: string | null) => void;\n     // ... other actions\n   }\n   ```",
        "testStrategy": "1. Unit test MenuBar renders all menu items with correct labels\n2. Test keyboard shortcuts trigger correct menu actions (mock handlers)\n3. Test StatusBar updates simulation status indicator color based on state\n4. Test Toolbar buttons have correct disabled states based on project/simulation state\n5. E2E test menu navigation: click File > New Project opens dialog\n6. Test menu closes when clicking outside",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create MainLayout Component with CSS Grid Structure",
            "description": "Implement the root layout component src/components/layout/MainLayout.tsx using CSS Grid to define the application shell structure with header, activity-bar, sidebar, main-content, and footer areas.",
            "dependencies": [],
            "details": "Create src/components/layout/MainLayout.tsx with a CSS Grid layout that defines the full application structure. The grid should have: 1) Grid template rows: auto (menu/toolbar header), 1fr (main content area), auto (status bar footer). 2) Grid template columns: auto (activity bar ~48px), auto (sidebar ~250px resizable), 1fr (main content). 3) Use Tailwind CSS classes for styling: h-screen, w-screen, overflow-hidden for the root container. 4) Define grid-template-areas for named regions: 'header header header' / 'activity sidebar main' / 'footer footer footer'. 5) Create placeholder div elements for each grid area with appropriate grid-area assignments. 6) Accept children prop for main content area. 7) Import and render MenuBar in header row, StatusBar in footer row. 8) Export MainLayout as the primary layout wrapper for the application. 9) Add dark mode support with bg-gray-900 for dark and bg-white for light themes. 10) Ensure the layout fills the viewport completely without scrolling on the main container.",
            "status": "done",
            "testStrategy": "Verify MainLayout renders without errors. Test that CSS Grid creates the expected structure by checking computed styles. Test that children are rendered in the main content area. Verify the layout fills the viewport (h-screen, w-screen). Test with React Testing Library that all grid areas are present and accessible.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:27:22.666Z"
          },
          {
            "id": 2,
            "title": "Implement MenuBar Component with Dropdown Menus and Keyboard Shortcuts",
            "description": "Create src/components/layout/MenuBar.tsx implementing a VSCode-style menu bar with File, Edit, View, Simulation, Modbus, and Help menus, including dropdown functionality and keyboard shortcut display.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/layout/MenuBar.tsx with: 1) Define menu structure as data: menus array with label, items (each item has label, shortcut?, action?, submenu?, separator?, disabled?). 2) File menu items: New Project (Ctrl+N), Open Project (Ctrl+O), separator, Save (Ctrl+S), Save As (Ctrl+Shift+S), separator, Recent Projects (submenu), separator, Exit. 3) Edit menu: Undo (Ctrl+Z), Redo (Ctrl+Y), separator, Cut (Ctrl+X), Copy (Ctrl+C), Paste (Ctrl+V), separator, Preferences. 4) View menu: Toggle Sidebar (Ctrl+B), Toggle Panel (submenu with Output, Problems, Terminal), separator, Reset Layout, separator, Zoom In (Ctrl++), Zoom Out (Ctrl+-). 5) Simulation menu: Start (F5), Stop (Shift+F5), Pause (F6), Step (F10), separator, Reset. 6) Modbus menu: Server Settings, separator, Start Server, Stop Server, separator, Connection Status. 7) Help menu: Documentation, separator, About. 8) Use useState for openMenu tracking which menu is open. 9) Implement click-to-open, click-outside-to-close using useEffect with document event listener. 10) Style with Tailwind: h-8 fixed header bar, hover states on menu items, dropdown with shadow-lg and border. 11) Display keyboard shortcuts right-aligned in menu items with text-gray-500. 12) Use layoutStore.setMenuOpen for state management integration.",
            "status": "done",
            "testStrategy": "Test that MenuBar renders all top-level menu labels (File, Edit, View, etc.). Test clicking a menu item opens the dropdown. Test clicking outside closes the dropdown. Test that keyboard shortcuts are displayed correctly. Test that menu items have correct disabled states based on project state. Test submenu rendering for Recent Projects and Toggle Panel.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:27:22.675Z"
          },
          {
            "id": 3,
            "title": "Implement Toolbar Component with Icon Button Groups",
            "description": "Create src/components/layout/Toolbar.tsx with grouped icon buttons for project operations, simulation controls, and view toggles using lucide-react icons with tooltips and proper disabled states.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/layout/Toolbar.tsx: 1) Install lucide-react for icons: npm install lucide-react. 2) Import icons: FileIcon, FolderOpen, Save, Play, Pause, Square, StepForward, PanelLeft, PanelBottom, PanelRight from lucide-react. 3) Create ToolbarButton component: button with icon, tooltip on hover (using title attribute or custom tooltip component), disabled prop styling (opacity-50, cursor-not-allowed), hover state (bg-gray-200 dark:bg-gray-700), consistent size (w-8 h-8), flex center alignment. 4) Create ToolbarSeparator component: vertical divider (h-6 w-px bg-gray-300 mx-1). 5) Group buttons with ToolbarSeparators: Project group (New, Open, Save), Simulation group (Play, Pause, Stop, Step), View group (toggle panels). 6) Project buttons disabled when appropriate (Save disabled if !isModified). 7) Simulation buttons disabled based on simulationStatus from layoutStore (Play disabled when running, Stop disabled when stopped, etc.). 8) Use Zustand store to read simulation status and toggle panel visibility. 9) Style toolbar: h-10, border-b, flex items-center, px-2, gap-1. 10) Add tooltips showing button name and keyboard shortcut.",
            "status": "done",
            "testStrategy": "Test Toolbar renders all button groups. Test ToolbarButton hover and disabled states apply correct CSS classes. Test clicking enabled buttons triggers onClick handlers. Test disabled buttons do not trigger onClick. Test tooltips appear on hover (if custom tooltip). Test icon rendering from lucide-react. Test simulation button disabled states match simulationStatus store value.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:27:22.681Z"
          },
          {
            "id": 4,
            "title": "Implement StatusBar Component with Real-Time Status Indicators",
            "description": "Create src/components/layout/StatusBar.tsx displaying simulation status with colored indicator, scan time, Modbus connection status, and memory usage in a fixed-height footer bar.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/layout/StatusBar.tsx: 1) Create StatusIndicator sub-component that shows a colored dot (w-2 h-2 rounded-full) with label - green for running, yellow for paused, red/gray for stopped. 2) Left section: Simulation status indicator using StatusIndicator with text label ('Running', 'Paused', 'Stopped'). 3) Center section: Scan time display showing current scan cycle time (e.g., '10ms'). Use flex-1 with text-center for centering. 4) Right section (flex with gap-4): a) Modbus TCP status showing 'TCP:502' with Connected/Disconnected indicator, b) Memory usage showing percentage or MB value (placeholder until real implementation). 5) Read all values from layoutStore: simulationStatus, scanTime, modbusConnected, memoryUsage. 6) Style: fixed height h-6 (24px), border-t separator, bg-gray-100 dark:bg-gray-800, text-xs font-mono, flex items-center justify-between, px-4. 7) Use appropriate icons from lucide-react: Wifi/WifiOff for connection, Activity for simulation, Cpu for memory. 8) Ensure status updates reactively when store changes. 9) Add hover tooltips for detailed status information.",
            "status": "done",
            "testStrategy": "Test StatusBar renders with default values. Test simulation status indicator shows correct color for each status (running=green, paused=yellow, stopped=gray). Test scan time displays formatted value with 'ms' suffix. Test Modbus connection shows correct Connected/Disconnected state. Test memory usage displays placeholder value. Test store changes cause re-render with updated values. Test accessibility with proper ARIA labels for status indicators.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:27:22.687Z"
          },
          {
            "id": 5,
            "title": "Create layoutStore with Zustand for Application Chrome State",
            "description": "Implement src/stores/layoutStore.ts using Zustand to manage menu state, simulation status, scan time, Modbus connection status, memory usage, and panel visibility for the application shell.",
            "dependencies": [],
            "details": "Create src/stores/layoutStore.ts with Zustand: 1) Import create from 'zustand'. 2) Define SimulationStatus type: 'running' | 'stopped' | 'paused'. 3) Define LayoutStore interface with state: menuOpen (string | null for currently open menu name), simulationStatus (SimulationStatus), scanTime (number in ms), modbusConnected (boolean), modbusPort (number, default 502), memoryUsageMb (number), sidebarVisible (boolean), panelVisible (boolean), panelType ('output' | 'problems' | 'terminal'). 4) Define actions: setMenuOpen(menu: string | null), setSimulationStatus(status: SimulationStatus), setScanTime(time: number), setModbusConnected(connected: boolean), setModbusPort(port: number), setMemoryUsage(mb: number), toggleSidebar(), togglePanel(), setPanelType(type: string), resetLayout(). 5) Create store with create<LayoutStore>((set) => ({...})). 6) Set sensible defaults: menuOpen=null, simulationStatus='stopped', scanTime=10, modbusConnected=false, modbusPort=502, memoryUsageMb=0, sidebarVisible=true, panelVisible=false, panelType='output'. 7) resetLayout action should restore all layout state to defaults. 8) Export useLayoutStore hook for component usage. 9) Add devtools middleware for debugging in development.",
            "status": "done",
            "testStrategy": "Test initial state values match expected defaults. Test each action updates the correct state field. Test setMenuOpen with string sets menuOpen, with null clears it. Test setSimulationStatus only accepts valid SimulationStatus values. Test toggleSidebar flips sidebarVisible boolean. Test resetLayout restores all values to initial state. Test store can be used in multiple components and updates propagate correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-26T23:32:06.212Z"
          }
        ],
        "updatedAt": "2026-01-27T00:27:22.687Z"
      },
      {
        "id": "12",
        "title": "Implement Sidebar with Activity Bar Navigation",
        "description": "Build VSCode Activity Bar-style sidebar with collapsible navigation, Explorer/Search/Modbus/Settings panels, and resizable width.",
        "details": "1. Create `src/components/layout/Sidebar.tsx`:\n   - Collapsible sidebar with configurable width (default: 250px, min: 150px, max: 400px)\n   - CSS transition for smooth show/hide animation (transform or width)\n   - Horizontal resize handle on right edge\n   - Flex layout: ActivityBar (fixed 48px) | Panel content (flexible)\n\n2. Create `src/components/layout/ActivityBar.tsx`:\n   - Vertical icon bar (48px width) positioned on left edge\n   - Icons using lucide-react: FolderTree (Explorer), Search, Server (Modbus), Settings\n   - Active tab indicator: left border highlight or background color change\n   - Tooltip on hover showing tab name using title attribute or custom tooltip\n   - Click handler switches active panel\n\n3. Create sidebar panel components in `src/components/sidebar/`:\n   - `ExplorerPanel.tsx`: Project file tree view with expandable folders\n     - Display .mop file contents structure (config.yml, plc_csv/, one_canvas/)\n     - Use recursive Tree component with expand/collapse icons\n     - Click on files to open/edit in panels\n   - `SearchPanel.tsx`: Global search input with results list\n     - Search input with debounced onChange\n     - Results grouped by file with line preview\n   - `ModbusPanel.tsx`: Server status display, memory overview\n     - Connection status indicator\n     - Quick start/stop server buttons\n     - Memory usage summary (coils, registers count)\n   - `SettingsPanel.tsx`: Quick settings shortcuts\n     - Links to open full settings dialog\n     - Quick toggles for common settings\n\n4. Create `src/stores/sidebarStore.ts` with Zustand:\n   ```typescript\n   interface SidebarStore {\n     activePanel: 'explorer' | 'search' | 'modbus' | 'settings';\n     isVisible: boolean;\n     width: number;\n     setActivePanel: (panel: string) => void;\n     toggleVisibility: () => void;\n     setWidth: (width: number) => void;\n   }\n   ```\n\n5. Implement resize handle with mouse drag:\n   - onMouseDown starts resize mode\n   - onMouseMove updates width (clamped to min/max)\n   - onMouseUp ends resize mode\n   - Cursor change to col-resize during drag",
        "testStrategy": "1. Test sidebar visibility toggle with Ctrl+B shortcut\n2. Test clicking ActivityBar icons switches panel content\n3. Test resize handle adjusts width within min/max bounds\n4. Test file tree in ExplorerPanel displays correct project structure\n5. Test active tab indicator highlights correct icon\n6. Test sidebar remembers width after toggle hide/show",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Zustand Sidebar Store for State Management",
            "description": "Implement the sidebarStore using Zustand to manage sidebar visibility, active panel selection, and width state with persistence support.",
            "dependencies": [],
            "details": "Create `src/stores/sidebarStore.ts` with Zustand store implementing: activePanel state with union type 'explorer' | 'search' | 'modbus' | 'settings', isVisible boolean defaulting to true, width number defaulting to 250px. Include actions: setActivePanel(panel) to switch panels, toggleVisibility() to show/hide sidebar, setWidth(width) with clamping between MIN_WIDTH=150 and MAX_WIDTH=400. Add persist middleware to save state to localStorage. Export typed hooks (useSidebarStore, useSidebarActions) for component consumption. This store must be created first as Sidebar and ActivityBar components depend on it.",
            "status": "done",
            "testStrategy": "Unit test store initialization with correct default values. Test setActivePanel updates activePanel correctly. Test toggleVisibility flips isVisible. Test setWidth clamps values within 150-400px range. Test persistence by verifying localStorage is updated on state changes.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:32:04.670Z"
          },
          {
            "id": 2,
            "title": "Implement ActivityBar Component with Panel Icons",
            "description": "Build the vertical ActivityBar component (48px width) with lucide-react icons for Explorer, Search, Modbus, and Settings panels with active state indication.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/layout/ActivityBar.tsx` as a vertical flex container with fixed 48px width and full height. Import lucide-react icons: FolderTree (Explorer), Search, Server (Modbus), Settings. Each icon button should: call sidebarStore.setActivePanel on click, show active indicator via left border (3px solid accent color) or background highlight when matching activePanel state, display tooltip on hover using title attribute showing panel name. Style with dark background (#252526 for dark theme), icon size 24px, vertical spacing 8px between icons. Include keyboard support for icon focus and activation.",
            "status": "done",
            "testStrategy": "Test clicking each icon calls setActivePanel with correct panel type. Verify active indicator appears only on the active panel icon. Test tooltip appears on hover with correct panel name. Test keyboard navigation (Tab to focus, Enter to activate).",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:32:04.677Z"
          },
          {
            "id": 3,
            "title": "Build Sidebar Container with Resize Handle",
            "description": "Create the main Sidebar component with collapsible functionality, resize handle for width adjustment, and CSS transitions for smooth animations.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/components/layout/Sidebar.tsx` with flex layout containing ActivityBar (fixed 48px) and panel content area (flexible). Implement resize handle on right edge: onMouseDown captures initial width and position, document mousemove calculates delta and calls setWidth with clamped value, mouseup removes listeners. Add CSS transition on width property for smooth collapse animation. When isVisible is false, use transform: translateX(-100%) or width: 48px (ActivityBar only) with transition. Include useEffect to add/remove global mousemove/mouseup listeners during resize. Set cursor to col-resize during active drag using body style manipulation.",
            "status": "done",
            "testStrategy": "Test sidebar renders with default 250px width. Test resize handle drag updates width within bounds. Test collapse animation triggers when isVisible toggles. Test cursor changes to col-resize during drag. Test keyboard shortcut Ctrl+B triggers toggleVisibility.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:32:04.683Z"
          },
          {
            "id": 4,
            "title": "Create Explorer and Search Sidebar Panels",
            "description": "Implement ExplorerPanel with recursive file tree component and SearchPanel with debounced search input and results display.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/sidebar/ExplorerPanel.tsx`: Build recursive Tree component displaying .mop project structure (config.yml, plc_csv/, one_canvas/). Each TreeNode has expand/collapse icon (ChevronRight/ChevronDown), file/folder icon, and label. Store expanded state locally or in store. Handle click on files to trigger file open action. Create `src/components/sidebar/SearchPanel.tsx`: Search input at top with magnifying glass icon, debounced onChange (300ms delay using useCallback + setTimeout). Display results grouped by filename with matching line preview and line number. Highlight search term in results. Empty state when no results or no search query.",
            "status": "done",
            "testStrategy": "ExplorerPanel: Test tree renders correct hierarchy. Test expand/collapse toggles visibility of children. Test file click emits open event. SearchPanel: Test debounce delays search execution. Test results display matches grouped by file. Test empty state shows appropriate message.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:32:04.688Z"
          },
          {
            "id": 5,
            "title": "Create Modbus and Settings Sidebar Panels",
            "description": "Implement ModbusPanel showing server status with quick controls and SettingsPanel with quick setting shortcuts and toggle controls.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/sidebar/ModbusPanel.tsx`: Display connection status indicator (colored dot: green=connected, gray=disconnected, yellow=connecting). Show quick Start/Stop server buttons using Play/Square icons. Display memory overview section with counts for coils, discrete inputs, holding registers, input registers. Use placeholder data initially, will connect to Modbus store later (Task 21-24 dependency). Create `src/components/sidebar/SettingsPanel.tsx`: Quick access links to open full settings dialog sections (General, Simulation, Modbus, Appearance). Include common toggle switches for dark mode, auto-save, show tooltips. Style as card-like sections with section headers.",
            "status": "done",
            "testStrategy": "ModbusPanel: Test status indicator shows correct color based on state. Test Start/Stop buttons trigger appropriate actions. Test memory counts display correctly. SettingsPanel: Test clicking links opens settings dialog at correct section. Test toggle switches update corresponding settings.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:32:04.751Z"
          }
        ],
        "updatedAt": "2026-01-27T00:32:04.751Z"
      },
      {
        "id": "13",
        "title": "Build Panel System with CSS Grid Layout",
        "description": "Implement CSS Grid-based flexible panel system supporting multiple panels with resize handles, minimize/maximize controls, and dynamic grid configuration.",
        "details": "1. Create `src/components/panels/PanelContainer.tsx`:\n   - CSS Grid layout with dynamic grid-template-columns and grid-template-rows\n   - Grid configuration from panelStore: { columns: ['1fr', '1fr'], rows: ['1fr', '1fr'] }\n   - Gap between panels (4px) for resize handles\n   - Full height/width within available space\n\n2. Create `src/components/panels/Panel.tsx`:\n   ```typescript\n   interface PanelProps {\n     id: string;\n     type: PanelType;\n     title: string;\n     isActive: boolean;\n     gridArea?: string; // e.g., '1 / 1 / 2 / 2'\n     onClose: () => void;\n     onMinimize: () => void;\n     onMaximize: () => void;\n     onActivate: () => void;\n   }\n   ```\n   - Header with title, minimize (-), maximize (□), close (×) buttons\n   - Content area rendering panel-specific component\n   - Active/inactive border styling (active: blue border)\n   - Click anywhere activates panel\n\n3. Create `src/components/panels/ResizeHandle.tsx`:\n   - Horizontal handle: between rows, full width, 4px height\n   - Vertical handle: between columns, full height, 4px width\n   - Visual feedback: cursor change, highlight on hover/drag\n   - Drag logic updates grid template values in store\n   - Minimum panel size constraint: 150px\n\n4. Define panel types in `src/types/panel.ts`:\n   ```typescript\n   type PanelType = 'ladder-editor' | 'memory-visualizer' | 'one-canvas' |\n                    'scenario-editor' | 'console' | 'properties';\n   interface PanelState {\n     id: string;\n     type: PanelType;\n     title: string;\n     gridArea: string;\n     isMinimized: boolean;\n   }\n   ```\n\n5. Create `src/stores/panelStore.ts` with Zustand:\n   ```typescript\n   interface PanelStore {\n     panels: PanelState[];\n     gridConfig: { columns: string[], rows: string[] };\n     activePanel: string | null;\n     addPanel: (type: PanelType, area: string) => void;\n     removePanel: (id: string) => void;\n     updateGridConfig: (config: GridConfig) => void;\n     setActivePanel: (id: string | null) => void;\n   }\n   ```\n\n6. Create placeholder panel content components:\n   - `LadderEditorPanel.tsx`: Placeholder 'Ladder Editor - Coming in Unit 4'\n   - `MemoryVisualizerPanel.tsx`: Placeholder, will integrate with Unit 3\n   - `OneCanvasPanel.tsx`: Placeholder 'One Canvas - Coming in Unit 5'\n   - `ScenarioEditorPanel.tsx`: Placeholder 'Scenario Editor - Coming in Unit 6'\n   - `ConsolePanel.tsx`: Simple log output display with timestamp\n   - `PropertiesPanel.tsx`: Selected element properties editor",
        "testStrategy": "1. Test grid layout renders panels in correct positions based on gridArea\n2. Test resize handle drag updates gridConfig columns/rows\n3. Test minimum size constraint prevents panels smaller than 150px\n4. Test panel close removes from grid and updates layout\n5. Test panel maximize expands to full grid area\n6. Test clicking panel sets it as active with visual indicator",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Panel Types and Interfaces in TypeScript",
            "description": "Create the foundational type definitions for the panel system including PanelType enum, PanelState interface, and GridConfig types that will be used throughout the panel system.",
            "dependencies": [],
            "details": "Create `src/types/panel.ts` with the following type definitions:\n\n1. Define `PanelType` as a union type: 'ladder-editor' | 'memory-visualizer' | 'one-canvas' | 'scenario-editor' | 'console' | 'properties'\n\n2. Define `PanelState` interface:\n   - id: string (unique identifier)\n   - type: PanelType\n   - title: string\n   - gridArea: string (CSS grid-area value, e.g., '1 / 1 / 2 / 2')\n   - isMinimized: boolean\n\n3. Define `GridConfig` interface:\n   - columns: string[] (array of grid-template-columns values, e.g., ['1fr', '1fr'])\n   - rows: string[] (array of grid-template-rows values)\n\n4. Define `PanelProps` interface for the Panel component:\n   - id: string\n   - type: PanelType\n   - title: string\n   - isActive: boolean\n   - gridArea?: string\n   - onClose: () => void\n   - onMinimize: () => void\n   - onMaximize: () => void\n   - onActivate: () => void\n\n5. Export all types for use in other modules.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation succeeds with no errors. Test that all types can be imported and used correctly in consumer files. Ensure type inference works correctly when creating PanelState objects.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:37:03.668Z"
          },
          {
            "id": 2,
            "title": "Create Zustand Panel Store for State Management",
            "description": "Implement a Zustand store to manage panel state including panel list, grid configuration, active panel tracking, and actions for adding/removing/updating panels.",
            "dependencies": [
              1
            ],
            "details": "Create `src/stores/panelStore.ts` with Zustand:\n\n1. Install zustand if not present: `npm install zustand`\n\n2. Define `PanelStore` interface:\n   - panels: PanelState[] (array of all panels)\n   - gridConfig: GridConfig (current grid layout)\n   - activePanel: string | null (ID of currently focused panel)\n\n3. Implement actions:\n   - addPanel(type: PanelType, area: string): void - creates new panel with unique ID\n   - removePanel(id: string): void - removes panel and updates layout\n   - updateGridConfig(config: GridConfig): void - updates grid template values\n   - setActivePanel(id: string | null): void - sets the active panel\n   - minimizePanel(id: string): void - toggles panel minimized state\n   - maximizePanel(id: string): void - expands panel to full grid area\n\n4. Set default state with 2x2 grid layout:\n   - gridConfig: { columns: ['1fr', '1fr'], rows: ['1fr', '1fr'] }\n   - panels: empty array initially\n   - activePanel: null\n\n5. Use immer middleware for immutable state updates if complex nested updates needed.",
            "status": "done",
            "testStrategy": "Unit test each store action: verify addPanel creates panel with correct properties, removePanel removes correct panel, updateGridConfig changes grid values, setActivePanel updates activePanel. Test that state updates trigger re-renders in subscribed components.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:37:03.676Z"
          },
          {
            "id": 3,
            "title": "Build PanelContainer Component with CSS Grid Layout",
            "description": "Create the main PanelContainer component that renders a CSS Grid-based layout, positioning child panels according to the grid configuration from the panel store.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/components/panels/PanelContainer.tsx`:\n\n1. Import hooks from panelStore to access gridConfig and panels\n\n2. Render a container div with CSS Grid:\n   - display: grid\n   - grid-template-columns: dynamic from store (e.g., '1fr 1fr')\n   - grid-template-rows: dynamic from store\n   - gap: 4px (space for resize handles)\n   - height: 100% and width: 100% to fill available space\n   - overflow: hidden\n\n3. Map over panels array and render Panel components:\n   - Pass panel props (id, type, title, gridArea)\n   - Apply style={{ gridArea: panel.gridArea }} to position each panel\n   - Handle isMinimized panels (collapse to header only or hide)\n\n4. Implement CSS styles:\n   - Create panel-container class with proper flexbox parent integration\n   - Ensure container takes full available space from parent layout\n   - Add CSS custom properties for theming (--panel-gap, --panel-border-radius)\n\n5. Add resize handle overlay areas between grid cells for future resize functionality.\n\n6. Export component as default.",
            "status": "done",
            "testStrategy": "Test grid layout renders panels in correct positions based on gridArea values. Verify gridConfig changes dynamically update the grid-template-columns and grid-template-rows. Test container fills available space correctly. Verify panels are positioned correctly with different grid configurations.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:37:03.681Z"
          },
          {
            "id": 4,
            "title": "Build Panel Component with Header and Controls",
            "description": "Create the Panel component with a header bar containing title, minimize/maximize/close buttons, content area for panel-specific components, and active/inactive visual states.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create `src/components/panels/Panel.tsx`:\n\n1. Accept PanelProps interface defined in types/panel.ts\n\n2. Structure the component:\n   - Outer container with border and rounded corners\n   - Header section (24-32px height):\n     * Title text (truncated with ellipsis if too long)\n     * Control buttons container (right-aligned):\n       - Minimize button (-) calls onMinimize\n       - Maximize button (□) calls onMaximize\n       - Close button (×) calls onClose\n   - Content area taking remaining space (overflow: auto)\n\n3. Implement visual states:\n   - Active panel: 2px blue/accent border\n   - Inactive panel: 1px gray border\n   - Header background color differentiation (active vs inactive)\n   - Button hover effects\n\n4. Handle click events:\n   - Clicking anywhere on panel calls onActivate\n   - Use event.stopPropagation on header buttons to prevent activation\n\n5. Render panel content based on type:\n   - Create switch/map to render correct panel content component\n   - Pass through any necessary props to content component\n\n6. Style with Tailwind CSS or CSS modules:\n   - flex flex-col for layout\n   - Panel header: flex justify-between items-center\n   - Control buttons: small icons with hover states",
            "status": "done",
            "testStrategy": "Test clicking panel calls onActivate callback. Test minimize/maximize/close buttons call correct callbacks. Test active panel has blue border styling. Test inactive panel has gray border. Test panel content area renders correct component based on type prop. Test header title truncates properly with ellipsis.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:37:03.687Z"
          },
          {
            "id": 5,
            "title": "Build ResizeHandle and Placeholder Panel Content Components",
            "description": "Create the ResizeHandle component for resizing panel grid areas and implement all six placeholder panel content components with basic UI indicating future functionality.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create `src/components/panels/ResizeHandle.tsx`:\n\n1. Accept props: orientation ('horizontal' | 'vertical'), index (which gap), onResize callback\n\n2. Render resize handle element:\n   - Horizontal: full width, 4px height, positioned between rows\n   - Vertical: full height, 4px width, positioned between columns\n   - cursor: col-resize (vertical) or row-resize (horizontal)\n   - background: transparent, changes to accent color on hover\n\n3. Implement drag logic:\n   - onMouseDown: start tracking, capture initial position\n   - onMouseMove (document): calculate delta, call onResize with new grid values\n   - onMouseUp: stop tracking, release event listeners\n   - Enforce minimum panel size: 150px constraint\n\n4. Update panelStore.updateGridConfig with new column/row values\n\nCreate placeholder panel content components in `src/components/panels/content/`:\n\n5. LadderEditorPanel.tsx:\n   - Display centered text: 'Ladder Editor - Coming in Unit 4'\n   - Basic placeholder styling with icon\n\n6. MemoryVisualizerPanel.tsx:\n   - Display: 'Memory Visualizer - Will integrate with Unit 3'\n   - Placeholder for memory display\n\n7. OneCanvasPanel.tsx:\n   - Display: 'One Canvas - Coming in Unit 5'\n   - Placeholder circuit canvas area\n\n8. ScenarioEditorPanel.tsx:\n   - Display: 'Scenario Editor - Coming in Unit 6'\n   - Placeholder for scenario UI\n\n9. ConsolePanel.tsx:\n   - Simple scrollable log output area with timestamps\n   - Basic log array display with useConsoleStore or local state\n\n10. PropertiesPanel.tsx:\n    - Display: 'Properties - Select an element'\n    - Placeholder for property editor form",
            "status": "done",
            "testStrategy": "Test resize handle drag updates gridConfig columns/rows in store. Test minimum size constraint prevents panels smaller than 150px. Test cursor changes to resize cursor on hover. Test all placeholder panels render their placeholder text correctly. Test ConsolePanel displays log entries with timestamps. Test resize handles appear between grid cells.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:37:03.692Z"
          }
        ],
        "updatedAt": "2026-01-27T00:37:03.692Z"
      },
      {
        "id": "14",
        "title": "Implement Tab System for Panel Content",
        "description": "Create tab bar system within panels supporting multiple tabs, reordering via drag, close with unsaved indicator, and context menu actions.",
        "details": "1. Create `src/components/panels/TabBar.tsx`:\n   - Horizontal scrollable tab list within panel header area\n   - Active tab indicator: bottom border or background highlight\n   - Tab overflow handling: horizontal scroll with scroll buttons or CSS overflow-x: auto\n   - Integrated into Panel component header section\n\n2. Create `src/components/panels/Tab.tsx`:\n   ```typescript\n   interface TabProps {\n     id: string;\n     icon?: React.ReactNode;\n     title: string;\n     isActive: boolean;\n     isModified: boolean; // Shows dot indicator\n     onActivate: () => void;\n     onClose: () => void;\n   }\n   ```\n   - Icon (optional) + title + close button layout\n   - Modified indicator: colored dot before title when isModified=true\n   - Close button (×) appears on hover or always visible\n   - Draggable for reordering using HTML5 drag API or @dnd-kit/core\n\n3. Create `src/components/panels/TabContent.tsx`:\n   - Content area switching based on active tab\n   - Lazy loading: only render active tab content, use React.memo for others\n   - Smooth transition between tabs (optional fade)\n\n4. Implement tab context menu:\n   - Right-click on tab shows context menu\n   - Options: 'Close', 'Close Others', 'Close All', 'Close to the Right'\n   - Use custom context menu component or react-contextmenu\n\n5. Update Panel component to support tabs:\n   - Panel can contain single content OR multiple tabs\n   - TabBar renders when panel has tabs array\n   - Each tab has its own PanelType and content\n\n6. Extend panelStore for tab management:\n   ```typescript\n   interface TabState {\n     id: string;\n     panelType: PanelType;\n     title: string;\n     isModified: boolean;\n     data?: any; // Tab-specific data\n   }\n   // In PanelState:\n   tabs?: TabState[];\n   activeTabId?: string;\n   // Actions:\n   addTab: (panelId: string, tab: TabState) => void;\n   removeTab: (panelId: string, tabId: string) => void;\n   setActiveTab: (panelId: string, tabId: string) => void;\n   reorderTabs: (panelId: string, fromIndex: number, toIndex: number) => void;\n   ```\n\n7. Implement tab drag reordering:\n   - onDragStart sets dragged tab data\n   - onDragOver allows drop on tab bar\n   - onDrop reorders tabs array",
        "testStrategy": "1. Test tab switching changes visible content to correct tab\n2. Test tab close removes tab from array and switches to adjacent\n3. Test tab reorder via drag updates tab order in store\n4. Test modified indicator (dot) appears when isModified=true\n5. Test context menu 'Close Others' closes all except right-clicked tab\n6. Test overflow scroll appears when many tabs exceed width",
        "priority": "medium",
        "dependencies": [
          "13"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Tab Types and Extend Panel Store with Tab State",
            "description": "Create TypeScript interfaces for TabState and TabBarProps, then extend the existing panelStore (from Task 13) with tab-related state properties and actions.",
            "dependencies": [],
            "details": "Create `src/types/tab.ts` with TabState interface including id, panelType, title, isModified, and optional data properties. Extend the PanelState interface in the panel store to include optional `tabs?: TabState[]` and `activeTabId?: string` properties. Add store actions: `addTab(panelId: string, tab: TabState)`, `removeTab(panelId: string, tabId: string)`, `setActiveTab(panelId: string, tabId: string)`, `reorderTabs(panelId: string, fromIndex: number, toIndex: number)`, and `updateTabModified(panelId: string, tabId: string, isModified: boolean)`. Ensure proper TypeScript typing with generics for tab data.",
            "status": "done",
            "testStrategy": "Unit test each store action: verify addTab creates tab with correct properties and sets it as active if first tab, removeTab removes correct tab and switches activeTab to adjacent if removed was active, setActiveTab updates activeTabId, reorderTabs correctly reorders the tabs array, updateTabModified toggles the isModified flag.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:38:51.142Z"
          },
          {
            "id": 2,
            "title": "Create Tab Component with Modified Indicator and Close Button",
            "description": "Build the individual Tab component with icon, title, modified indicator (dot), close button on hover, and support for drag handle integration.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/panels/Tab.tsx` implementing TabProps interface: { id: string, icon?: React.ReactNode, title: string, isActive: boolean, isModified: boolean, onActivate: () => void, onClose: () => void, onContextMenu: (e: React.MouseEvent) => void }. Style with Tailwind CSS: active tab has bottom border or background highlight, inactive tabs are muted. Display colored dot indicator before title when isModified=true. Close button (×) appears on hover or always visible for active tab. Add draggable attribute and data-tab-id for drag-and-drop support. Handle click for activation and prevent close button click from bubbling to tab click.",
            "status": "done",
            "testStrategy": "Test tab click calls onActivate, close button click calls onClose without triggering onActivate, modified indicator dot appears when isModified=true, active state applies correct visual styling (border/background), right-click triggers onContextMenu callback.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:39:32.610Z"
          },
          {
            "id": 3,
            "title": "Build TabBar Component with Horizontal Scrolling and Overflow Handling",
            "description": "Create the TabBar container component that renders tabs horizontally with scroll support, active tab indicator, and integration with the panel header area.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/components/panels/TabBar.tsx` that maps over panel's tabs array from store and renders Tab components. Implement horizontal scrollable container using CSS `overflow-x: auto` with hidden scrollbar styling or custom scroll buttons for overflow. Track activeTabId from store and pass isActive prop to each Tab. Wire up onActivate to call setActiveTab action, onClose to call removeTab action. Handle empty tabs state gracefully. Add drop zone for tab drag reordering using HTML5 drag events (onDragOver, onDrop). Calculate drop position based on mouse position relative to tab elements.",
            "status": "done",
            "testStrategy": "Test TabBar renders all tabs from panel state, clicking tab triggers setActiveTab store action, closing tab triggers removeTab action, horizontal scroll appears when tabs exceed container width, active tab is visually distinct, tab reorder drop zone accepts dragged tabs.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:40:47.487Z"
          },
          {
            "id": 4,
            "title": "Implement Tab Context Menu with Close Actions",
            "description": "Create a context menu component for tabs with options like Close, Close Others, Close All, and Close to the Right.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create `src/components/panels/TabContextMenu.tsx` as a custom context menu (positioned dropdown) or integrate with a context menu library. Menu options: 'Close' (closes the right-clicked tab), 'Close Others' (closes all tabs except the right-clicked one), 'Close All' (closes all tabs in the panel), 'Close to the Right' (closes all tabs after the right-clicked tab). Each action dispatches appropriate removeTab calls to the store. Position menu at mouse coordinates on right-click. Close menu on click outside or Escape key. Disable 'Close Others' and 'Close to the Right' when only one tab exists.",
            "status": "done",
            "testStrategy": "Test context menu appears at correct position on right-click, 'Close' removes only the clicked tab, 'Close Others' removes all except clicked tab and makes it active, 'Close All' removes all tabs from panel, 'Close to the Right' removes tabs after clicked index, menu closes on outside click and Escape key.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:41:22.519Z"
          },
          {
            "id": 5,
            "title": "Integrate TabBar and TabContent into Panel Component",
            "description": "Update the Panel component from Task 13 to conditionally render TabBar when tabs exist, implement TabContent area with lazy loading, and wire up tab drag reordering logic.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Modify `src/components/panels/Panel.tsx` to check if panel has tabs array. If tabs exist, render TabBar in the header section below or replacing the title. Create `src/components/panels/TabContent.tsx` that switches content based on activeTabId, rendering the appropriate PanelType component for the active tab. Implement lazy loading: only mount active tab content, use React.memo for performance. Add optional smooth fade transition between tabs using CSS or framer-motion. Implement full drag reordering: onDragStart sets dragged tab info in dataTransfer, onDragOver on TabBar allows drop, onDrop calculates new position and calls reorderTabs action. Handle edge case of single-tab panels (show tab or just title).",
            "status": "done",
            "testStrategy": "Test Panel with tabs renders TabBar in header, Panel without tabs renders single content area, tab switching changes TabContent to correct panel type component, lazy loading only renders active tab content, tab drag reordering updates tabs array order in store, context menu integration works from Tab through TabBar to Panel.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:22:42.826Z"
          }
        ],
        "updatedAt": "2026-01-27T05:22:42.826Z"
      },
      {
        "id": "15",
        "title": "Add Panel Drag-and-Drop for Layout Customization",
        "description": "Enable panel drag-and-drop to rearrange layout, split panels by dropping on edges, merge panels as tabs by dropping in center, with visual guides and animations.",
        "details": "1. Install @dnd-kit/core and @dnd-kit/sortable:\n   ```bash\n   npm install @dnd-kit/core @dnd-kit/sortable\n   ```\n\n2. Create `src/components/panels/DraggablePanel.tsx`:\n   - Wrap Panel component with DnD context\n   - Drag handle in panel header (grip icon or entire header)\n   - Visual feedback during drag: reduced opacity (0.5), shadow\n   - useDraggable hook from @dnd-kit/core\n\n3. Create `src/components/panels/DropZone.tsx`:\n   - Overlay component rendered during drag operations\n   - Position indicators: top, bottom, left, right edges + center\n   - Highlight zone when panel dragged over (blue overlay)\n   - Different visual for edge drop (split) vs center drop (merge)\n\n4. Implement panel split functionality:\n   - Detect drop position (top/bottom for horizontal split, left/right for vertical)\n   - Dropping on edge splits the target area:\n     - Top edge: new row above, target moves down\n     - Left edge: new column left, target moves right\n   - Update gridConfig to add new row/column\n   - Assign new gridArea to dropped panel\n\n5. Implement panel merge functionality:\n   - Dropping in center of panel adds as new tab\n   - Convert target panel to tabbed panel if not already\n   - Add dragged panel content as new tab\n   - Remove original panel from grid\n\n6. Create `src/components/panels/DragOverlay.tsx`:\n   - Ghost preview of panel at cursor during drag\n   - Shows panel title and type icon\n   - Animated snap to drop zone on approach\n\n7. Add visual guides during drag:\n   - Grid lines showing potential split positions\n   - Animated transitions when layout rearranges\n   - Use CSS transitions for smooth panel size changes\n\n8. Create DnD context provider:\n   ```typescript\n   // src/providers/PanelDndProvider.tsx\n   export function PanelDndProvider({ children }) {\n     return (\n       <DndContext onDragStart onDragOver onDragEnd sensors modifiers>\n         {children}\n         <DragOverlay>{/* Active item preview */}</DragOverlay>\n       </DndContext>\n     );\n   }\n   ```",
        "testStrategy": "1. Test panel drag shows visual feedback (opacity, cursor)\n2. Test drop on edge creates split layout with new grid cell\n3. Test drop in center merges panels as tabs\n4. Test drop zone highlights correctly when dragged over\n5. Test layout persists after drag operations (check panelStore)\n6. E2E test complex rearrangement: drag panel A to right of B, then drag C to bottom",
        "priority": "medium",
        "dependencies": [
          "14"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install @dnd-kit Dependencies and Create PanelDndProvider Context",
            "description": "Set up the drag-and-drop infrastructure by installing @dnd-kit packages and creating the DnD context provider that wraps the panel system.",
            "dependencies": [],
            "details": "1. Install required packages: `npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities`\n\n2. Create `src/providers/PanelDndProvider.tsx`:\n   - Import DndContext, DragOverlay, useSensors, useSensor, PointerSensor, KeyboardSensor from @dnd-kit/core\n   - Configure sensors with activation constraints (distance: 10px) to prevent accidental drags\n   - Set up collision detection strategy (closestCenter or rectIntersection)\n   - Implement onDragStart, onDragOver, and onDragEnd event handlers\n   - Track active dragging panel ID in local state\n   - Export context for accessing drag state from child components\n\n3. Create `src/types/dnd.ts` for DnD-specific type definitions:\n   - DropPosition type: 'top' | 'bottom' | 'left' | 'right' | 'center'\n   - DragData interface with panelId, panelType, sourceGridArea\n   - DropResult interface with targetPanelId, dropPosition, targetGridArea\n\n4. Integrate PanelDndProvider into app component tree, wrapping PanelContainer",
            "status": "done",
            "testStrategy": "Test DndContext renders children correctly. Test sensors are configured with correct activation constraints. Test drag events fire onDragStart/onDragEnd handlers. Verify PanelDndProvider exports context value accessible by child components.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:24:25.709Z"
          },
          {
            "id": 2,
            "title": "Create DraggablePanel Component with Drag Handle and Visual Feedback",
            "description": "Implement the DraggablePanel wrapper component that makes panels draggable with a drag handle in the header and visual feedback during drag operations.",
            "dependencies": [
              1
            ],
            "details": "1. Create `src/components/panels/DraggablePanel.tsx`:\n   - Import useDraggable hook from @dnd-kit/core\n   - Wrap existing Panel component with draggable functionality\n   - Pass panel ID and type as draggable data\n\n2. Implement drag handle in panel header:\n   - Add grip icon (6-dot pattern or similar) to left side of panel header\n   - Use CSS cursor: grab (cursor: grabbing when active)\n   - Apply drag handle ref from useDraggable to grip element\n   - Alternative: make entire header draggable (configurable via prop)\n\n3. Add visual feedback during drag:\n   - Reduce opacity to 0.5 when isDragging is true\n   - Add box-shadow for elevation effect\n   - Apply CSS transform from useDraggable for smooth positioning\n   - Add transition for opacity changes\n\n4. Update Panel component to accept draggable props:\n   - Add isDragging prop to conditionally apply drag styles\n   - Ensure panel header renders drag handle slot\n\n5. Add keyboard accessibility: support Enter/Space to initiate drag",
            "status": "done",
            "testStrategy": "Test drag handle renders with correct cursor style. Test useDraggable hook provides correct attributes and listeners. Test opacity reduces to 0.5 when isDragging=true. Test drag data contains correct panelId and panelType. Test keyboard activation works with Enter key.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:26:23.132Z"
          },
          {
            "id": 3,
            "title": "Create DropZone Overlay and DragOverlay Preview Components",
            "description": "Implement the DropZone component showing position indicators during drag and DragOverlay component displaying a ghost preview of the dragged panel.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Create `src/components/panels/DropZone.tsx`:\n   - Import useDroppable hook from @dnd-kit/core\n   - Create overlay component that renders on top of target panels during drag\n   - Implement 5 drop zones per panel: top, bottom, left, right (edges), center\n   - Each zone occupies ~25% of edge area, center takes remaining area\n   - Use isOver and active from useDroppable to detect hover state\n\n2. Implement visual indicators:\n   - Edge zones (split): semi-transparent blue overlay on hovered edge\n   - Center zone (merge): different visual - dashed border or tab icon overlay\n   - Show split preview line when hovering edge zones\n   - Animate highlight transitions with CSS transitions (opacity, background-color)\n\n3. Create `src/components/panels/DragOverlay.tsx`:\n   - Render ghost preview following cursor during drag\n   - Show panel title, type icon, and miniature panel appearance\n   - Apply slight scale (0.9) and rotation (2deg) for lifted effect\n   - Add subtle shadow for depth\n   - Animate snap-to-drop-zone when approaching valid target\n\n4. Integrate DragOverlay into PanelDndProvider:\n   - Render DragOverlay component with active panel content\n   - Pass dragged panel metadata for preview rendering\n\n5. Implement conditional rendering: only show DropZone overlays when drag is active",
            "status": "done",
            "testStrategy": "Test DropZone renders 5 distinct drop regions (top, bottom, left, right, center). Test hover highlight appears on correct zone when dragged over. Test edge zones show split visual vs center shows merge visual. Test DragOverlay follows cursor position during drag. Test DragOverlay displays correct panel title and icon.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:26:23.140Z"
          },
          {
            "id": 4,
            "title": "Implement Panel Split Functionality for Edge Drop Operations",
            "description": "Implement the logic to split panels when dropping on edges, updating the CSS Grid configuration to create new rows or columns.",
            "dependencies": [
              2,
              3
            ],
            "details": "1. Create `src/utils/gridUtils.ts` for grid manipulation functions:\n   - calculateDropPosition(event, targetRect): determines which edge/center was targeted\n   - splitGridColumn(gridConfig, targetArea, position): adds new column left/right\n   - splitGridRow(gridConfig, targetArea, position): adds new row above/below\n   - generateNewGridArea(existingAreas): creates unique grid area name\n\n2. Implement split logic in onDragEnd handler:\n   - Top edge drop: insert new row above target, move target down\n   - Bottom edge drop: insert new row below target\n   - Left edge drop: insert new column left, move target right\n   - Right edge drop: insert new column right of target\n\n3. Update panel store with split actions:\n   - splitPanelHorizontal(targetPanelId, droppedPanelId, position: 'top'|'bottom')\n   - splitPanelVertical(targetPanelId, droppedPanelId, position: 'left'|'right')\n   - Each action updates gridConfig.columns/rows and reassigns gridArea values\n\n4. Handle grid area name updates:\n   - Assign new gridArea to dropped panel\n   - Update grid-template-areas in gridConfig\n   - Ensure unique naming convention (e.g., 'panel-{id}')\n\n5. Add CSS transitions to PanelContainer:\n   - Animate grid-template-columns and grid-template-rows changes\n   - Use transition duration of 200-300ms for smooth resize\n\n6. Edge case handling: prevent splitting to create panels smaller than minimum size",
            "status": "done",
            "testStrategy": "Test drop on top edge creates new row above and positions dragged panel there. Test drop on left edge creates new column left of target. Test gridConfig updates correctly with new column/row values. Test CSS transitions animate panel size changes. Test minimum size constraint prevents invalid splits.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:29:42.954Z"
          },
          {
            "id": 5,
            "title": "Implement Panel Merge as Tabs and Add Visual Guides with Animations",
            "description": "Implement center drop merging panels as tabs, add grid line visual guides during drag, and ensure layout persistence after drag operations.",
            "dependencies": [
              3,
              4
            ],
            "details": "1. Implement merge functionality in onDragEnd handler:\n   - Detect center drop via calculateDropPosition\n   - If target panel has no tabs: convert to tabbed panel, add dragged panel as second tab\n   - If target already tabbed: append dragged panel as new tab\n   - Remove dragged panel from its original grid position\n   - Update panel store's tabs array for target panel\n\n2. Create merge store actions:\n   - mergePanelAsTabs(targetPanelId, sourcePanelId): converts/adds to tabs\n   - removePanelFromGrid(panelId): removes panel and collapses empty grid areas\n   - collapseEmptyGridAreas(gridConfig): removes unused rows/columns after panel removal\n\n3. Add visual guides during drag in `src/components/panels/DragGuides.tsx`:\n   - Render grid lines showing potential split positions\n   - Display dashed lines at 50% marks of each panel\n   - Show animated guides that pulse when hovering valid drop zones\n   - Use CSS position: absolute overlay on PanelContainer\n\n4. Implement smooth animations:\n   - CSS transitions for panel size changes (width, height): 250ms ease-out\n   - Animate tab bar expansion when merging panels\n   - Fade-out animation for removed panel grid area\n   - Use requestAnimationFrame for smooth guide line rendering\n\n5. Ensure layout persistence:\n   - Call panelStore.persistLayout() after any drag operation completes\n   - Verify gridConfig and panel positions saved to storage\n   - Add debounced auto-save after layout changes\n\n6. Add undo support: store previous layout state for Ctrl+Z reversal",
            "status": "done",
            "testStrategy": "Test drop in center converts target to tabbed panel with dragged panel as new tab. Test already tabbed panel receives new tab on center drop. Test original panel removed from grid after merge. Test visual grid guides appear during active drag. Test layout persists to panelStore after drag operations complete. E2E test: drag panel A to right of B, then drag C to center of A creating tabs.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:29:42.961Z"
          }
        ],
        "updatedAt": "2026-01-27T05:29:42.961Z"
      },
      {
        "id": "16",
        "title": "Create Settings Dialog with Configuration Panels",
        "description": "Implement modal settings dialog with sidebar navigation for General, Simulation, Modbus, and Appearance settings with save/cancel/apply actions.",
        "details": "1. Create `src/components/settings/SettingsDialog.tsx`:\n   - Modal dialog with 80% viewport width/height, max 800x600\n   - Two-column layout: category sidebar (200px) | settings content\n   - Search bar at top to filter settings by keyword\n   - Footer with Save, Cancel, Apply buttons\n   - ESC key closes dialog with unsaved changes warning\n\n2. Create `src/components/settings/GeneralSettings.tsx`:\n   - Language selection dropdown: 한국어, English, 日本語\n   - Auto-save interval: number input with 'seconds' label (min 30)\n   - Start with last project: checkbox\n   - Telemetry opt-in/out: checkbox with explanation text\n\n3. Create `src/components/settings/SimulationSettings.tsx`:\n   - Default scan time (ms): number input with range 1-1000\n   - Timer precision: dropdown (Low, Medium, High)\n   - Simulation speed multiplier: radio buttons (0.5x, 1x, 2x, 4x)\n   - Step execution mode: dropdown options\n\n4. Create `src/components/settings/ModbusSettings.tsx`:\n   - Default TCP port: number input (range 1-65535, default 502)\n   - Default RTU serial settings:\n     - COM port: dropdown (populated from available ports)\n     - Baud rate: dropdown (9600, 19200, 38400, 57600, 115200)\n     - Parity: dropdown (None, Odd, Even)\n     - Stop bits: dropdown (1, 2)\n   - Connection timeout (ms): number input\n   - Auto-reconnect: checkbox\n\n5. Create `src/components/settings/AppearanceSettings.tsx`:\n   - Theme selection: radio buttons (Light, Dark, System)\n   - Font size adjustment: slider (12px to 20px)\n   - Grid display toggle: checkbox\n   - Animation enable/disable: checkbox\n\n6. Create `src/stores/settingsStore.ts` with Zustand:\n   ```typescript\n   interface AppSettings {\n     language: 'ko' | 'en' | 'ja';\n     theme: 'light' | 'dark' | 'system';\n     autoSaveInterval: number;\n     // ... all settings\n   }\n   interface SettingsStore {\n     settings: AppSettings;\n     pendingChanges: Partial<AppSettings>;\n     loadSettings: () => Promise<void>;\n     saveSettings: () => Promise<void>;\n     updatePending: (key: string, value: any) => void;\n     applyPending: () => void;\n     discardPending: () => void;\n   }\n   ```\n\n7. Add Tauri commands for settings persistence:\n   - In `src-tauri/src/commands/settings.rs`:\n     - `#[tauri::command] get_app_settings() -> Result<AppSettings, String>`\n     - `#[tauri::command] save_app_settings(settings: AppSettings) -> Result<(), String>`\n   - Store in app data directory as `settings.json`\n   - Register commands in main.rs",
        "testStrategy": "1. Test settings dialog opens with current values populated\n2. Test changes are held as pending until Save/Apply clicked\n3. Test Cancel discards pendingChanges and closes dialog\n4. Test Apply saves but keeps dialog open\n5. Test settings persist after app restart (mock Tauri invoke)\n6. Test theme change applies immediately on Apply",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Zustand Settings Store with AppSettings Interface and Pending Changes Logic",
            "description": "Implement the settingsStore.ts with Zustand including the AppSettings interface, pending changes management, and methods for loading, saving, updating, applying, and discarding settings changes.",
            "dependencies": [],
            "details": "Create src/stores/settingsStore.ts with Zustand. Define AppSettings interface with all settings fields: language ('ko' | 'en' | 'ja'), theme ('light' | 'dark' | 'system'), autoSaveInterval (number), startWithLastProject (boolean), telemetryEnabled (boolean), defaultScanTimeMs (number, 1-1000), timerPrecision ('low' | 'medium' | 'high'), simulationSpeedMultiplier (0.5 | 1 | 2 | 4), stepExecutionMode (string), defaultTcpPort (number, 1-65535), rtuComPort (string), rtuBaudRate (9600 | 19200 | 38400 | 57600 | 115200), rtuParity ('none' | 'odd' | 'even'), rtuStopBits (1 | 2), connectionTimeoutMs (number), autoReconnect (boolean), fontSize (number, 12-20), gridDisplay (boolean), animationEnabled (boolean). Define SettingsStore interface with: settings (AppSettings), pendingChanges (Partial<AppSettings>), isLoading (boolean), loadSettings (async function using invoke('get_app_settings')), saveSettings (async function using invoke('save_app_settings')), updatePending (key, value => adds to pendingChanges), applyPending (merges pendingChanges into settings and calls saveSettings), discardPending (clears pendingChanges). Use create<SettingsStore> from zustand with sensible defaults for all settings.",
            "status": "done",
            "testStrategy": "Test store initializes with correct default values. Test updatePending adds changes to pendingChanges without modifying settings. Test applyPending merges changes and resets pendingChanges. Test discardPending clears all pendingChanges. Mock invoke for loadSettings and saveSettings testing.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:22:56.055Z"
          },
          {
            "id": 2,
            "title": "Implement Tauri Commands for Settings Persistence in Rust Backend",
            "description": "Create the settings.rs module with get_app_settings and save_app_settings Tauri commands that persist settings as JSON in the app data directory.",
            "dependencies": [
              1
            ],
            "details": "Create src-tauri/src/commands/settings.rs. Define AppSettings struct matching the TypeScript interface with serde derives for JSON serialization. Implement #[tauri::command] pub async fn get_app_settings(app_handle: tauri::AppHandle) -> Result<AppSettings, String> that reads from app_data_dir/settings.json using tauri::Manager to get app_handle.path().app_data_dir(). Return default AppSettings if file doesn't exist. Implement #[tauri::command] pub async fn save_app_settings(app_handle: tauri::AppHandle, settings: AppSettings) -> Result<(), String> that creates the app data directory if needed and writes settings as JSON. Add pub mod settings to src-tauri/src/commands/mod.rs. Register both commands in main.rs invoke_handler with tauri::generate_handler![commands::settings::get_app_settings, commands::settings::save_app_settings]. Create src/types/settings.ts with TypeScript AppSettings interface matching the Rust struct for type safety.",
            "status": "done",
            "testStrategy": "Test get_app_settings returns defaults when settings.json doesn't exist. Test save_app_settings creates settings.json with correct content. Test roundtrip: save then load returns identical settings. Test error handling for filesystem permission issues. Integration test invoke from frontend.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:23:57.157Z"
          },
          {
            "id": 3,
            "title": "Create SettingsDialog Modal Component with Sidebar Navigation and Footer Actions",
            "description": "Implement the main SettingsDialog.tsx component as a modal with category sidebar, content area, search functionality, and Save/Cancel/Apply action buttons.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/settings/SettingsDialog.tsx. Accept props: isOpen (boolean), onClose (callback). Use a modal overlay with 80% viewport width/height, max 800x600px. Two-column layout: left sidebar (200px width) with category buttons (General, Simulation, Modbus, Appearance) styled with active indicator; right content area rendering the active settings panel. Add search input at top that filters settings by keyword (pass search term to child panels). Footer with three buttons: Cancel (calls discardPending and onClose), Apply (calls applyPending but keeps dialog open), Save (calls applyPending and onClose). Implement ESC key handler that checks for pending changes and shows unsaved warning confirmation before closing. Use Tailwind CSS for styling with dark mode support classes. Import and conditionally render GeneralSettings, SimulationSettings, ModbusSettings, AppearanceSettings based on activeCategory state. Export as named export for use in menu/toolbar triggers.",
            "status": "done",
            "testStrategy": "Test dialog renders when isOpen is true. Test clicking Cancel discards changes and closes. Test clicking Apply saves but keeps dialog open. Test clicking Save saves and closes. Test ESC key triggers unsaved changes warning when pendingChanges exists. Test sidebar navigation switches between panels. Test search input passes filter to child panels.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:28:36.309Z"
          },
          {
            "id": 4,
            "title": "Implement GeneralSettings and SimulationSettings Panel Components",
            "description": "Create the GeneralSettings panel with language, auto-save, startup, and telemetry options, and SimulationSettings panel with scan time, precision, speed, and step mode options.",
            "dependencies": [
              1,
              3
            ],
            "details": "Create src/components/settings/GeneralSettings.tsx with props: searchFilter (string optional). Render settings controls: Language selection dropdown with options 한국어/English/日本語 mapped to 'ko'/'en'/'ja'; Auto-save interval number input with 'seconds' label (min 30, step 10); Start with last project checkbox; Telemetry opt-in/out checkbox with explanation text. Each control calls updatePending from settingsStore on change. Display current value from settings merged with pendingChanges. Filter visibility based on searchFilter matching labels. Create src/components/settings/SimulationSettings.tsx similarly: Default scan time number input (ms) with range 1-1000; Timer precision dropdown (Low/Medium/High); Simulation speed multiplier radio buttons (0.5x/1x/2x/4x); Step execution mode dropdown (options: single-step, until-breakpoint, continuous). Use consistent styling with labels, descriptions, and Tailwind classes including dark mode variants.",
            "status": "done",
            "testStrategy": "Test GeneralSettings renders all four setting controls. Test language dropdown updates pendingChanges.language. Test auto-save input validates minimum value of 30. Test checkbox toggles update boolean settings. Test SimulationSettings renders all controls with correct options. Test search filter hides non-matching settings. Test current values display correctly from store.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:28:36.316Z"
          },
          {
            "id": 5,
            "title": "Implement ModbusSettings and AppearanceSettings Panel Components",
            "description": "Create the ModbusSettings panel with TCP/RTU configuration options and AppearanceSettings panel with theme, font size, grid, and animation toggles.",
            "dependencies": [
              1,
              3
            ],
            "details": "Create src/components/settings/ModbusSettings.tsx with: Default TCP port number input (range 1-65535, default 502); RTU serial settings section with: COM port dropdown (populated via invoke('list_serial_ports') or placeholder for manual entry), Baud rate dropdown (9600/19200/38400/57600/115200), Parity dropdown (None/Odd/Even), Stop bits dropdown (1/2); Connection timeout number input (ms, default 3000); Auto-reconnect checkbox. Group RTU settings visually with a fieldset or bordered section. Create src/components/settings/AppearanceSettings.tsx with: Theme selection as three radio buttons (Light/Dark/System) with icons; Font size slider input ranging 12px to 20px with current value display; Grid display toggle checkbox; Animation enable/disable checkbox. For theme, apply immediately on change for preview (using document.documentElement.classList.toggle('dark')). Style consistently with other panels, support dark mode, and implement searchFilter prop for filtering.",
            "status": "done",
            "testStrategy": "Test ModbusSettings renders TCP and RTU configuration sections. Test port input validates range 1-65535. Test RTU dropdowns have correct options. Test AppearanceSettings renders theme radios with correct values. Test font size slider respects 12-20 range. Test theme change applies immediately for preview. Test search filter works across both panels. Test all controls update pendingChanges correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:28:36.322Z"
          }
        ],
        "updatedAt": "2026-01-27T04:28:36.322Z"
      },
      {
        "id": "17",
        "title": "Implement Theme System with Dark Mode Support",
        "description": "Create theme provider supporting Light/Dark/System themes with Tailwind CSS dark mode class strategy and system preference detection.",
        "details": "1. Create `src/providers/ThemeProvider.tsx`:\n   ```typescript\n   type Theme = 'light' | 'dark' | 'system';\n   interface ThemeContextValue {\n     theme: Theme;\n     resolvedTheme: 'light' | 'dark'; // Actual applied theme\n     setTheme: (theme: Theme) => void;\n   }\n   const ThemeContext = createContext<ThemeContextValue>(...);\n   ```\n   - System theme detection: window.matchMedia('(prefers-color-scheme: dark)')\n   - Listen to matchMedia change event for auto-switch\n   - Apply 'dark' class to document.documentElement based on resolvedTheme\n\n2. Create `src/hooks/useTheme.ts`:\n   ```typescript\n   export function useTheme() {\n     const { theme, resolvedTheme, setTheme } = useContext(ThemeContext);\n     const isDark = resolvedTheme === 'dark';\n     return { theme, setTheme, isDark };\n   }\n   ```\n\n3. Configure Tailwind CSS for dark mode in `tailwind.config.js`:\n   ```javascript\n   module.exports = {\n     darkMode: 'class',\n     theme: {\n       extend: {\n         colors: {\n           // Custom semantic colors if needed\n         }\n       }\n     }\n   }\n   ```\n\n4. Create CSS custom properties for theme colors in `src/index.css`:\n   ```css\n   :root {\n     --color-bg-primary: theme('colors.white');\n     --color-text-primary: theme('colors.gray.900');\n     --color-border: theme('colors.gray.200');\n   }\n   .dark {\n     --color-bg-primary: theme('colors.gray.900');\n     --color-text-primary: theme('colors.gray.100');\n     --color-border: theme('colors.gray.700');\n   }\n   ```\n\n5. Update all existing components with dark mode variants:\n   - Background: `bg-white dark:bg-gray-900`\n   - Text: `text-gray-900 dark:text-gray-100`\n   - Borders: `border-gray-200 dark:border-gray-700`\n   - Hover states: `hover:bg-gray-100 dark:hover:bg-gray-800`\n   - Focus rings: adjust for visibility on dark backgrounds\n\n6. Add theme toggle locations:\n   - AppearanceSettings in settings dialog (primary)\n   - StatusBar quick toggle (moon/sun icon button)\n   - Activity bar settings icon tooltip menu (optional)\n\n7. Persist theme preference:\n   - Save to settingsStore.settings.theme\n   - Load on app start via ThemeProvider initialization\n   - Sync with Tauri settings persistence",
        "testStrategy": "1. Test theme toggle switches between light/dark visual appearance\n2. Test 'system' theme follows OS preference (mock matchMedia)\n3. Test theme persists after page reload (check localStorage or Tauri store)\n4. Test all components have proper dark mode styles (visual inspection)\n5. Test system preference change updates theme when 'system' selected\n6. Test quick toggle in StatusBar changes theme",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ThemeProvider Context and Provider Component",
            "description": "Implement the ThemeProvider.tsx component with React Context for theme management, supporting Light/Dark/System theme options with system preference detection.",
            "dependencies": [],
            "details": "Create src/providers/ThemeProvider.tsx with the following implementation:\n1. Define Theme type as 'light' | 'dark' | 'system'\n2. Define ThemeContextValue interface with theme (user selection), resolvedTheme ('light' | 'dark' actual applied), and setTheme function\n3. Create ThemeContext using React.createContext with default values\n4. Implement ThemeProvider component that:\n   - Uses useState for theme state (default: 'system')\n   - Uses useState for resolvedTheme state\n   - Implements getSystemTheme() using window.matchMedia('(prefers-color-scheme: dark)')\n   - Sets up useEffect to listen to matchMedia 'change' event for auto-switching when theme is 'system'\n   - Sets up useEffect to apply/remove 'dark' class on document.documentElement based on resolvedTheme\n   - Provides context value to children\n5. Export ThemeContext and ThemeProvider",
            "status": "done",
            "testStrategy": "Test ThemeProvider renders children correctly. Test context provides default values. Test setTheme updates theme state. Test resolvedTheme correctly reflects 'dark' when theme='dark' and 'light' when theme='light'. Mock window.matchMedia to test system theme detection returns correct value.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:31:57.473Z"
          },
          {
            "id": 2,
            "title": "Implement useTheme Custom Hook and Settings Store Integration",
            "description": "Create the useTheme hook for consuming theme context and integrate theme persistence with the existing settingsStore from Task 16.",
            "dependencies": [
              1
            ],
            "details": "1. Create src/hooks/useTheme.ts:\n   - Import ThemeContext from ThemeProvider\n   - Export useTheme hook that calls useContext(ThemeContext)\n   - Add convenience computed property isDark: resolvedTheme === 'dark'\n   - Return { theme, setTheme, resolvedTheme, isDark }\n   - Throw error if used outside ThemeProvider\n\n2. Integrate with settingsStore (from Task 16):\n   - Ensure AppSettings interface in settingsStore includes theme: 'light' | 'dark' | 'system'\n   - Update ThemeProvider to:\n     a. Read initial theme from settingsStore.settings.theme on mount\n     b. Call settingsStore.updatePending({ theme }) when setTheme is called\n   - Add effect to sync theme changes from settingsStore back to ThemeProvider\n\n3. Ensure theme persists via Tauri settings persistence (leveraging Task 16's save_app_settings command)",
            "status": "done",
            "testStrategy": "Test useTheme returns correct context values. Test useTheme throws when used outside provider. Test isDark computed property returns true when resolvedTheme is 'dark'. Test theme changes are synced to settingsStore.pendingChanges. Test initial theme is loaded from settingsStore on mount. Test theme persists after simulated page reload.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:32:03.596Z"
          },
          {
            "id": 3,
            "title": "Configure Tailwind CSS Dark Mode and CSS Custom Properties",
            "description": "Set up Tailwind CSS dark mode with class strategy and define CSS custom properties for semantic theme colors in the global stylesheet.",
            "dependencies": [],
            "details": "1. Update tailwind.config.js (create if not exists):\n   ```javascript\n   module.exports = {\n     darkMode: 'class',\n     content: ['./src/**/*.{js,ts,jsx,tsx}', './index.html'],\n     theme: {\n       extend: {\n         colors: {\n           // Optional semantic color aliases\n         }\n       }\n     },\n     plugins: []\n   }\n   ```\n\n2. Create/Update src/index.css with CSS custom properties:\n   ```css\n   @tailwind base;\n   @tailwind components;\n   @tailwind utilities;\n\n   :root {\n     --color-bg-primary: theme('colors.white');\n     --color-bg-secondary: theme('colors.gray.50');\n     --color-text-primary: theme('colors.gray.900');\n     --color-text-secondary: theme('colors.gray.600');\n     --color-border: theme('colors.gray.200');\n     --color-accent: theme('colors.blue.600');\n   }\n\n   .dark {\n     --color-bg-primary: theme('colors.gray.900');\n     --color-bg-secondary: theme('colors.gray.800');\n     --color-text-primary: theme('colors.gray.100');\n     --color-text-secondary: theme('colors.gray.400');\n     --color-border: theme('colors.gray.700');\n     --color-accent: theme('colors.blue.400');\n   }\n   ```",
            "status": "done",
            "testStrategy": "Test Tailwind dark: variants work by adding dark class to html element. Test CSS custom properties change values when .dark class is present on root. Verify tailwind.config.js has darkMode: 'class' setting. Visual inspection that colors transition correctly between modes.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:31:57.549Z"
          },
          {
            "id": 4,
            "title": "Create AppearanceSettings Panel with Theme Toggle",
            "description": "Implement the AppearanceSettings panel component for the Settings Dialog (Task 16) with theme selection dropdown, font size controls, and visual preference options.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create src/components/settings/AppearanceSettings.tsx:\n1. Import useTheme hook and useSettingsStore\n2. Create AppearanceSettingsProps interface with searchFilter?: string prop\n3. Implement theme selection using a dropdown/select:\n   - Options: 'Light', 'Dark', 'System (Auto)'\n   - Values: 'light', 'dark', 'system'\n   - onChange calls updatePending({ theme: selectedValue })\n   - Display current theme from pendingChanges.theme ?? settings.theme\n\n4. Add additional appearance settings (as per PRD):\n   - Font size slider/input (12-20px range)\n   - Grid display toggle checkbox\n   - Animation enable/disable checkbox\n\n5. Group settings with labels and implement search filtering:\n   - Each setting group has a label that can be filtered\n   - Hide settings that don't match searchFilter\n\n6. Style with Tailwind dark mode variants:\n   - bg-white dark:bg-gray-800 for containers\n   - text-gray-900 dark:text-gray-100 for text\n   - border-gray-200 dark:border-gray-700 for borders\n\n7. Register AppearanceSettings in SettingsDialog sidebar navigation",
            "status": "done",
            "testStrategy": "Test theme dropdown renders with three options. Test selecting theme calls updatePending with correct value. Test current theme displays from store. Test search filter hides non-matching settings. Test all controls render with correct dark mode styling. Test font size validates within range.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:32:03.602Z"
          },
          {
            "id": 5,
            "title": "Add Theme Quick Toggle to StatusBar and Update Existing Components",
            "description": "Add a theme quick toggle button to the StatusBar component and update all existing layout components with proper dark mode Tailwind variants.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "1. Update StatusBar component (src/components/layout/StatusBar.tsx):\n   - Import useTheme hook\n   - Add theme toggle button (sun/moon icon):\n     - Show SunIcon when isDark is true (click switches to light)\n     - Show MoonIcon when isDark is false (click switches to dark)\n     - Quick toggle cycles: light → dark → light (not system)\n     - Tooltip shows current theme and 'Click to toggle'\n   - Style toggle button: hover:bg-gray-100 dark:hover:bg-gray-800\n\n2. Update all existing layout components with dark mode variants:\n   - MainLayout.tsx: bg-gray-100 dark:bg-gray-900\n   - MenuBar.tsx: bg-white dark:bg-gray-800, text colors, borders\n   - Toolbar.tsx: icon colors, hover states\n   - Sidebar.tsx: bg-gray-50 dark:bg-gray-900, item hover states\n   - Panel.tsx: header bg, content bg, border colors\n   - TabBar.tsx: active/inactive tab styling\n   - ResizeHandle.tsx: handle colors for visibility\n\n3. Update common components:\n   - Button.tsx: primary, secondary, ghost variants with dark mode\n   - Tooltip.tsx: bg-gray-900 dark:bg-gray-100, inverted text\n\n4. Add focus ring adjustments for dark mode visibility:\n   - focus:ring-blue-500 dark:focus:ring-blue-400\n   - focus:ring-offset-white dark:focus:ring-offset-gray-900",
            "status": "done",
            "testStrategy": "Test StatusBar renders theme toggle button. Test clicking toggle switches between light and dark themes. Test toggle icon changes based on current theme. Test all layout components have proper dark mode classes applied. Visual inspection of all components in both light and dark modes. Test focus states are visible in both modes. Test hover states provide adequate contrast.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:33:10.693Z"
          }
        ],
        "updatedAt": "2026-01-27T05:33:10.693Z"
      },
      {
        "id": "18",
        "title": "Add Internationalization (i18n) Support",
        "description": "Implement multi-language support for Korean, English, and Japanese using react-i18next with translation files and language detection.",
        "details": "1. Install i18n dependencies:\n   ```bash\n   npm install react-i18next i18next i18next-browser-languagedetector\n   ```\n\n2. Create `src/i18n/index.ts`:\n   ```typescript\n   import i18n from 'i18next';\n   import { initReactI18next } from 'react-i18next';\n   import LanguageDetector from 'i18next-browser-languagedetector';\n   import en from './locales/en.json';\n   import ko from './locales/ko.json';\n   import ja from './locales/ja.json';\n\n   i18n\n     .use(LanguageDetector)\n     .use(initReactI18next)\n     .init({\n       resources: { en: { translation: en }, ko: { translation: ko }, ja: { translation: ja } },\n       fallbackLng: 'en',\n       interpolation: { escapeValue: false },\n       detection: { order: ['localStorage', 'navigator'] }\n     });\n   export default i18n;\n   ```\n\n3. Create translation files structure:\n   - `src/i18n/locales/en.json`:\n     ```json\n     {\n       \"menu\": {\n         \"file\": { \"label\": \"File\", \"new\": \"New Project\", \"open\": \"Open Project\", \"save\": \"Save\", ... },\n         \"edit\": { \"label\": \"Edit\", \"undo\": \"Undo\", \"redo\": \"Redo\", ... },\n         ...\n       },\n       \"dialog\": { \"newProject\": { \"title\": \"New Project\", \"name\": \"Project Name\", ... } },\n       \"status\": { \"running\": \"Running\", \"stopped\": \"Stopped\", \"paused\": \"Paused\" },\n       \"settings\": { ... },\n       \"errors\": { \"projectNotFound\": \"Project not found: {{path}}\", ... }\n     }\n     ```\n   - `src/i18n/locales/ko.json`: Korean translations\n   - `src/i18n/locales/ja.json`: Japanese translations\n\n4. Create type-safe translation hook in `src/hooks/useTranslation.ts`:\n   ```typescript\n   import { useTranslation as useI18nTranslation } from 'react-i18next';\n   // Re-export with app-specific typing if needed\n   export function useTranslation() {\n     return useI18nTranslation();\n   }\n   ```\n\n5. Update all UI components to use translations:\n   - Import useTranslation hook\n   - Replace hardcoded strings: `t('menu.file.new')` instead of 'New Project'\n   - Use Trans component for complex translations with JSX\n   - Example: `<span>{t('status.running')}</span>`\n\n6. Add language selector to Settings:\n   - Dropdown in GeneralSettings with options\n   - onChange calls i18n.changeLanguage(lng)\n   - Immediate UI update on change\n\n7. Persist language preference:\n   - Save to settingsStore.settings.language\n   - Apply on app initialization\n   - Sync with i18n instance",
        "testStrategy": "1. Test language switch updates all visible text immediately\n2. Test fallback to English for missing translation keys\n3. Test language persists after page reload\n4. Test interpolation works (e.g., error messages with {{path}})\n5. Test language detector picks up browser preference initially\n6. Test all major UI areas have translation coverage",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install i18n Dependencies and Create Core Configuration",
            "description": "Install react-i18next, i18next, and i18next-browser-languagedetector packages. Create the i18n initialization module at src/i18n/index.ts with language detection, fallback, and resource loading setup.",
            "dependencies": [],
            "details": "1. Run npm install to add dependencies:\n   - react-i18next (React bindings for i18next)\n   - i18next (core internationalization framework)\n   - i18next-browser-languagedetector (automatic language detection)\n\n2. Create src/i18n/index.ts with:\n   - Import i18n from 'i18next'\n   - Import initReactI18next from 'react-i18next'\n   - Import LanguageDetector from 'i18next-browser-languagedetector'\n   - Configure detection order: ['localStorage', 'navigator']\n   - Set fallbackLng to 'en'\n   - Set interpolation.escapeValue to false (React handles escaping)\n   - Import and register translation resources for en, ko, ja\n   - Export configured i18n instance\n\n3. Import i18n in main entry point (src/main.tsx or App.tsx) to initialize before app renders",
            "status": "done",
            "testStrategy": "Verify all 3 npm packages install successfully. Test i18n initializes without errors on app startup. Test browser language detection picks up system locale correctly. Test fallback to English when unsupported language detected.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:36:52.672Z"
          },
          {
            "id": 2,
            "title": "Create Translation JSON Files with Comprehensive UI Text Structure",
            "description": "Create locale JSON files for English, Korean, and Japanese at src/i18n/locales/ with organized namespace structure covering menus, dialogs, status messages, settings, and error messages.",
            "dependencies": [
              1
            ],
            "details": "1. Create directory structure: src/i18n/locales/\n\n2. Create src/i18n/locales/en.json with namespaced structure:\n   - menu: { file: { label, new, open, save, saveAs, recent, exit }, edit: { label, undo, redo, cut, copy, paste }, view: { label, toggleSidebar, resetLayout }, simulation: { label, start, stop, pause, step, reset }, modbus: { label, serverSettings, startServer, stopServer }, help: { label, documentation, about } }\n   - dialog: { newProject: { title, name, description, path }, openProject: { title }, settings: { title, save, cancel, apply } }\n   - status: { running, stopped, paused, connected, disconnected }\n   - settings: { general: { language, autoSave, startup }, simulation: { scanTime, precision }, modbus: { tcpPort, rtuPort }, appearance: { theme, fontSize } }\n   - errors: { projectNotFound, saveError, loadError, invalidPath } with {{variable}} interpolation\n   - common: { ok, cancel, save, delete, create, close }\n\n3. Create src/i18n/locales/ko.json with Korean translations matching the same structure\n\n4. Create src/i18n/locales/ja.json with Japanese translations matching the same structure\n\n5. Ensure all keys exist in all 3 files for consistency",
            "status": "done",
            "testStrategy": "Validate JSON syntax is correct for all 3 files. Verify key structure is identical across all locales. Test interpolation variables like {{path}} render correctly. Test special characters (Korean hangul, Japanese kanji/hiragana) display properly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:36:52.679Z"
          },
          {
            "id": 3,
            "title": "Create Type-Safe useTranslation Hook and Translation Utilities",
            "description": "Implement a type-safe wrapper around react-i18next's useTranslation hook in src/hooks/useTranslation.ts with TypeScript support for translation keys and a Trans component helper for JSX interpolation.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Create src/types/i18n.ts with TypeScript type definitions:\n   - Define TranslationKey type based on JSON structure for autocomplete support\n   - Define supported languages type: 'en' | 'ko' | 'ja'\n\n2. Create src/hooks/useTranslation.ts:\n   - Re-export useTranslation from react-i18next with app-specific typing\n   - Export convenience function for namespace-scoped translations\n   - Add useLanguage hook returning current language and changeLanguage function\n   - Include typed t() function with key path support (e.g., 'menu.file.new')\n\n3. Create src/components/common/Trans.tsx:\n   - Wrapper around react-i18next Trans component\n   - Support for JSX interpolation in translations\n   - Type-safe props for translation keys\n\n4. Export all utilities from src/i18n/index.ts for convenient imports\n\n5. Add helper function formatTranslation() for dynamic key construction",
            "status": "done",
            "testStrategy": "Test useTranslation hook returns t function that resolves keys correctly. Test TypeScript catches invalid translation keys at compile time. Test useLanguage hook returns correct current language. Test Trans component renders JSX interpolation properly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:36:52.685Z"
          },
          {
            "id": 4,
            "title": "Integrate Language Selector in Settings Dialog with Persistence",
            "description": "Add language selection dropdown to GeneralSettings panel (from Task 16) that triggers immediate UI language change, persists selection to settingsStore, and syncs with i18n instance on app initialization.",
            "dependencies": [
              3
            ],
            "details": "1. Update GeneralSettings.tsx (from Task 16 subtask 4):\n   - Add language dropdown with options: English, 한국어, 日本語\n   - Each option has value ('en', 'ko', 'ja') and display label in native language\n   - On change, call i18n.changeLanguage(lng) for immediate UI update\n   - Update settingsStore.pendingChanges.language\n\n2. Update AppSettings interface in settingsStore.ts:\n   - Add language: 'en' | 'ko' | 'ja' field with default 'en'\n   - Include language in persistence via save_app_settings command\n\n3. Update settings.rs Tauri command (from Task 16 subtask 2):\n   - Include language field in AppSettings struct\n   - Persist to settings.json\n\n4. Create language sync on app startup:\n   - In App.tsx or useEffect in MainLayout, read language from settingsStore\n   - Call i18n.changeLanguage(storedLanguage) to sync\n   - Ensure this runs after settingsStore loads from Tauri\n\n5. Handle language change side effects:\n   - Update document lang attribute for accessibility\n   - Consider right-to-left support flag for future languages",
            "status": "done",
            "testStrategy": "Test language dropdown shows all 3 options with native labels. Test selecting a language immediately updates all visible UI text. Test language persists after app restart via Tauri storage. Test initial app load respects stored language preference over browser detection.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:36:52.691Z"
          },
          {
            "id": 5,
            "title": "Apply Translations to All UI Components and Create Usage Guidelines",
            "description": "Systematically replace hardcoded strings in all UI components (MenuBar, Toolbar, StatusBar, Dialogs, Panels, Settings) with translation keys using the t() function, and document i18n usage patterns for future development.",
            "dependencies": [
              3,
              4
            ],
            "details": "1. Update MenuBar.tsx (from Task 11):\n   - Replace all menu labels with t('menu.file.label'), t('menu.file.new'), etc.\n   - Update all keyboard shortcut tooltips\n\n2. Update Toolbar.tsx (from Task 11):\n   - Replace button tooltips with translations\n   - Use t() for icon button aria-labels\n\n3. Update StatusBar.tsx (from Task 11):\n   - Replace status text: t('status.running'), t('status.stopped'), etc.\n   - Translate connection status messages\n\n4. Update all Dialog components:\n   - NewProjectDialog, OpenProjectDialog: titles, labels, buttons\n   - SettingsDialog: section titles, field labels\n   - Use t() for all user-visible text\n\n5. Update Panel components:\n   - Panel headers, tab labels, placeholder text\n   - Context menu items\n\n6. Create src/docs/i18n-guide.md (internal documentation):\n   - Usage patterns: t('key'), t('key', { variable }), <Trans> component\n   - Adding new translation keys checklist\n   - Testing translations locally\n   - Naming conventions for translation keys\n\n7. Add eslint rule or comments to flag untranslated strings in future PRs",
            "status": "done",
            "testStrategy": "Test switching language updates MenuBar, Toolbar, StatusBar text immediately. Test error messages display with interpolated values (e.g., file paths). Test all dialogs show translated titles and button labels. Test no hardcoded user-visible strings remain in UI components. Test fallback to English for any missing keys shows key path (development warning).",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:36:59.590Z"
          }
        ],
        "updatedAt": "2026-01-27T05:36:59.590Z"
      },
      {
        "id": "19",
        "title": "Create Layout Persistence and Preset System",
        "description": "Implement layout serialization for save/restore, built-in layout presets (Default, Compact, Debug, Memory Focus), and user custom preset management.",
        "details": "1. Define layout serialization format in `src/types/layout.ts`:\n   ```typescript\n   interface LayoutConfig {\n     name: string;\n     grid: { columns: string[], rows: string[] };\n     panels: {\n       id: string;\n       type: PanelType;\n       gridArea: string;\n       tabs?: { type: PanelType, title: string }[];\n     }[];\n     sidebar: { visible: boolean, width: number, activePanel: string };\n     isBuiltIn?: boolean; // Cannot be deleted if true\n   }\n   ```\n\n2. Create built-in layout presets:\n   - **Default**: 2x2 grid with Ladder Editor (top-left), Memory Visualizer (top-right), One Canvas (bottom-left), Console (bottom-right)\n   - **Compact**: Single panel area with all panels as tabs\n   - **Debug**: 2 rows - main panels top, Console expanded bottom (70/30 split)\n   - **Memory Focus**: Large Memory Visualizer (80% width), Properties panel side\n\n3. Add layout management to panelStore:\n   ```typescript\n   // Additional state and actions:\n   currentLayoutName: string;\n   savedLayouts: LayoutConfig[];\n   saveLayout: (name: string) => void;\n   loadLayout: (name: string) => void;\n   deleteLayout: (name: string) => void;\n   resetToDefault: () => void;\n   exportLayout: (name: string) => LayoutConfig;\n   importLayout: (config: LayoutConfig) => void;\n   getAvailableLayouts: () => LayoutConfig[];\n   ```\n\n4. Create Tauri commands for layout persistence:\n   - In `src-tauri/src/commands/layout.rs`:\n     - `#[tauri::command] save_layout(name: String, config: LayoutConfig) -> Result<(), String>`\n     - `#[tauri::command] load_layout(name: String) -> Result<LayoutConfig, String>`\n     - `#[tauri::command] list_layouts() -> Result<Vec<String>, String>`\n     - `#[tauri::command] delete_layout(name: String) -> Result<(), String>`\n   - Store in app data directory as `layouts.json`\n\n5. Add layout menu in View menu:\n   - Submenu with list of available presets (built-in + user)\n   - Checkmark on currently active layout\n   - Separator line between built-in and user layouts\n   - 'Save Current Layout As...' opens name input dialog\n   - 'Reset Layout' restores Default preset\n\n6. Auto-save layout on application close:\n   - Listen to Tauri window close event\n   - Save current layout as '_lastSession' special preset\n   - On app start, optionally restore last session layout\n\n7. Create `src/components/layout/SaveLayoutDialog.tsx`:\n   - Modal with name input\n   - Shows preview of layout (simplified grid visualization)\n   - Warn if name conflicts with existing",
        "testStrategy": "1. Test saveLayout stores all panel positions and grid config\n2. Test loadLayout restores exact panel arrangement\n3. Test built-in presets (Default, Compact, etc.) apply correct layouts\n4. Test layout persists across app restarts via Tauri storage\n5. Test delete only works for user layouts, not built-in\n6. Test last session layout restored on startup when enabled",
        "priority": "medium",
        "dependencies": [
          "13",
          "16"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Layout Types and Serialization Format",
            "description": "Create TypeScript interfaces for layout configuration in src/types/layout.ts and corresponding Rust structs in src-tauri/src/types/layout.rs for serialization.",
            "dependencies": [],
            "details": "Create src/types/layout.ts with the following interfaces:\n\n1. LayoutConfig interface:\n   - name: string (layout preset name)\n   - grid: { columns: string[], rows: string[] } (CSS grid template definitions)\n   - panels: array of panel configurations with id, type (PanelType), gridArea, and optional tabs\n   - sidebar: { visible: boolean, width: number, activePanel: string }\n   - isBuiltIn?: boolean (prevents deletion if true)\n\n2. Supporting types:\n   - PanelLayoutConfig: { id: string, type: PanelType, gridArea: string, tabs?: TabConfig[] }\n   - TabConfig: { type: PanelType, title: string }\n   - GridConfig: { columns: string[], rows: string[] }\n   - SidebarConfig: { visible: boolean, width: number, activePanel: string }\n\n3. Create corresponding Rust structs in src-tauri/src/types/layout.rs:\n   - LayoutConfig with #[derive(Serialize, Deserialize, Clone)]\n   - PanelLayoutConfig, TabConfig, GridConfig, SidebarConfig\n   - Ensure field names match TypeScript (use serde rename if needed)\n\n4. Export types from src/types/index.ts for easy importing throughout the application.",
            "status": "done",
            "testStrategy": "Unit test that LayoutConfig can be serialized to JSON and deserialized back correctly. Test that all required fields are present. Test TypeScript compilation catches missing required fields. Test Rust structs serialize/deserialize with serde_json. Verify round-trip serialization preserves all data.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:00:02.655Z"
          },
          {
            "id": 2,
            "title": "Create Built-in Layout Presets",
            "description": "Define the four built-in layout presets (Default, Compact, Debug, Memory Focus) as constant configurations with isBuiltIn flag set to true.",
            "dependencies": [
              1
            ],
            "details": "Create src/config/layoutPresets.ts with the following presets:\n\n1. DEFAULT_LAYOUT:\n   - 2x2 grid: columns ['1fr', '1fr'], rows ['1fr', '1fr']\n   - Panels: Ladder Editor (top-left, gridArea: '1/1/2/2'), Memory Visualizer (top-right, gridArea: '1/2/2/3'), One Canvas (bottom-left, gridArea: '2/1/3/2'), Console (bottom-right, gridArea: '2/2/3/3')\n   - Sidebar: visible=true, width=250, activePanel='explorer'\n   - isBuiltIn=true\n\n2. COMPACT_LAYOUT:\n   - 1x1 grid: columns ['1fr'], rows ['1fr']\n   - Single panel with all panels as tabs array\n   - isBuiltIn=true\n\n3. DEBUG_LAYOUT:\n   - 2-row split (70/30): columns ['1fr'], rows ['70fr', '30fr']\n   - Main panels as tabs (top), Console expanded (bottom)\n   - isBuiltIn=true\n\n4. MEMORY_FOCUS_LAYOUT:\n   - 2-column split (80/20): columns ['80fr', '20fr'], rows ['1fr']\n   - Large Memory Visualizer (left), Properties panel (right)\n   - isBuiltIn=true\n\n5. Export BUILT_IN_LAYOUTS array containing all presets\n6. Export getPresetByName(name: string) helper function",
            "status": "done",
            "testStrategy": "Test each preset has isBuiltIn=true. Test DEFAULT_LAYOUT has exactly 4 panels in correct grid positions. Test COMPACT_LAYOUT has single panel with 4 tabs. Test DEBUG_LAYOUT has 70/30 split ratio. Test MEMORY_FOCUS_LAYOUT has 80/20 split. Test getPresetByName returns correct preset or undefined for unknown names.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:00:53.469Z"
          },
          {
            "id": 3,
            "title": "Implement Tauri Commands for Layout Persistence",
            "description": "Create Rust Tauri commands for saving, loading, listing, and deleting layouts with file-based persistence in the app data directory.",
            "dependencies": [
              1
            ],
            "details": "Create src-tauri/src/commands/layout.rs with the following commands:\n\n1. #[tauri::command] pub async fn save_layout(app: AppHandle, name: String, config: LayoutConfig) -> Result<(), String>\n   - Validate name is not empty and doesn't contain invalid characters\n   - Load existing layouts.json from app_data_dir\n   - Add/update layout in the list\n   - Write back to layouts.json with pretty formatting\n   - Handle file creation if doesn't exist\n\n2. #[tauri::command] pub async fn load_layout(app: AppHandle, name: String) -> Result<LayoutConfig, String>\n   - Read layouts.json from app_data_dir\n   - Find layout by name, return error if not found\n   - Return the LayoutConfig\n\n3. #[tauri::command] pub async fn list_layouts(app: AppHandle) -> Result<Vec<String>, String>\n   - Read layouts.json, return list of layout names\n   - Return empty vec if file doesn't exist\n\n4. #[tauri::command] pub async fn delete_layout(app: AppHandle, name: String) -> Result<(), String>\n   - Check isBuiltIn flag, return error if true\n   - Remove layout from list and save\n\n5. Register commands in src-tauri/src/lib.rs tauri::Builder\n6. Use tauri::path::BaseDirectory::AppData for storage location\n7. Create LayoutStorage struct to encapsulate file operations",
            "status": "done",
            "testStrategy": "Test save_layout creates layouts.json if not exists. Test load_layout returns error for non-existent layout. Test list_layouts returns empty vec for new installation. Test delete_layout fails for built-in layouts with appropriate error message. Test save then load returns identical config. Test concurrent saves don't corrupt file. Integration test with actual Tauri app context.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:01:01.481Z"
          },
          {
            "id": 4,
            "title": "Extend panelStore with Layout Management Actions",
            "description": "Add layout management state and actions to the existing panelStore including save, load, delete, export, import, and preset selection functionality.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Extend src/stores/panelStore.ts with layout management:\n\n1. Add new state properties:\n   - currentLayoutName: string (name of currently active layout)\n   - savedLayouts: LayoutConfig[] (cached list of user layouts)\n   - isLayoutModified: boolean (track unsaved changes)\n\n2. Add new actions:\n   - saveLayout: (name: string) => Promise<void> - serialize current state, call Tauri save_layout\n   - loadLayout: (name: string) => Promise<void> - call Tauri load_layout, apply to state\n   - deleteLayout: (name: string) => Promise<void> - call Tauri delete_layout, refresh savedLayouts\n   - resetToDefault: () => void - load DEFAULT_LAYOUT preset\n   - exportLayout: (name: string) => LayoutConfig - return current state as LayoutConfig\n   - importLayout: (config: LayoutConfig) => void - apply external config to state\n   - getAvailableLayouts: () => LayoutConfig[] - return built-in + user layouts\n   - refreshSavedLayouts: () => Promise<void> - reload from Tauri storage\n   - setLayoutModified: (modified: boolean) => void\n\n3. Helper functions:\n   - serializeCurrentLayout(): LayoutConfig - convert current store state to config\n   - applyLayoutConfig(config: LayoutConfig): void - apply config to store state\n\n4. Initialize savedLayouts on store creation by calling refreshSavedLayouts\n5. Track layout modifications by subscribing to relevant state changes",
            "status": "done",
            "testStrategy": "Test saveLayout calls Tauri command with serialized state. Test loadLayout applies config to panels, grid, and sidebar state. Test deleteLayout removes from savedLayouts cache. Test resetToDefault applies DEFAULT_LAYOUT. Test getAvailableLayouts returns combined built-in and user layouts. Test isLayoutModified becomes true when panels change. Test export/import round-trip preserves layout. Mock Tauri invoke for unit tests.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:02:38.913Z"
          },
          {
            "id": 5,
            "title": "Create SaveLayoutDialog and View Menu Integration",
            "description": "Implement the SaveLayoutDialog modal component and integrate layout selection/management into the View menu with auto-save on close functionality.",
            "dependencies": [
              2,
              4
            ],
            "details": "1. Create src/components/layout/SaveLayoutDialog.tsx:\n   - Modal with name input field (validate non-empty, no special chars)\n   - Show simplified grid preview of current layout\n   - Warning message if name conflicts with existing layout\n   - Checkbox for 'Replace existing' when name exists\n   - Save and Cancel buttons\n   - Call panelStore.saveLayout on confirm\n\n2. Update MenuBar View menu (src/components/layout/MenuBar.tsx):\n   - Add 'Layouts' submenu\n   - List built-in presets with separator (Default, Compact, Debug, Memory Focus)\n   - List user layouts below separator (from panelStore.savedLayouts)\n   - Checkmark on currentLayoutName\n   - 'Save Current Layout As...' opens SaveLayoutDialog\n   - 'Reset Layout' calls panelStore.resetToDefault()\n   - 'Manage Layouts...' submenu with delete options for user layouts\n\n3. Implement auto-save on close:\n   - Listen to Tauri window close-requested event in App.tsx\n   - Save current layout as '_lastSession' before closing\n   - On app start, check settings for 'restoreLastSession' flag\n   - If enabled, call loadLayout('_lastSession')\n\n4. Add keyboard shortcut Ctrl+Shift+S for 'Save Layout As...' in layoutStore shortcuts\n5. Create src/components/layout/LayoutPreview.tsx for simplified grid visualization in dialog",
            "status": "done",
            "testStrategy": "Test SaveLayoutDialog validates empty name shows error. Test name conflict shows warning message. Test Save button calls saveLayout with entered name. Test Cancel closes dialog without saving. Test View menu shows all built-in presets. Test checkmark appears on active layout. Test clicking preset calls loadLayout. Test auto-save triggers on window close event. Test '_lastSession' layout restores on startup when enabled. E2E test: create layout, restart app, verify restored.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:06:40.462Z"
          }
        ],
        "updatedAt": "2026-01-27T10:06:40.462Z"
      },
      {
        "id": "20",
        "title": "Implement ModbusMemory Struct with Memory Map",
        "description": "Create Rust ModbusMemory struct managing Coils, Discrete Inputs, Holding Registers, and Input Registers with thread-safe access and CSV snapshot support.",
        "details": "1. Add dependencies to `src-tauri/Cargo.toml`:\n   ```toml\n   bitvec = \"1\"\n   parking_lot = \"0.12\"\n   ```\n\n2. Create modbus module structure in `src-tauri/src/modbus/`:\n   ```\n   modbus/\n   ├── mod.rs\n   ├── memory.rs\n   ├── server.rs\n   ├── tcp.rs\n   ├── rtu.rs\n   ├── protocol.rs\n   └── types.rs\n   ```\n\n3. Create `src-tauri/src/modbus/memory.rs`:\n   ```rust\n   use bitvec::prelude::*;\n   use parking_lot::RwLock;\n\n   pub struct ModbusMemory {\n       coils: RwLock<BitVec<u8, Msb0>>,\n       discrete_inputs: RwLock<BitVec<u8, Msb0>>,\n       holding_registers: RwLock<Vec<u16>>,\n       input_registers: RwLock<Vec<u16>>,\n       config: MemoryMapSettings,\n   }\n   ```\n\n4. Implement memory access methods:\n   ```rust\n   impl ModbusMemory {\n     pub fn new(config: &MemoryMapSettings) -> Self;\n\n     // Coils (Function codes 0x01, 0x05, 0x0F)\n     pub fn read_coils(&self, start: u16, count: u16) -> Result<Vec<bool>, MemoryError>;\n     pub fn write_coil(&self, address: u16, value: bool) -> Result<(), MemoryError>;\n     pub fn write_coils(&self, start: u16, values: &[bool]) -> Result<(), MemoryError>;\n\n     // Discrete Inputs (Function code 0x02)\n     pub fn read_discrete_inputs(&self, start: u16, count: u16) -> Result<Vec<bool>, MemoryError>;\n     pub fn write_discrete_input(&self, address: u16, value: bool) -> Result<(), MemoryError>; // Internal use\n\n     // Holding Registers (Function codes 0x03, 0x06, 0x10)\n     pub fn read_holding_registers(&self, start: u16, count: u16) -> Result<Vec<u16>, MemoryError>;\n     pub fn write_holding_register(&self, address: u16, value: u16) -> Result<(), MemoryError>;\n     pub fn write_holding_registers(&self, start: u16, values: &[u16]) -> Result<(), MemoryError>;\n\n     // Input Registers (Function code 0x04)\n     pub fn read_input_registers(&self, start: u16, count: u16) -> Result<Vec<u16>, MemoryError>;\n     pub fn write_input_register(&self, address: u16, value: u16) -> Result<(), MemoryError>; // Internal use\n   }\n   ```\n\n5. Add bounds checking and error handling:\n   ```rust\n   #[derive(Error, Debug)]\n   pub enum MemoryError {\n     #[error(\"Address out of range: {address} (valid: {start}-{end})\")]\n     AddressOutOfRange { address: u16, start: u16, end: u16 },\n     #[error(\"Count exceeds available range: requested {count} from {address}, available {available}\")]\n     CountExceedsRange { address: u16, count: u16, available: u16 },\n   }\n   ```\n\n6. Implement CSV snapshot:\n   ```rust\n   pub fn save_to_csv(&self, path: &Path) -> Result<(), std::io::Error>;\n   pub fn load_from_csv(&self, path: &Path) -> Result<(), std::io::Error>;\n   // Format: address,type,value (e.g., '0,coil,1' or '40001,holding,1234')\n   ```",
        "testStrategy": "1. Unit test read/write for each memory type at various addresses\n2. Test boundary conditions (address=0, address=max-1, count spanning end)\n3. Test error returned for out-of-range address access\n4. Test CSV save and load roundtrip preserves all data\n5. Test concurrent read/write with multiple threads using RwLock\n6. Test memory initialized with correct size from MemoryMapSettings",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Modbus Module Structure and Dependencies",
            "description": "Create the modbus module directory structure under src-tauri/src/modbus/ and add required dependencies (bitvec, parking_lot, thiserror) to Cargo.toml.",
            "dependencies": [],
            "details": "1. Add dependencies to src-tauri/Cargo.toml:\n   - bitvec = \"1\" (for efficient bit vector storage of coils and discrete inputs)\n   - parking_lot = \"0.12\" (for high-performance RwLock)\n   - thiserror = \"1\" (for error type derivation)\n\n2. Create the modbus module directory structure:\n   - src-tauri/src/modbus/mod.rs (module entry point with pub mod declarations)\n   - src-tauri/src/modbus/memory.rs (ModbusMemory struct)\n   - src-tauri/src/modbus/types.rs (shared types including MemoryError)\n\n3. In mod.rs, declare public modules:\n   ```rust\n   pub mod memory;\n   pub mod types;\n   ```\n\n4. Ensure the modbus module is declared in src-tauri/src/lib.rs or main.rs.",
            "status": "done",
            "testStrategy": "Verify Cargo.toml compiles successfully with new dependencies. Verify module structure is correct by running 'cargo check' in src-tauri directory.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:45:30.092Z"
          },
          {
            "id": 2,
            "title": "Define MemoryError Type and Memory Configuration Types",
            "description": "Create the MemoryError enum with thiserror for address out-of-range and count exceeded errors, plus any configuration types needed for memory initialization.",
            "dependencies": [
              1
            ],
            "details": "1. Create src-tauri/src/modbus/types.rs with:\n   ```rust\n   use thiserror::Error;\n\n   #[derive(Error, Debug)]\n   pub enum MemoryError {\n       #[error(\"Address out of range: {address} (valid: {start}-{end})\")]\n       AddressOutOfRange { address: u16, start: u16, end: u16 },\n       #[error(\"Count exceeds available range: requested {count} from {address}, available {available}\")]\n       CountExceedsRange { address: u16, count: u16, available: u16 },\n       #[error(\"Invalid count: {count} (must be > 0)\")]\n       InvalidCount { count: u16 },\n   }\n   ```\n\n2. Define MemoryMapSettings struct (or reference from project config module if already exists from Task 3):\n   ```rust\n   pub struct MemoryMapSettings {\n       pub coil_count: u16,\n       pub discrete_input_count: u16,\n       pub holding_register_count: u16,\n       pub input_register_count: u16,\n   }\n   ```\n\n3. Implement Default trait for MemoryMapSettings with sensible defaults (e.g., 65536 for each).",
            "status": "done",
            "testStrategy": "Unit test that MemoryError can be created and displays correct error messages. Test Default implementation for MemoryMapSettings returns expected values.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:45:30.100Z"
          },
          {
            "id": 3,
            "title": "Implement ModbusMemory Struct with Core Read/Write Methods",
            "description": "Create the ModbusMemory struct with RwLock-protected fields for all four memory types and implement all read/write methods with proper bounds checking.",
            "dependencies": [
              2
            ],
            "details": "1. Create src-tauri/src/modbus/memory.rs with:\n   ```rust\n   use bitvec::prelude::*;\n   use parking_lot::RwLock;\n   use super::types::{MemoryError, MemoryMapSettings};\n\n   pub struct ModbusMemory {\n       coils: RwLock<BitVec<u8, Msb0>>,\n       discrete_inputs: RwLock<BitVec<u8, Msb0>>,\n       holding_registers: RwLock<Vec<u16>>,\n       input_registers: RwLock<Vec<u16>>,\n       config: MemoryMapSettings,\n   }\n   ```\n\n2. Implement constructor:\n   - pub fn new(config: &MemoryMapSettings) -> Self\n   - Initialize all vectors/bitvecs to config sizes with zeros\n\n3. Implement Coil methods (Function codes 0x01, 0x05, 0x0F):\n   - pub fn read_coils(&self, start: u16, count: u16) -> Result<Vec<bool>, MemoryError>\n   - pub fn write_coil(&self, address: u16, value: bool) -> Result<(), MemoryError>\n   - pub fn write_coils(&self, start: u16, values: &[bool]) -> Result<(), MemoryError>\n\n4. Implement Discrete Input methods (Function code 0x02):\n   - pub fn read_discrete_inputs(&self, start: u16, count: u16) -> Result<Vec<bool>, MemoryError>\n   - pub fn write_discrete_input(&self, address: u16, value: bool) -> Result<(), MemoryError> // Internal use\n\n5. Implement Holding Register methods (Function codes 0x03, 0x06, 0x10):\n   - pub fn read_holding_registers(&self, start: u16, count: u16) -> Result<Vec<u16>, MemoryError>\n   - pub fn write_holding_register(&self, address: u16, value: u16) -> Result<(), MemoryError>\n   - pub fn write_holding_registers(&self, start: u16, values: &[u16]) -> Result<(), MemoryError>\n\n6. Implement Input Register methods (Function code 0x04):\n   - pub fn read_input_registers(&self, start: u16, count: u16) -> Result<Vec<u16>, MemoryError>\n   - pub fn write_input_register(&self, address: u16, value: u16) -> Result<(), MemoryError> // Internal use\n\n7. All methods must validate bounds and return appropriate MemoryError variants.",
            "status": "done",
            "testStrategy": "Unit test read/write for each memory type at address 0, middle addresses, and max-1. Test boundary conditions where count spans end of range. Test error returned for out-of-range addresses. Test concurrent read/write with multiple threads using RwLock.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:45:30.106Z"
          },
          {
            "id": 4,
            "title": "Implement CSV Snapshot Save and Load Functionality",
            "description": "Add save_to_csv and load_from_csv methods to ModbusMemory for persisting and restoring memory state with format: address,type,value per line.",
            "dependencies": [
              3
            ],
            "details": "1. Add CSV format handling to memory.rs:\n   - Format: 'address,type,value' per line\n   - Types: 'coil', 'discrete', 'holding', 'input'\n   - Values: 0/1 for bits, 0-65535 for registers\n   - Example lines:\n     - '0,coil,1'\n     - '40001,holding,1234'\n     - '10000,discrete,0'\n     - '30001,input,5678'\n\n2. Implement save_to_csv:\n   ```rust\n   pub fn save_to_csv(&self, path: &Path) -> Result<(), std::io::Error>\n   ```\n   - Acquire read locks on all memory sections\n   - Write header line (optional): 'address,type,value'\n   - Iterate through all non-zero values and write to CSV\n   - Or write all values for complete snapshot (configurable)\n\n3. Implement load_from_csv:\n   ```rust\n   pub fn load_from_csv(&self, path: &Path) -> Result<(), std::io::Error>\n   ```\n   - Parse CSV file line by line\n   - Validate address ranges before writing\n   - Clear existing memory or merge (configurable)\n   - Handle parsing errors gracefully\n\n4. Add helper method for address-to-type mapping if using Modbus addressing convention:\n   - 0x0000-0xFFFF: Coils\n   - 1x0000-1xFFFF: Discrete Inputs\n   - 3x0000-3xFFFF: Input Registers\n   - 4x0000-4xFFFF: Holding Registers",
            "status": "done",
            "testStrategy": "Test CSV save creates valid file with correct format. Test CSV load restores all data correctly. Test save/load roundtrip preserves all data types and values. Test load handles missing file gracefully. Test load validates address ranges and rejects invalid entries.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:45:30.112Z"
          },
          {
            "id": 5,
            "title": "Add Unit Tests for ModbusMemory Module",
            "description": "Create comprehensive unit tests covering all ModbusMemory functionality including concurrent access, boundary conditions, error cases, and CSV operations.",
            "dependencies": [
              4
            ],
            "details": "1. Create test module in memory.rs or separate test file:\n   ```rust\n   #[cfg(test)]\n   mod tests {\n       use super::*;\n       use std::sync::Arc;\n       use std::thread;\n   }\n   ```\n\n2. Test memory initialization:\n   - Test new() creates memory with correct sizes from config\n   - Test all values initialized to zero\n\n3. Test read operations:\n   - Read single value at start, middle, end of range\n   - Read multiple values\n   - Read entire range\n\n4. Test write operations:\n   - Write single value\n   - Write multiple values\n   - Write at boundary addresses\n\n5. Test error conditions:\n   - Address out of range (> max)\n   - Count exceeds available range\n   - Zero count handling\n\n6. Test concurrent access:\n   - Multiple readers simultaneously\n   - Reader and writer simultaneously\n   - Multiple writers (sequential due to exclusive lock)\n   - Use Arc<ModbusMemory> with thread::spawn\n\n7. Test CSV operations:\n   - Save to temporary file\n   - Load from saved file\n   - Roundtrip preserves all values\n   - Handle malformed CSV gracefully\n\n8. Test with MemoryMapSettings variations:\n   - Default settings\n   - Minimum sizes (1 element each)\n   - Maximum practical sizes",
            "status": "done",
            "testStrategy": "Run 'cargo test' in src-tauri directory. All tests should pass. Test coverage should include all public methods, error paths, and concurrent access patterns. Consider using proptest or quickcheck for property-based testing of boundary conditions.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:45:30.117Z"
          }
        ],
        "updatedAt": "2026-01-27T00:45:30.117Z"
      },
      {
        "id": "21",
        "title": "Implement Modbus TCP Server",
        "description": "Create Modbus TCP server using tokio-modbus handling standard Function Codes (0x01-0x06, 0x0F, 0x10) with connection tracking and graceful shutdown.",
        "details": "1. Add tokio-modbus dependency to `src-tauri/Cargo.toml`:\n   ```toml\n   tokio-modbus = \"0.9\"\n   ```\n\n2. Create `src-tauri/src/modbus/tcp.rs`:\n   ```rust\n   use tokio_modbus::server::tcp::Server;\n   use std::sync::Arc;\n   use parking_lot::RwLock;\n   use tokio::sync::oneshot;\n\n   pub struct ModbusTcpServer {\n       config: TcpConfig,\n       memory: Arc<ModbusMemory>,\n       server_handle: Option<tokio::task::JoinHandle<()>>,\n       shutdown_tx: Option<oneshot::Sender<()>>,\n       connections: Arc<RwLock<Vec<ConnectionInfo>>>,\n   }\n\n   pub struct ConnectionInfo {\n       pub address: std::net::SocketAddr,\n       pub connected_at: chrono::DateTime<chrono::Utc>,\n   }\n   ```\n\n3. Implement ModbusTcpServer methods:\n   ```rust\n   impl ModbusTcpServer {\n     pub fn new(config: TcpConfig, memory: Arc<ModbusMemory>) -> Self;\n     pub async fn start(&mut self) -> Result<(), ModbusError>;\n     pub async fn stop(&mut self) -> Result<(), ModbusError>;\n     pub fn is_running(&self) -> bool;\n     pub fn get_connection_count(&self) -> usize;\n     pub fn get_connections(&self) -> Vec<ConnectionInfo>;\n   }\n   ```\n\n4. Implement Modbus service handler:\n   ```rust\n   struct ModbusService {\n       memory: Arc<ModbusMemory>,\n       connections: Arc<RwLock<Vec<ConnectionInfo>>>,\n       app_handle: tauri::AppHandle,\n   }\n\n   impl tokio_modbus::server::Service for ModbusService {\n     type Request = Request;\n     type Response = Response;\n     type Error = std::io::Error;\n     type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send>>;\n\n     fn call(&self, req: Self::Request) -> Self::Future {\n       // Handle function codes:\n       // 0x01: Read Coils -> memory.read_coils()\n       // 0x02: Read Discrete Inputs -> memory.read_discrete_inputs()\n       // 0x03: Read Holding Registers -> memory.read_holding_registers()\n       // 0x04: Read Input Registers -> memory.read_input_registers()\n       // 0x05: Write Single Coil -> memory.write_coil()\n       // 0x06: Write Single Register -> memory.write_holding_register()\n       // 0x0F: Write Multiple Coils -> memory.write_coils()\n       // 0x10: Write Multiple Registers -> memory.write_holding_registers()\n     }\n   }\n   ```\n\n5. Add connection tracking:\n   - Track connected clients in connections Vec\n   - Emit 'modbus:connection' event on connect/disconnect via app_handle\n   - Update connection list on new connection and cleanup\n\n6. Implement graceful shutdown:\n   - shutdown_tx sends signal to stop accepting\n   - Wait for active requests to complete (timeout 5s)\n   - Clean up all resources",
        "testStrategy": "1. Test server starts and binds to configured port (verify with netstat)\n2. Test server stops and releases port (rebind possible)\n3. Test each function code with external client (pymodbus, ModbusPoll)\n4. Test concurrent client connections up to limit\n5. Test connection events emitted on connect/disconnect\n6. Test graceful shutdown completes pending requests",
        "priority": "high",
        "dependencies": [
          "20"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add tokio-modbus Dependency and Create TCP Module Structure",
            "description": "Add tokio-modbus = \"0.9\" dependency to src-tauri/Cargo.toml and create the tcp.rs file in src-tauri/src/modbus/ directory with basic imports and module structure.",
            "dependencies": [],
            "details": "Add tokio-modbus = \"0.9\" to the [dependencies] section in src-tauri/Cargo.toml. Create src-tauri/src/modbus/tcp.rs with necessary imports: tokio_modbus::server::tcp::Server, std::sync::Arc, parking_lot::RwLock, tokio::sync::oneshot, std::net::SocketAddr. Also add chrono = \"0.4\" dependency if not present for timestamp tracking. Export the tcp module from src-tauri/src/modbus/mod.rs. Run 'cargo check' to verify dependencies resolve correctly.",
            "status": "done",
            "testStrategy": "Run 'cargo check' in src-tauri directory to verify tokio-modbus compiles and all imports resolve. Verify module is properly exported in mod.rs.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:12:56.926Z"
          },
          {
            "id": 2,
            "title": "Define TcpConfig and ConnectionInfo Types",
            "description": "Create the TcpConfig struct for TCP server configuration and ConnectionInfo struct for tracking connected clients with their metadata.",
            "dependencies": [
              1
            ],
            "details": "In src-tauri/src/modbus/types.rs or tcp.rs, define: TcpConfig struct with fields: bind_address (String), port (u16), unit_id (u8), max_connections (usize), timeout_ms (u64). Add Default implementation with bind_address=\"0.0.0.0\", port=502, unit_id=1, max_connections=10, timeout_ms=3000. Define ConnectionInfo struct with address (std::net::SocketAddr) and connected_at (chrono::DateTime<chrono::Utc>) fields. Derive Serialize, Deserialize, Clone, Debug for both structs.",
            "status": "done",
            "testStrategy": "Unit test TcpConfig::default() returns expected values. Test ConnectionInfo can be created with SocketAddr and current timestamp. Verify serialization roundtrip works correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:12:56.933Z"
          },
          {
            "id": 3,
            "title": "Implement ModbusTcpServer Struct with Core Methods",
            "description": "Create the ModbusTcpServer struct with config, memory reference, server handle, shutdown channel, and connections tracking, plus implement constructor and lifecycle methods.",
            "dependencies": [
              2
            ],
            "details": "Define ModbusTcpServer struct with fields: config (TcpConfig), memory (Arc<ModbusMemory>), server_handle (Option<tokio::task::JoinHandle<()>>), shutdown_tx (Option<oneshot::Sender<()>>), connections (Arc<RwLock<Vec<ConnectionInfo>>>), running (Arc<std::sync::atomic::AtomicBool>). Implement: new(config: TcpConfig, memory: Arc<ModbusMemory>) -> Self constructor. Implement is_running(&self) -> bool using AtomicBool. Implement get_connection_count(&self) -> usize and get_connections(&self) -> Vec<ConnectionInfo> using the connections RwLock.",
            "status": "done",
            "testStrategy": "Unit test new() creates server in non-running state. Test is_running() returns false initially. Test get_connection_count() returns 0 on fresh server. Test get_connections() returns empty Vec initially.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:12:56.939Z"
          },
          {
            "id": 4,
            "title": "Implement ModbusService Handler with Function Code Processing",
            "description": "Create the ModbusService struct implementing tokio_modbus::server::Service trait to handle all Modbus function codes (0x01-0x06, 0x0F, 0x10) by delegating to ModbusMemory.",
            "dependencies": [
              3
            ],
            "details": "Create ModbusService struct with memory (Arc<ModbusMemory>), connections (Arc<RwLock<Vec<ConnectionInfo>>>), and optionally app_handle (tauri::AppHandle) for events. Implement tokio_modbus::server::Service trait with Request, Response, Error, and Future associated types. In the call() method, match on Request variants: ReadCoils -> memory.read_coils(), ReadDiscreteInputs -> memory.read_discrete_inputs(), ReadHoldingRegisters -> memory.read_holding_registers(), ReadInputRegisters -> memory.read_input_registers(), WriteSingleCoil -> memory.write_coil(), WriteSingleRegister -> memory.write_holding_register(), WriteMultipleCoils -> memory.write_coils(), WriteMultipleRegisters -> memory.write_holding_registers(). Return appropriate Response variants or error responses for invalid operations.",
            "status": "done",
            "testStrategy": "Unit test each function code handler with mock ModbusMemory. Test ReadCoils returns correct bit values. Test WriteMultipleRegisters writes and returns correct response. Test invalid address ranges return exception responses.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:12:56.946Z"
          },
          {
            "id": 5,
            "title": "Implement Server Start/Stop with Connection Tracking and Graceful Shutdown",
            "description": "Implement the start() and stop() async methods for ModbusTcpServer with proper TCP listener setup, connection accept loop, connection tracking with events, and graceful shutdown with timeout.",
            "dependencies": [
              4
            ],
            "details": "Implement async start(&mut self) -> Result<(), ModbusError>: bind TCP listener to config.bind_address:config.port, create shutdown oneshot channel, spawn async task for accept loop that processes connections using ModbusService, track new connections in connections Vec with ConnectionInfo, update running AtomicBool to true. Implement async stop(&mut self) -> Result<(), ModbusError>: send shutdown signal via shutdown_tx, wait for server_handle with tokio::time::timeout(Duration::from_secs(5)), clean up connections list, update running to false. Add connection tracking: when client connects, push ConnectionInfo to connections and emit 'modbus:connection' event with event_type='connected'. On disconnect, remove from Vec and emit event_type='disconnected'. Ensure all resources are cleaned up even on error paths.",
            "status": "done",
            "testStrategy": "Test server starts and binds to configured port (verify with netstat or TcpStream::connect). Test server stops and releases port (rebind immediately succeeds). Test connection events emit on connect/disconnect using mock app_handle. Test graceful shutdown waits for pending requests (up to 5s timeout). Test concurrent connection limit is enforced.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:12:56.954Z"
          }
        ],
        "updatedAt": "2026-01-27T03:12:56.954Z"
      },
      {
        "id": "22",
        "title": "Implement Modbus RTU Server",
        "description": "Create Modbus RTU server for serial communication using tokio-serial with port enumeration, configurable parameters, and proper RTU framing with CRC validation.",
        "details": "1. Add dependencies to `src-tauri/Cargo.toml`:\n   ```toml\n   tokio-serial = \"5\"\n   serialport = \"4\"  # For port enumeration\n   ```\n\n2. Create `src-tauri/src/modbus/rtu.rs`:\n   ```rust\n   use tokio_serial::{SerialPortBuilderExt, SerialStream};\n\n   pub struct ModbusRtuServer {\n       config: RtuConfig,\n       memory: Arc<ModbusMemory>,\n       port: Option<SerialStream>,\n       running: Arc<AtomicBool>,\n       task_handle: Option<tokio::task::JoinHandle<()>>,\n   }\n\n   pub struct RtuConfig {\n       pub com_port: String,\n       pub baud_rate: u32,\n       pub parity: Parity,\n       pub stop_bits: StopBits,\n       pub data_bits: DataBits,\n       pub unit_id: u8,\n   }\n   ```\n\n3. Implement port enumeration:\n   ```rust\n   pub fn list_available_ports() -> Result<Vec<PortInfo>, std::io::Error> {\n     let ports = serialport::available_ports()?;\n     Ok(ports.into_iter().map(|p| PortInfo {\n       name: p.port_name,\n       port_type: match p.port_type {\n         SerialPortType::UsbPort(_) => \"USB\",\n         SerialPortType::BluetoothPort => \"Bluetooth\",\n         _ => \"Unknown\"\n       }.to_string(),\n       description: /* extract from port_type */,\n     }).collect())\n   }\n   ```\n\n4. Implement ModbusRtuServer methods:\n   ```rust\n   impl ModbusRtuServer {\n     pub fn new(config: RtuConfig, memory: Arc<ModbusMemory>) -> Self;\n     pub async fn start(&mut self) -> Result<(), ModbusError>;\n     pub async fn stop(&mut self) -> Result<(), ModbusError>;\n     pub fn is_running(&self) -> bool;\n   }\n   ```\n\n5. Implement RTU frame handling:\n   ```rust\n   async fn rtu_loop(port: &mut SerialStream, memory: Arc<ModbusMemory>, running: Arc<AtomicBool>) {\n     let mut buffer = [0u8; 256];\n     loop {\n       // Read frame with proper timing (3.5 character silence detection)\n       // Parse RTU frame: [Unit ID (1)] [Function Code (1)] [Data (N)] [CRC (2)]\n       // Validate CRC-16 (Modbus polynomial)\n       // Extract request, process with same logic as TCP\n       // Build response frame with CRC\n       // Write response to serial port\n     }\n   }\n   ```\n\n6. CRC-16 implementation:\n   ```rust\n   fn calculate_crc(data: &[u8]) -> u16 {\n     // Modbus CRC-16 polynomial: 0xA001\n     let mut crc: u16 = 0xFFFF;\n     for byte in data {\n       crc ^= *byte as u16;\n       for _ in 0..8 {\n         if crc & 0x0001 != 0 {\n           crc = (crc >> 1) ^ 0xA001;\n         } else {\n           crc >>= 1;\n         }\n       }\n     }\n     crc\n   }\n   ```\n\n7. Configure serial parameters in open:\n   - Baud rate: 9600, 19200, 38400, 57600, 115200\n   - Data bits: 7, 8\n   - Parity: None, Odd, Even\n   - Stop bits: 1, 2\n\n8. Handle serial port errors:\n   - Port disconnection detection\n   - Framing errors recovery\n   - Parity errors logging",
        "testStrategy": "1. Test port enumeration returns available ports with correct info\n2. Test server opens and configures serial port correctly\n3. Test CRC validation rejects bad frames\n4. Test with virtual COM port pair (com0com on Windows)\n5. Test serial parameter combinations (baud, parity, stop bits)\n6. Test error handling on port disconnect during operation",
        "priority": "medium",
        "dependencies": [
          "20",
          "21"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add RTU dependencies and create module structure",
            "description": "Add tokio-serial and serialport dependencies to Cargo.toml and create the rtu.rs module file with basic imports and type definitions.",
            "dependencies": [],
            "details": "Add to src-tauri/Cargo.toml:\n- tokio-serial = \"5\" for async serial communication\n- serialport = \"4\" for port enumeration\n\nCreate src-tauri/src/modbus/rtu.rs with:\n- Imports: tokio_serial::{SerialPortBuilderExt, SerialStream}, serialport, std::sync::Arc, parking_lot::RwLock, std::sync::atomic::{AtomicBool, Ordering}\n- RtuConfig struct with fields: com_port (String), baud_rate (u32), parity (Parity enum), stop_bits (StopBits enum), data_bits (DataBits enum), unit_id (u8)\n- PortInfo struct for enumeration results: name (String), port_type (String), description (Option<String>)\n- ModbusRtuServer struct skeleton with config, memory, port, running, task_handle fields\n- Update mod.rs to include pub mod rtu;",
            "status": "done",
            "testStrategy": "Verify Cargo.toml compiles with new dependencies. Verify rtu.rs module is accessible from parent module. Check all type definitions are properly declared with required derives (Debug, Clone, Serialize where needed).",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:30:33.617Z"
          },
          {
            "id": 2,
            "title": "Implement serial port enumeration function",
            "description": "Create the list_available_ports function that discovers available COM ports with detailed metadata about each port type.",
            "dependencies": [
              1
            ],
            "details": "Implement in src-tauri/src/modbus/rtu.rs:\n\npub fn list_available_ports() -> Result<Vec<PortInfo>, std::io::Error> {\n  let ports = serialport::available_ports()?;\n  Ok(ports.into_iter().map(|p| {\n    let (port_type, description) = match &p.port_type {\n      SerialPortType::UsbPort(info) => (\n        \"USB\".to_string(),\n        Some(format!(\"{} {}\", info.manufacturer.as_deref().unwrap_or(\"\"), info.product.as_deref().unwrap_or(\"\")).trim().to_string())\n      ),\n      SerialPortType::BluetoothPort => (\"Bluetooth\".to_string(), None),\n      SerialPortType::PciPort => (\"PCI\".to_string(), None),\n      SerialPortType::Unknown => (\"Unknown\".to_string(), None),\n    };\n    PortInfo { name: p.port_name, port_type, description }\n  }).collect())\n}\n\nAdd #[derive(Serialize)] to PortInfo for Tauri command exposure.",
            "status": "done",
            "testStrategy": "Unit test that list_available_ports returns Ok on systems with no ports. Manual test on Windows with COM ports to verify USB port info extraction. Test that returned PortInfo contains expected fields.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:30:42.160Z"
          },
          {
            "id": 3,
            "title": "Implement CRC-16 calculation and RTU frame validation",
            "description": "Create CRC-16 Modbus calculation function and frame validation utilities for RTU protocol framing.",
            "dependencies": [
              1
            ],
            "details": "Implement in src-tauri/src/modbus/rtu.rs:\n\nfn calculate_crc(data: &[u8]) -> u16 {\n  let mut crc: u16 = 0xFFFF;\n  for byte in data {\n    crc ^= *byte as u16;\n    for _ in 0..8 {\n      if crc & 0x0001 != 0 {\n        crc = (crc >> 1) ^ 0xA001;\n      } else {\n        crc >>= 1;\n      }\n    }\n  }\n  crc\n}\n\nfn validate_frame(frame: &[u8]) -> bool {\n  if frame.len() < 4 { return false; }  // Min: unit_id + fc + crc(2)\n  let data_len = frame.len() - 2;\n  let received_crc = u16::from_le_bytes([frame[data_len], frame[data_len + 1]]);\n  calculate_crc(&frame[..data_len]) == received_crc\n}\n\nfn build_response_frame(unit_id: u8, response: &[u8]) -> Vec<u8> {\n  let mut frame = Vec::with_capacity(response.len() + 3);\n  frame.push(unit_id);\n  frame.extend_from_slice(response);\n  let crc = calculate_crc(&frame);\n  frame.extend_from_slice(&crc.to_le_bytes());\n  frame\n}",
            "status": "done",
            "testStrategy": "Unit test calculate_crc with known test vectors from Modbus specification. Test validate_frame rejects frames with bad CRC. Test validate_frame rejects frames shorter than 4 bytes. Test build_response_frame produces valid CRC that passes validation.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:30:42.168Z"
          },
          {
            "id": 4,
            "title": "Implement ModbusRtuServer core methods and serial port handling",
            "description": "Implement the ModbusRtuServer struct methods for lifecycle management including new(), start(), stop(), and is_running() with proper serial port configuration.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement in src-tauri/src/modbus/rtu.rs:\n\nimpl ModbusRtuServer {\n  pub fn new(config: RtuConfig, memory: Arc<ModbusMemory>) -> Self {\n    Self { config, memory, port: None, running: Arc::new(AtomicBool::new(false)), task_handle: None }\n  }\n\n  pub async fn start(&mut self) -> Result<(), ModbusError> {\n    if self.running.load(Ordering::SeqCst) { return Err(ModbusError::AlreadyRunning); }\n    let builder = tokio_serial::new(&self.config.com_port, self.config.baud_rate)\n      .parity(self.config.parity)\n      .stop_bits(self.config.stop_bits)\n      .data_bits(self.config.data_bits);\n    let port = builder.open_native_async()?;\n    self.port = Some(port);\n    self.running.store(true, Ordering::SeqCst);\n    // Spawn RTU loop task (implemented in subtask 5)\n    Ok(())\n  }\n\n  pub async fn stop(&mut self) -> Result<(), ModbusError> {\n    self.running.store(false, Ordering::SeqCst);\n    if let Some(handle) = self.task_handle.take() { handle.abort(); }\n    self.port = None;\n    Ok(())\n  }\n\n  pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }\n}",
            "status": "done",
            "testStrategy": "Test new() creates server in stopped state. Test start() on invalid port returns appropriate error. Test start() when already running returns AlreadyRunning error. Test stop() sets running to false. Test is_running() reflects actual state. Integration test with virtual COM port pair (com0com on Windows).",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:30:42.173Z"
          },
          {
            "id": 5,
            "title": "Implement RTU communication loop with frame handling and error recovery",
            "description": "Create the async RTU loop that reads frames from serial port, validates them, processes requests through shared ModbusMemory, and sends responses with proper inter-frame timing.",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement in src-tauri/src/modbus/rtu.rs:\n\nasync fn rtu_loop(mut port: SerialStream, memory: Arc<ModbusMemory>, running: Arc<AtomicBool>, unit_id: u8) {\n  let mut buffer = [0u8; 256];\n  let mut frame_buffer = Vec::with_capacity(256);\n  let char_time_us = 11_000_000 / 9600; // Adjust based on baud rate\n  let t35_timeout = Duration::from_micros((char_time_us * 35).max(1750)); // 3.5 char or 1.75ms min\n\n  while running.load(Ordering::SeqCst) {\n    match timeout(t35_timeout, port.read(&mut buffer)).await {\n      Ok(Ok(n)) if n > 0 => frame_buffer.extend_from_slice(&buffer[..n]),\n      Ok(Ok(_)) | Err(_) => {\n        // Frame complete (timeout) - process if we have data\n        if frame_buffer.len() >= 4 && validate_frame(&frame_buffer) {\n          if frame_buffer[0] == unit_id {\n            let response = process_request(&frame_buffer[1..frame_buffer.len()-2], &memory);\n            let response_frame = build_response_frame(unit_id, &response);\n            let _ = port.write_all(&response_frame).await;\n          }\n        }\n        frame_buffer.clear();\n      }\n      Ok(Err(e)) => {\n        log::error!(\"Serial read error: {}\", e);\n        frame_buffer.clear();\n        // Consider reconnection logic for persistent errors\n      }\n    }\n  }\n}\n\nIntegrate with start() method to spawn this loop as a tokio task.",
            "status": "done",
            "testStrategy": "Test with virtual COM port pair sending valid Modbus RTU frames. Test frame reassembly across multiple reads. Test 3.5 character timeout triggers frame processing. Test invalid CRC frames are silently discarded. Test frames addressed to wrong unit_id are ignored. Test serial error recovery does not crash the loop.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:30:42.179Z"
          }
        ],
        "updatedAt": "2026-01-27T10:30:42.179Z"
      },
      {
        "id": "23",
        "title": "Create Modbus Tauri Commands",
        "description": "Implement Tauri command handlers for Modbus server control (start/stop TCP/RTU) and memory access (read/write coils and registers) with proper state management.",
        "details": "1. Create `src-tauri/src/commands/modbus.rs`:\n\n2. Define ModbusState for Tauri managed state:\n   ```rust\n   pub struct ModbusState {\n       pub memory: Arc<ModbusMemory>,\n       pub tcp_server: Mutex<Option<ModbusTcpServer>>,\n       pub rtu_server: Mutex<Option<ModbusRtuServer>>,\n   }\n   ```\n\n3. Implement server control commands:\n   ```rust\n   #[tauri::command]\n   pub async fn modbus_start_tcp(\n       state: State<'_, ModbusState>,\n       port: u16\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn modbus_stop_tcp(\n       state: State<'_, ModbusState>\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn modbus_start_rtu(\n       state: State<'_, ModbusState>,\n       config: RtuConfig\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn modbus_stop_rtu(\n       state: State<'_, ModbusState>\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn modbus_get_status(\n       state: State<'_, ModbusState>\n   ) -> Result<ModbusStatus, String>;\n\n   #[tauri::command]\n   pub async fn modbus_list_serial_ports() -> Result<Vec<PortInfo>, String>;\n   ```\n\n4. Implement memory access commands:\n   ```rust\n   #[tauri::command]\n   pub async fn modbus_read_coils(\n       state: State<'_, ModbusState>,\n       start: u16,\n       count: u16\n   ) -> Result<Vec<bool>, String>;\n\n   #[tauri::command]\n   pub async fn modbus_write_coil(\n       state: State<'_, ModbusState>,\n       address: u16,\n       value: bool\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn modbus_read_registers(\n       state: State<'_, ModbusState>,\n       register_type: String, // \"holding\" | \"input\"\n       start: u16,\n       count: u16\n   ) -> Result<Vec<u16>, String>;\n\n   #[tauri::command]\n   pub async fn modbus_write_register(\n       state: State<'_, ModbusState>,\n       address: u16,\n       value: u16\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn modbus_bulk_write(\n       state: State<'_, ModbusState>,\n       operations: Vec<WriteOperation>\n   ) -> Result<(), String>;\n   ```\n\n5. Define supporting types:\n   ```rust\n   #[derive(Serialize)]\n   pub struct ModbusStatus {\n       tcp_running: bool,\n       tcp_port: Option<u16>,\n       tcp_connections: usize,\n       rtu_running: bool,\n       rtu_port: Option<String>,\n   }\n\n   #[derive(Deserialize)]\n   pub struct WriteOperation {\n       register_type: String,\n       address: u16,\n       value: u16,\n   }\n   ```\n\n6. Register commands and state in main.rs:\n   ```rust\n   .manage(ModbusState {\n       memory: Arc::new(ModbusMemory::new(&MemoryMapSettings::default())),\n       tcp_server: Mutex::new(None),\n       rtu_server: Mutex::new(None),\n   })\n   .invoke_handler(tauri::generate_handler![\n       modbus_start_tcp, modbus_stop_tcp,\n       modbus_start_rtu, modbus_stop_rtu,\n       modbus_get_status, modbus_list_serial_ports,\n       modbus_read_coils, modbus_write_coil,\n       modbus_read_registers, modbus_write_register,\n       modbus_bulk_write,\n   ])\n   ```",
        "testStrategy": "1. Test each command returns correct data type\n2. Test error handling for invalid parameters (negative address, etc.)\n3. Test commands work both when server running and stopped\n4. Test memory read returns values written by memory write\n5. Test bulk_write applies all operations atomically\n6. Integration test commands from frontend via invoke",
        "priority": "high",
        "dependencies": [
          "21",
          "22"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create modbus.rs Command Module Structure with ModbusState Definition",
            "description": "Set up the Tauri commands module for Modbus by creating src-tauri/src/commands/modbus.rs with the ModbusState managed state struct and necessary imports.",
            "dependencies": [],
            "details": "Create src-tauri/src/commands/modbus.rs file with all required imports: std::sync::Arc, tauri::State, tokio::sync::Mutex (or parking_lot::Mutex), serde::{Serialize, Deserialize}. Define the ModbusState struct containing: memory: Arc<ModbusMemory>, tcp_server: Mutex<Option<ModbusTcpServer>>, rtu_server: Mutex<Option<ModbusRtuServer>>. Add the modbus module to src-tauri/src/commands/mod.rs with 'pub mod modbus;' and re-export public items. Ensure ModbusState derives or implements Default if needed for Tauri managed state initialization. This struct will be the central state container that all Modbus Tauri commands access.",
            "status": "done",
            "testStrategy": "Run 'cargo check' in src-tauri directory to verify the module compiles. Verify ModbusState can be instantiated with default values. Check that the modbus module is properly exported from commands/mod.rs.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:33:18.449Z"
          },
          {
            "id": 2,
            "title": "Implement TCP Server Control Commands (start/stop)",
            "description": "Create the modbus_start_tcp and modbus_stop_tcp Tauri command handlers for controlling the TCP server lifecycle with proper async handling.",
            "dependencies": [
              1
            ],
            "details": "Implement #[tauri::command] pub async fn modbus_start_tcp(state: State<'_, ModbusState>, port: u16) -> Result<(), String> that: acquires lock on tcp_server mutex, checks if server already running (return error if so), creates new ModbusTcpServer with shared memory Arc, calls server.start().await, stores server in Option. Implement #[tauri::command] pub async fn modbus_stop_tcp(state: State<'_, ModbusState>) -> Result<(), String> that: acquires lock, extracts server from Option with take(), calls server.stop().await if Some, returns Ok. Use map_err(|e| e.to_string()) to convert errors for Tauri. Handle edge cases: starting when already started, stopping when not running.",
            "status": "done",
            "testStrategy": "Test start_tcp succeeds and sets tcp_server to Some. Test start_tcp returns error when already running. Test stop_tcp succeeds when running. Test stop_tcp returns Ok (no-op) when not running. Integration test with actual TCP binding on available port.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:33:18.456Z"
          },
          {
            "id": 3,
            "title": "Implement RTU Server Control Commands and Serial Port Listing",
            "description": "Create modbus_start_rtu, modbus_stop_rtu, and modbus_list_serial_ports Tauri commands for RTU server control and COM port enumeration.",
            "dependencies": [
              1
            ],
            "details": "Define RtuConfig struct (derive Deserialize) with fields: port_name: String, baud_rate: u32, data_bits: u8, parity: String, stop_bits: u8, unit_id: u8, timeout_ms: u64. Implement #[tauri::command] pub async fn modbus_start_rtu(state: State<'_, ModbusState>, config: RtuConfig) -> Result<(), String> with same pattern as TCP. Implement #[tauri::command] pub async fn modbus_stop_rtu(state: State<'_, ModbusState>) -> Result<(), String>. Define PortInfo struct (derive Serialize) with fields: name: String, port_type: String (USB, PCI, etc.), manufacturer: Option<String>, product: Option<String>. Implement #[tauri::command] pub async fn modbus_list_serial_ports() -> Result<Vec<PortInfo>, String> using serialport::available_ports() to enumerate COM ports.",
            "status": "done",
            "testStrategy": "Test list_serial_ports returns Ok even with no ports. Test start_rtu with valid config succeeds on systems with serial ports. Test stop_rtu when running. Mock serial port for unit testing. Manual test on Windows with USB-to-Serial adapter.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:33:18.462Z"
          },
          {
            "id": 4,
            "title": "Implement Memory Access Commands (read/write coils and registers)",
            "description": "Create Tauri commands for reading and writing Modbus memory including coils and holding/input registers with proper parameter validation.",
            "dependencies": [
              1
            ],
            "details": "Implement #[tauri::command] pub async fn modbus_read_coils(state: State<'_, ModbusState>, start: u16, count: u16) -> Result<Vec<bool>, String> that calls memory.read_coils(). Implement #[tauri::command] pub async fn modbus_write_coil(state: State<'_, ModbusState>, address: u16, value: bool) -> Result<(), String>. Implement #[tauri::command] pub async fn modbus_read_registers(state: State<'_, ModbusState>, register_type: String, start: u16, count: u16) -> Result<Vec<u16>, String> where register_type is 'holding' or 'input' - match on string to call appropriate memory method. Implement #[tauri::command] pub async fn modbus_write_register(state: State<'_, ModbusState>, address: u16, value: u16) -> Result<(), String> for holding registers only (input registers are read-only). Add validation for count > 0 and address + count <= max_address.",
            "status": "done",
            "testStrategy": "Test read_coils returns correct bool array. Test write_coil updates memory. Test read_registers with both 'holding' and 'input' types. Test write_register updates holding register. Test error on invalid register_type. Test boundary conditions (address 0, address 65535, count spanning end).",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:33:18.467Z"
          },
          {
            "id": 5,
            "title": "Implement Status Query and Bulk Write Commands with main.rs Registration",
            "description": "Create modbus_get_status and modbus_bulk_write commands, define supporting types, and register all commands and state in main.rs.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Define ModbusStatus struct (derive Serialize) with fields: tcp_running: bool, tcp_port: Option<u16>, tcp_connections: usize, rtu_running: bool, rtu_port: Option<String>. Implement #[tauri::command] pub async fn modbus_get_status(state: State<'_, ModbusState>) -> Result<ModbusStatus, String> that queries both servers for status. Define WriteOperation struct (derive Deserialize) with fields: register_type: String, address: u16, value: u16. Implement #[tauri::command] pub async fn modbus_bulk_write(state: State<'_, ModbusState>, operations: Vec<WriteOperation>) -> Result<(), String> that applies all write operations, supporting both coils (value != 0 = true) and holding registers. In main.rs: add .manage(ModbusState { memory: Arc::new(ModbusMemory::new(&MemoryMapSettings::default())), tcp_server: Mutex::new(None), rtu_server: Mutex::new(None) }) and register all 11 commands with tauri::generate_handler![].",
            "status": "done",
            "testStrategy": "Test get_status returns correct running states. Test bulk_write applies all operations. Test bulk_write with mixed coil and register operations. Test bulk_write rolls back or errors appropriately on failure. Verify all commands registered in main.rs by running app and calling from frontend. Integration test complete workflow: start server, write memory, read back, stop server.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:33:18.473Z"
          }
        ],
        "updatedAt": "2026-01-27T10:33:18.473Z"
      },
      {
        "id": "24",
        "title": "Implement Modbus Event System",
        "description": "Create event emission system for memory changes and connection status using Tauri events, with support for change batching and address range subscriptions.",
        "details": "1. Define event types in `src-tauri/src/modbus/types.rs`:\n   ```rust\n   #[derive(Serialize, Clone)]\n   pub struct MemoryChangeEvent {\n       pub register_type: String, // \"coil\" | \"discrete\" | \"holding\" | \"input\"\n       pub address: u16,\n       pub old_value: serde_json::Value, // bool or u16\n       pub new_value: serde_json::Value,\n       pub source: String, // \"internal\" | \"external\" | \"simulation\"\n   }\n\n   #[derive(Serialize, Clone)]\n   pub struct ConnectionEvent {\n       pub event_type: String, // \"connected\" | \"disconnected\"\n       pub protocol: String, // \"tcp\" | \"rtu\"\n       pub client_addr: String,\n       pub timestamp: String, // ISO8601\n   }\n\n   #[derive(Serialize, Clone)]\n   pub struct MemoryBatchChangeEvent {\n       pub changes: Vec<MemoryChangeEvent>,\n   }\n   ```\n\n2. Add event emission to ModbusMemory:\n   ```rust\n   pub struct ModbusMemory {\n       // ... existing fields\n       app_handle: Option<tauri::AppHandle>,\n       change_buffer: RwLock<Vec<MemoryChangeEvent>>,\n       buffer_timeout: Duration, // default 50ms\n   }\n\n   impl ModbusMemory {\n     pub fn set_app_handle(&mut self, handle: tauri::AppHandle);\n\n     fn emit_change(&self, change: MemoryChangeEvent) {\n       // Add to buffer, flush if timeout elapsed\n       // Or emit immediately for single changes\n     }\n\n     fn flush_changes(&self) {\n       // Emit batched event: \"modbus:memory-batch-changed\"\n     }\n   }\n   ```\n\n3. Update write methods to emit events:\n   ```rust\n   pub fn write_coil(&self, address: u16, value: bool) -> Result<(), MemoryError> {\n     let old_value = self.read_coils(address, 1)?[0];\n     // ... actual write\n     self.emit_change(MemoryChangeEvent {\n       register_type: \"coil\".into(),\n       address,\n       old_value: json!(old_value),\n       new_value: json!(value),\n       source: \"internal\".into(),\n     });\n     Ok(())\n   }\n   ```\n\n4. Add connection events to servers:\n   - In TCP server on_connect callback: emit \"modbus:connection\" event\n   - In TCP server on_disconnect callback: emit \"modbus:connection\" event\n   - Include client address in event payload\n\n5. Implement event batching for bulk operations:\n   ```rust\n   pub fn write_coils(&self, start: u16, values: &[bool]) -> Result<(), MemoryError> {\n     // Start batch mode\n     self.start_batch();\n     for (i, value) in values.iter().enumerate() {\n       // ... write with emit_change (buffered)\n     }\n     // End batch, emit single batched event\n     self.end_batch();\n   }\n   ```\n\n6. Create subscription management (optional, for performance):\n   ```rust\n   pub struct MemorySubscription {\n       id: String,\n       register_type: String,\n       start: u16,\n       count: u16,\n   }\n\n   // Only emit events for subscribed ranges\n   fn should_emit(&self, change: &MemoryChangeEvent) -> bool;\n   ```\n\n7. Frontend event listening setup documentation:\n   ```typescript\n   import { listen } from '@tauri-apps/api/event';\n\n   listen('modbus:memory-changed', (event) => {\n     const change = event.payload as MemoryChangeEvent;\n     // Update UI\n   });\n\n   listen('modbus:memory-batch-changed', (event) => {\n     const batch = event.payload as MemoryBatchChangeEvent;\n     // Batch update UI\n   });\n\n   listen('modbus:connection', (event) => {\n     const conn = event.payload as ConnectionEvent;\n     // Update connection status\n   });\n   ```",
        "testStrategy": "1. Test single memory write emits single change event\n2. Test event contains correct old_value and new_value\n3. Test bulk write emits batched event with all changes\n4. Test connection events fire on client connect/disconnect\n5. Test event batching reduces event count for bulk operations\n6. Frontend integration test receives events correctly",
        "priority": "medium",
        "dependencies": [
          "23"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Event Type Structs in types.rs",
            "description": "Create MemoryChangeEvent, ConnectionEvent, and MemoryBatchChangeEvent structs with Serialize and Clone derives for Tauri event emission.",
            "dependencies": [],
            "details": "Add three event structs to `src-tauri/src/modbus/types.rs`:\n\n1. `MemoryChangeEvent` with fields:\n   - `register_type: String` (\"coil\" | \"discrete\" | \"holding\" | \"input\")\n   - `address: u16`\n   - `old_value: serde_json::Value` (to handle both bool and u16)\n   - `new_value: serde_json::Value`\n   - `source: String` (\"internal\" | \"external\" | \"simulation\")\n\n2. `ConnectionEvent` with fields:\n   - `event_type: String` (\"connected\" | \"disconnected\")\n   - `protocol: String` (\"tcp\" | \"rtu\")\n   - `client_addr: String`\n   - `timestamp: String` (ISO8601 format)\n\n3. `MemoryBatchChangeEvent` with fields:\n   - `changes: Vec<MemoryChangeEvent>`\n\nAll structs must derive `Serialize, Clone` and use `#[derive(serde::Serialize, Clone)]`. Add `serde_json` to dependencies in Cargo.toml if not present.",
            "status": "done",
            "testStrategy": "Unit test that each struct can be serialized to JSON correctly. Test MemoryChangeEvent with both bool (coil) and u16 (register) values serialize properly via serde_json::Value. Verify Clone trait works for all structs.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:34:36.862Z"
          },
          {
            "id": 2,
            "title": "Add Event Infrastructure to ModbusMemory",
            "description": "Extend ModbusMemory struct with AppHandle storage, change buffer, and buffer timeout configuration for event batching support.",
            "dependencies": [
              1
            ],
            "details": "Modify `ModbusMemory` struct in `src-tauri/src/modbus/memory.rs` to include:\n\n1. Add fields:\n   - `app_handle: Option<tauri::AppHandle>` - stores Tauri handle for event emission\n   - `change_buffer: RwLock<Vec<MemoryChangeEvent>>` - buffers changes for batching\n   - `buffer_timeout: Duration` - configurable timeout (default 50ms)\n   - `batch_mode: RwLock<bool>` - tracks if in batch operation\n\n2. Add methods:\n   - `pub fn set_app_handle(&mut self, handle: tauri::AppHandle)` - setter for app handle\n   - `fn emit_change(&self, change: MemoryChangeEvent)` - adds to buffer or emits immediately\n   - `fn flush_changes(&self)` - emits batched event \"modbus:memory-batch-changed\"\n   - `pub fn start_batch(&self)` - enables batch mode\n   - `pub fn end_batch(&self)` - disables batch mode and flushes\n\nThe emit_change method should check batch_mode: if true, add to buffer; if false, emit single \"modbus:memory-changed\" event immediately.",
            "status": "done",
            "testStrategy": "Test set_app_handle stores handle correctly. Test emit_change in non-batch mode triggers immediate event (mock app_handle). Test start_batch/end_batch toggle batch_mode correctly. Test flush_changes clears buffer after emitting.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:46:22.908Z"
          },
          {
            "id": 3,
            "title": "Integrate Event Emission into Memory Write Operations",
            "description": "Update all ModbusMemory write methods (write_coil, write_coils, write_register, write_registers) to capture old values and emit change events.",
            "dependencies": [
              2
            ],
            "details": "Modify each write method in ModbusMemory to emit events:\n\n1. `write_coil(address, value)` - Single coil write:\n   - Read old value before write: `let old = self.read_coils(address, 1)?[0];`\n   - Perform actual write\n   - Call `emit_change(MemoryChangeEvent { register_type: \"coil\".into(), address, old_value: json!(old), new_value: json!(value), source: \"internal\".into() })`\n\n2. `write_coils(start, values)` - Bulk coil write:\n   - Call `start_batch()`\n   - For each value, read old, write new, emit_change (buffered)\n   - Call `end_batch()` to flush single batched event\n\n3. `write_register(address, value)` - Single holding register:\n   - Same pattern as write_coil but register_type: \"holding\"\n\n4. `write_registers(start, values)` - Bulk register write:\n   - Same batch pattern as write_coils\n\nNote: Discrete inputs and input registers are typically read-only in Modbus, but if write methods exist, apply same pattern.",
            "status": "done",
            "testStrategy": "Test single write_coil emits one MemoryChangeEvent with correct old/new values. Test write_coils(start, 5 values) emits one MemoryBatchChangeEvent containing 5 changes. Test event contains correct register_type for each memory type. Test source field is \"internal\" for these operations.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:46:23.757Z"
          },
          {
            "id": 4,
            "title": "Implement Connection Events in TCP and RTU Servers",
            "description": "Add connection event emission to ModbusTcpServer and ModbusRtuServer for client connect/disconnect tracking with proper timestamps.",
            "dependencies": [
              1
            ],
            "details": "Modify TCP and RTU server implementations to emit ConnectionEvent:\n\n1. In `ModbusTcpServer` (src-tauri/src/modbus/tcp.rs):\n   - Add `app_handle: Option<tauri::AppHandle>` field\n   - Add `set_app_handle(&mut self, handle)` method\n   - In connection accept loop, on new connection emit:\n     ```rust\n     ConnectionEvent {\n       event_type: \"connected\".into(),\n       protocol: \"tcp\".into(),\n       client_addr: peer_addr.to_string(),\n       timestamp: chrono::Utc::now().to_rfc3339(),\n     }\n     ```\n   - On connection close/drop, emit with event_type: \"disconnected\"\n   - Emit to \"modbus:connection\" event channel\n\n2. In `ModbusRtuServer` (src-tauri/src/modbus/rtu.rs):\n   - Same pattern but protocol: \"rtu\"\n   - client_addr could be the port name or \"serial\" for RTU\n\nAdd `chrono` crate dependency for timestamp formatting if not present.",
            "status": "done",
            "testStrategy": "Test TCP server emits 'connected' event on client connect with correct client_addr. Test 'disconnected' event fires when client drops connection. Test timestamp is valid ISO8601 format. Test RTU server emits connection event with protocol: \"rtu\". Mock app_handle to capture emitted events.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:46:24.600Z"
          },
          {
            "id": 5,
            "title": "Add Subscription Management and Frontend Documentation",
            "description": "Implement optional MemorySubscription system for performance optimization and create TypeScript type definitions with usage documentation for frontend event listeners.",
            "dependencies": [
              3,
              4
            ],
            "details": "1. Create subscription management in `src-tauri/src/modbus/events.rs`:\n   ```rust\n   pub struct MemorySubscription {\n       pub id: String,\n       pub register_type: String,\n       pub start: u16,\n       pub count: u16,\n   }\n   \n   pub struct SubscriptionManager {\n       subscriptions: RwLock<Vec<MemorySubscription>>,\n   }\n   ```\n   - Add `fn should_emit(&self, change: &MemoryChangeEvent) -> bool` that checks if change falls within any subscription range\n   - Integrate into ModbusMemory.emit_change() to filter events\n\n2. Create TypeScript types in `src/types/modbus-events.ts`:\n   ```typescript\n   export interface MemoryChangeEvent {\n     register_type: 'coil' | 'discrete' | 'holding' | 'input';\n     address: number;\n     old_value: boolean | number;\n     new_value: boolean | number;\n     source: 'internal' | 'external' | 'simulation';\n   }\n   // ... ConnectionEvent, MemoryBatchChangeEvent\n   ```\n\n3. Add documentation/example in `src/hooks/useModbusEvents.ts` showing:\n   - How to listen with `listen('modbus:memory-changed', handler)`\n   - How to listen to batch events\n   - How to handle connection events\n   - Cleanup with unlisten on component unmount",
            "status": "done",
            "testStrategy": "Test SubscriptionManager.should_emit returns true for changes within subscribed range. Test returns false for changes outside all subscriptions. Test empty subscriptions list allows all events (no filtering). Frontend: verify TypeScript types compile without errors. Integration test: frontend receives events emitted from Rust backend correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:46:40.784Z"
          }
        ],
        "updatedAt": "2026-01-27T10:46:40.784Z"
      },
      {
        "id": "25",
        "title": "Create Frontend Modbus Integration",
        "description": "Implement TypeScript service layer, Zustand store, and React hooks for Modbus server control and memory monitoring with real-time event updates.",
        "details": "1. Create `src/services/modbusService.ts`:\n   ```typescript\n   import { invoke } from '@tauri-apps/api/core';\n\n   export const modbusService = {\n     // Server control\n     startTcp: (port: number) => invoke('modbus_start_tcp', { port }),\n     stopTcp: () => invoke('modbus_stop_tcp'),\n     startRtu: (config: RtuConfig) => invoke('modbus_start_rtu', { config }),\n     stopRtu: () => invoke('modbus_stop_rtu'),\n     getStatus: () => invoke<ModbusStatus>('modbus_get_status'),\n     listSerialPorts: () => invoke<PortInfo[]>('modbus_list_serial_ports'),\n\n     // Memory access\n     readCoils: (start: number, count: number) =>\n       invoke<boolean[]>('modbus_read_coils', { start, count }),\n     writeCoil: (address: number, value: boolean) =>\n       invoke('modbus_write_coil', { address, value }),\n     readRegisters: (type: RegisterType, start: number, count: number) =>\n       invoke<number[]>('modbus_read_registers', { registerType: type, start, count }),\n     writeRegister: (address: number, value: number) =>\n       invoke('modbus_write_register', { address, value }),\n   };\n   ```\n\n2. Create `src/stores/modbusStore.ts` with Zustand:\n   ```typescript\n   interface ModbusStore {\n     status: ModbusStatus | null;\n     isConnecting: boolean;\n     error: string | null;\n     coilCache: Map<number, boolean>;\n     registerCache: Map<number, number>;\n     connections: ConnectionInfo[];\n\n     fetchStatus: () => Promise<void>;\n     setStatus: (status: ModbusStatus) => void;\n     updateCoilCache: (address: number, value: boolean) => void;\n     updateRegisterCache: (address: number, value: number) => void;\n     setConnections: (conns: ConnectionInfo[]) => void;\n   }\n   ```\n\n3. Create `src/hooks/useModbus.ts`:\n   ```typescript\n   export function useModbus() {\n     const store = useModbusStore();\n\n     const startTcp = async (port: number) => {\n       try {\n         await modbusService.startTcp(port);\n         await store.fetchStatus();\n       } catch (error) {\n         // Handle error, show toast\n       }\n     };\n\n     const stopTcp = async () => { /* similar */ };\n\n     return {\n       status: store.status,\n       startTcp,\n       stopTcp,\n       // ... other operations\n     };\n   }\n   ```\n\n4. Create `src/hooks/useModbusMemory.ts`:\n   ```typescript\n   export function useModbusMemory(\n     type: RegisterType,\n     start: number,\n     count: number\n   ) {\n     const [values, setValues] = useState<number[] | boolean[]>([]);\n\n     useEffect(() => {\n       // Initial load\n       const load = async () => {\n         if (type === 'coil') {\n           setValues(await modbusService.readCoils(start, count));\n         } else {\n           setValues(await modbusService.readRegisters(type, start, count));\n         }\n       };\n       load();\n\n       // Subscribe to changes\n       const unlisten = listen('modbus:memory-changed', (event) => {\n         const change = event.payload as MemoryChangeEvent;\n         if (isInRange(change.address, start, count) && change.registerType === type) {\n           setValues(prev => {\n             const updated = [...prev];\n             updated[change.address - start] = change.newValue;\n             return updated;\n           });\n         }\n       });\n\n       return () => { unlisten.then(fn => fn()); };\n     }, [type, start, count]);\n\n     return values;\n   }\n   ```\n\n5. Create `src/types/modbus.ts`:\n   ```typescript\n   export type RegisterType = 'coil' | 'discrete' | 'holding' | 'input';\n\n   export interface ModbusStatus {\n     tcpRunning: boolean;\n     tcpPort: number | null;\n     tcpConnections: number;\n     rtuRunning: boolean;\n     rtuPort: string | null;\n   }\n\n   export interface RtuConfig {\n     comPort: string;\n     baudRate: number;\n     parity: 'none' | 'odd' | 'even';\n     stopBits: 1 | 2;\n   }\n\n   export interface PortInfo {\n     name: string;\n     portType: string;\n     description: string;\n   }\n\n   export interface MemoryChangeEvent {\n     registerType: RegisterType;\n     address: number;\n     oldValue: boolean | number;\n     newValue: boolean | number;\n     source: string;\n   }\n\n   export interface ConnectionEvent {\n     eventType: 'connected' | 'disconnected';\n     protocol: 'tcp' | 'rtu';\n     clientAddr: string;\n     timestamp: string;\n   }\n   ```\n\n6. Update ModbusPanel in sidebar:\n   - Show TCP/RTU server status (running/stopped with colored indicator)\n   - Start/Stop buttons for each server type\n   - TCP port configuration input\n   - Connection count display\n   - Quick memory overview (total coils, registers with counts)",
        "testStrategy": "1. Mock invoke for unit testing service methods\n2. Test useModbusMemory updates state on memory change events\n3. Test server start/stop functions update status correctly\n4. Test useModbus hook error handling shows toast\n5. Integration test with running Modbus server\n6. E2E test: start server, write value, verify UI updates",
        "priority": "high",
        "dependencies": [
          "24",
          "12"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Modbus TypeScript Type Definitions",
            "description": "Define all TypeScript interfaces and types for Modbus functionality in src/types/modbus.ts including RegisterType, ModbusStatus, RtuConfig, PortInfo, MemoryChangeEvent, ConnectionEvent, and WriteOperation types.",
            "dependencies": [],
            "details": "Create src/types/modbus.ts with the following type definitions:\n\n1. RegisterType union type: 'coil' | 'discrete' | 'holding' | 'input'\n\n2. ModbusStatus interface with nested tcp and rtu objects:\n   - tcp: { running: boolean, port: number | null, connections: number }\n   - rtu: { running: boolean, comPort: string | null, baudRate: number | null }\n\n3. RtuConfig interface:\n   - comPort: string\n   - baudRate: number (9600, 19200, 38400, 57600, 115200)\n   - parity: 'none' | 'odd' | 'even'\n   - stopBits: 1 | 2\n   - dataBits?: 7 | 8\n\n4. PortInfo interface:\n   - name: string\n   - portType: string\n   - description: string\n\n5. MemoryChangeEvent interface:\n   - registerType: RegisterType\n   - address: number\n   - oldValue: boolean | number\n   - newValue: boolean | number\n   - source: 'internal' | 'external' | 'simulation'\n\n6. ConnectionEvent interface:\n   - eventType: 'connected' | 'disconnected'\n   - protocol: 'tcp' | 'rtu'\n   - clientAddr: string\n   - timestamp: string\n\n7. WriteOperation interface:\n   - type: 'coil' | 'holding_register'\n   - address: number\n   - value: number | boolean\n\nExport all types with proper JSDoc comments for IDE support.",
            "status": "done",
            "testStrategy": "Verify all types compile without TypeScript errors. Test that types are correctly exported and can be imported in other modules. Ensure type guards work for discriminated unions (RegisterType). Validate that interfaces match the Rust backend Tauri command signatures from PRD_Unit3_ModServer.md.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:36:10.992Z"
          },
          {
            "id": 2,
            "title": "Implement Modbus Service Layer with Tauri Invoke Wrappers",
            "description": "Create src/services/modbusService.ts that wraps all Tauri invoke commands for Modbus server control (start/stop TCP/RTU) and memory access operations (read/write coils and registers).",
            "dependencies": [
              1
            ],
            "details": "Create src/services/modbusService.ts with the following structure:\n\n1. Import invoke from '@tauri-apps/api/core' and types from '../types/modbus'\n\n2. Export modbusService object with server control methods:\n   - startTcp(port: number): Promise<void> - invoke('modbus_start_tcp', { port })\n   - stopTcp(): Promise<void> - invoke('modbus_stop_tcp')\n   - startRtu(config: RtuConfig): Promise<void> - invoke('modbus_start_rtu', { config })\n   - stopRtu(): Promise<void> - invoke('modbus_stop_rtu')\n   - getStatus(): Promise<ModbusStatus> - invoke('modbus_get_status')\n   - listSerialPorts(): Promise<PortInfo[]> - invoke('modbus_list_serial_ports')\n\n3. Memory access methods:\n   - readCoils(start: number, count: number): Promise<boolean[]> - invoke('modbus_read_coils', { start, count })\n   - writeCoil(address: number, value: boolean): Promise<void> - invoke('modbus_write_coil', { address, value })\n   - readRegisters(type: RegisterType, start: number, count: number): Promise<number[]> - invoke('modbus_read_registers', { registerType: type, start, count })\n   - writeRegister(address: number, value: number): Promise<void> - invoke('modbus_write_register', { address, value })\n   - bulkWrite(operations: WriteOperation[]): Promise<void> - invoke('modbus_bulk_write', { operations })\n\n4. Add proper error typing and async/await patterns for all methods.",
            "status": "done",
            "testStrategy": "Mock @tauri-apps/api/core invoke function using vitest/jest. Test each service method calls invoke with correct command name and parameters. Test error handling by mocking invoke to reject. Verify TypeScript types are correctly applied to return values. Test that RegisterType parameter is properly transformed to registerType in the invoke call.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:36:49.089Z"
          },
          {
            "id": 3,
            "title": "Create Zustand Store for Modbus State Management",
            "description": "Implement src/stores/modbusStore.ts using Zustand to manage Modbus server status, connection state, error handling, and memory caches for coils and registers with appropriate actions.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create src/stores/modbusStore.ts with Zustand:\n\n1. Install zustand if not present: npm install zustand\n\n2. Define ModbusStore interface:\n   - status: ModbusStatus | null\n   - isConnecting: boolean\n   - error: string | null\n   - coilCache: Map<number, boolean>\n   - registerCache: Map<number, number>\n   - connections: ConnectionInfo[] (where ConnectionInfo = { clientAddr: string, connectedAt: string, protocol: 'tcp' | 'rtu' })\n\n3. Implement actions:\n   - fetchStatus: async () => Promise<void> - calls modbusService.getStatus() and updates status\n   - setStatus: (status: ModbusStatus) => void - directly set status (for event updates)\n   - setError: (error: string | null) => void\n   - setConnecting: (connecting: boolean) => void\n   - updateCoilCache: (address: number, value: boolean) => void\n   - updateRegisterCache: (address: number, value: number) => void\n   - clearCache: () => void - resets both caches\n   - addConnection: (conn: ConnectionInfo) => void\n   - removeConnection: (clientAddr: string) => void\n   - setConnections: (conns: ConnectionInfo[]) => void\n\n4. Use immer middleware for immutable updates on Map operations\n\n5. Export useModbusStore hook and selector helpers:\n   - selectStatus, selectIsConnecting, selectError, selectTcpRunning, selectRtuRunning",
            "status": "done",
            "testStrategy": "Test store initializes with correct default values (status: null, isConnecting: false, error: null, empty caches). Test fetchStatus updates status state. Test setStatus directly updates status. Test coilCache and registerCache Map operations (update, clear). Test connection list management (add, remove, set). Test selectors return correct derived state. Test immer integration preserves immutability.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:38:51.303Z"
          },
          {
            "id": 4,
            "title": "Implement useModbus Hook for Server Control Operations",
            "description": "Create src/hooks/useModbus.ts React hook that provides server control functions (start/stop TCP/RTU) with loading states, error handling, toast notifications, and automatic status updates.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create src/hooks/useModbus.ts:\n\n1. Import modbusService, useModbusStore, and toast notification library (e.g., sonner or react-hot-toast)\n\n2. Export useModbus hook that returns:\n   - status: ModbusStatus | null (from store)\n   - isConnecting: boolean (from store)\n   - error: string | null (from store)\n   - tcpRunning: boolean (derived from status)\n   - rtuRunning: boolean (derived from status)\n   - connectionCount: number (derived from status)\n\n3. Implement async action functions with error handling:\n   - startTcp: async (port: number) => Promise<boolean>\n     - Set isConnecting true, clear error\n     - Call modbusService.startTcp(port)\n     - On success: fetchStatus(), show success toast, return true\n     - On error: setError(message), show error toast, return false\n     - Finally: setConnecting(false)\n\n   - stopTcp: async () => Promise<boolean> - similar pattern\n\n   - startRtu: async (config: RtuConfig) => Promise<boolean> - similar pattern\n\n   - stopRtu: async () => Promise<boolean> - similar pattern\n\n   - refreshStatus: async () => Promise<void> - call fetchStatus() with error handling\n\n   - listSerialPorts: async () => Promise<PortInfo[]> - wrapped with error handling\n\n4. Use useCallback for all functions to prevent unnecessary re-renders\n\n5. Optionally add useEffect for initial status fetch on mount",
            "status": "done",
            "testStrategy": "Test startTcp calls service and updates store on success. Test startTcp shows error toast and sets error on failure. Test isConnecting state transitions (true during operation, false after). Test stopTcp/startRtu/stopRtu follow same patterns. Test refreshStatus fetches and updates status. Test listSerialPorts returns port list. Integration test: verify hook works with actual store updates. Test useCallback memoization prevents function reference changes.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:39:45.457Z"
          },
          {
            "id": 5,
            "title": "Implement useModbusMemory Hook for Real-time Memory Monitoring",
            "description": "Create src/hooks/useModbusMemory.ts React hook that subscribes to Modbus memory changes for a specific register type and address range, with initial data loading and Tauri event-based real-time updates.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create src/hooks/useModbusMemory.ts:\n\n1. Import listen from '@tauri-apps/api/event', modbusService, and types\n\n2. Define hook signature:\n   function useModbusMemory(type: RegisterType, start: number, count: number): {\n     values: (boolean | number)[];\n     isLoading: boolean;\n     error: string | null;\n     refresh: () => Promise<void>;\n   }\n\n3. Implement hook:\n   - useState for values, isLoading, error\n   - useCallback for refresh function that loads data based on type:\n     - If type === 'coil': await modbusService.readCoils(start, count)\n     - Else: await modbusService.readRegisters(type, start, count)\n\n4. useEffect for initial load and event subscription:\n   - Set isLoading true, call refresh()\n   - Subscribe to 'modbus:memory-changed' event using listen()\n   - Event handler checks if change is in range:\n     ```typescript\n     const isInRange = (address: number) => address >= start && address < start + count;\n     if (event.payload.registerType === type && isInRange(event.payload.address)) {\n       setValues(prev => {\n         const updated = [...prev];\n         updated[event.payload.address - start] = event.payload.newValue;\n         return updated;\n       });\n     }\n     ```\n   - Return cleanup function that calls unlisten\n\n5. Add dependencies array: [type, start, count]\n\n6. Handle type coercion: coil values are boolean[], register values are number[]\n\n7. Optional: integrate with modbusStore cache for performance optimization",
            "status": "done",
            "testStrategy": "Test initial load fetches correct data based on RegisterType (coils vs registers). Test isLoading state transitions during fetch. Test error state is set on failed fetch. Test event listener updates values when memory-changed event fires within range. Test event listener ignores events outside subscribed range. Test event listener ignores events for different register types. Test cleanup function unsubscribes from events on unmount. Test refresh function reloads data. Test values array updates correctly at the right index (address - start).",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T10:40:50.395Z"
          }
        ],
        "updatedAt": "2026-01-27T10:40:50.395Z"
      },
      {
        "id": "26",
        "title": "Set Up End-to-End Testing Infrastructure",
        "description": "Configure Playwright for E2E testing with Tauri app launch support, create test utilities, fixtures, and initial test suites for project, layout, and Modbus functionality.",
        "details": "1. Install Playwright:\n   ```bash\n   npm install -D @playwright/test\n   npx playwright install\n   ```\n\n2. Create `playwright.config.ts`:\n   ```typescript\n   import { defineConfig } from '@playwright/test';\n\n   export default defineConfig({\n     testDir: './tests/e2e',\n     timeout: 60000,\n     retries: process.env.CI ? 2 : 0,\n     use: {\n       trace: 'on-first-retry',\n       screenshot: 'only-on-failure',\n       video: 'on-first-retry',\n     },\n     projects: [\n       { name: 'tauri', use: { /* Tauri-specific config */ } }\n     ],\n   });\n   ```\n\n3. Create test utilities in `tests/e2e/utils/`:\n   - `app.ts`: Tauri app lifecycle helpers\n     ```typescript\n     export async function launchApp() {\n       // Use @playwright/test with custom launch for Tauri\n       // May need tauri-driver or webview2 approach on Windows\n     }\n     export async function closeApp(app) { /* cleanup */ }\n     ```\n   - `selectors.ts`: Common element selectors\n     ```typescript\n     export const selectors = {\n       menuBar: '[data-testid=\"menu-bar\"]',\n       newProjectBtn: '[data-testid=\"new-project-btn\"]',\n       projectNameInput: '[data-testid=\"project-name-input\"]',\n       // ...\n     };\n     ```\n   - `helpers.ts`: Common test operations\n     ```typescript\n     export async function createNewProject(page, name: string) {\n       await page.click(selectors.newProjectBtn);\n       await page.fill(selectors.projectNameInput, name);\n       await page.click(selectors.createBtn);\n     }\n     ```\n\n4. Create test fixtures in `tests/e2e/fixtures/`:\n   - Sample .mop files for testing (valid and intentionally corrupted)\n   - Mock project configurations\n   - Test data for memory values\n\n5. Write initial E2E test suites:\n   - `tests/e2e/project.spec.ts`:\n     ```typescript\n     test('creates new project', async ({ page }) => {\n       await page.click('[data-testid=\"menu-file\"]');\n       await page.click('[data-testid=\"menu-new-project\"]');\n       await page.fill('[data-testid=\"project-name\"]', 'TestProject');\n       // ... folder selection\n       await page.click('[data-testid=\"create-btn\"]');\n       await expect(page.locator('[data-testid=\"project-header\"]')).toContainText('TestProject');\n     });\n\n     test('opens existing project', async ({ page }) => { /* */ });\n     test('saves project', async ({ page }) => { /* */ });\n     ```\n\n   - `tests/e2e/layout.spec.ts`:\n     ```typescript\n     test('toggles sidebar with Ctrl+B', async ({ page }) => {\n       const sidebar = page.locator('[data-testid=\"sidebar\"]');\n       await expect(sidebar).toBeVisible();\n       await page.keyboard.press('Control+b');\n       await expect(sidebar).not.toBeVisible();\n       await page.keyboard.press('Control+b');\n       await expect(sidebar).toBeVisible();\n     });\n\n     test('resizes panels', async ({ page }) => { /* */ });\n     test('switches sidebar tabs', async ({ page }) => { /* */ });\n     ```\n\n   - `tests/e2e/modbus.spec.ts`:\n     ```typescript\n     test('starts and stops Modbus TCP server', async ({ page }) => {\n       await page.click('[data-testid=\"modbus-start-tcp\"]');\n       await expect(page.locator('[data-testid=\"tcp-status\"]')).toContainText('Running');\n       await page.click('[data-testid=\"modbus-stop-tcp\"]');\n       await expect(page.locator('[data-testid=\"tcp-status\"]')).toContainText('Stopped');\n     });\n\n     test('displays memory values', async ({ page }) => { /* */ });\n     ```\n\n6. Add npm scripts:\n   ```json\n   \"scripts\": {\n     \"test:e2e\": \"playwright test\",\n     \"test:e2e:ui\": \"playwright test --ui\",\n     \"test:e2e:headed\": \"playwright test --headed\"\n   }\n   ```\n\n7. Add data-testid attributes to components:\n   - Update existing components to include data-testid for reliable selection\n   - Create naming convention: component-name or component-action",
        "testStrategy": "1. Verify Playwright installation and configuration works\n2. Test app launch/close utilities work reliably\n3. Run initial test suite and verify all tests pass\n4. Test screenshot capture on failure works\n5. Verify tests run in CI environment (if applicable)\n6. Test on Windows as primary target platform",
        "priority": "medium",
        "dependencies": [
          "15"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Playwright and Create Configuration File",
            "description": "Install @playwright/test package, run browser installation, and create playwright.config.ts with Tauri-specific settings for E2E testing.",
            "dependencies": [],
            "details": "Install Playwright dependencies: `npm install -D @playwright/test` and `npx playwright install`. Create `playwright.config.ts` in project root with: testDir set to './tests/e2e', timeout of 60000ms for Tauri app startup, retries set to 2 for CI and 0 locally, trace/screenshot/video capture on failure, and a 'tauri' project configuration. Add npm scripts to package.json: 'test:e2e' for headless runs, 'test:e2e:ui' for Playwright UI mode, and 'test:e2e:headed' for headed browser execution. Configure webServer to build and launch the Tauri app before tests using 'npm run tauri dev' command.",
            "status": "done",
            "testStrategy": "Verify Playwright installation by running 'npx playwright --version'. Test configuration by running 'npx playwright test --list' to confirm test directory is recognized. Verify npm scripts execute without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T09:40:29.506Z"
          },
          {
            "id": 2,
            "title": "Create Test Utilities for Tauri App Lifecycle and Element Selection",
            "description": "Implement test utility modules for Tauri application launch/close helpers, common element selectors, and reusable test operations.",
            "dependencies": [
              1
            ],
            "details": "Create `tests/e2e/utils/` directory structure. Implement `app.ts` with launchApp() function that handles Tauri/WebView2 app startup on Windows, closeApp() for cleanup, and waitForAppReady() that waits for main window to be interactive. Create `selectors.ts` with data-testid based selectors for: menu bar components (menu-bar, menu-file, menu-new-project), project operations (new-project-btn, project-name-input, create-btn, project-header), sidebar elements (sidebar, sidebar-tab-*), panel system (panel-container, panel-header, resize-handle), and Modbus controls (modbus-start-tcp, tcp-status). Create `helpers.ts` with common test operations: createNewProject(page, name), openProject(page, path), toggleSidebar(page), switchSidebarTab(page, tab).",
            "status": "done",
            "testStrategy": "Unit test selector constants are properly exported. Test app lifecycle helpers launch and close a minimal Tauri app without errors. Verify helper functions work with mock page objects.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T09:41:55.618Z"
          },
          {
            "id": 3,
            "title": "Create Test Fixtures with Sample Project Files",
            "description": "Create test fixture directory with sample .mop project files (valid and corrupted), mock project configurations, and test data for memory values.",
            "dependencies": [
              1
            ],
            "details": "Create `tests/e2e/fixtures/` directory. Generate sample .mop files: 'valid-project.mop' as a properly structured ZIP archive containing config.yml with project metadata, plc_csv/ directory with sample PLC data, and memory snapshots. Create 'corrupted-project.mop' with intentionally invalid ZIP structure for error handling tests. Create 'minimal-project.mop' with only required files for quick loading tests. Add 'mock-config.yml' with sample project configuration. Create 'test-memory-values.json' containing predefined coil and register values for Modbus testing (addresses 0-99 with various values). Add 'expected-layouts.json' defining expected panel positions after layout operations.",
            "status": "done",
            "testStrategy": "Verify .mop files can be opened by the application without errors. Test corrupted file triggers appropriate error handling. Validate JSON fixtures parse correctly and contain expected data structures.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T09:42:52.967Z"
          },
          {
            "id": 4,
            "title": "Write Initial E2E Test Suites for Project, Layout, and Modbus",
            "description": "Implement three E2E test specification files covering project operations, layout manipulation, and Modbus server functionality.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create `tests/e2e/project.spec.ts` with tests: 'creates new project' (click menu, fill name, select folder, verify header shows project name), 'opens existing project' (use fixture .mop file, verify project loads), 'saves project' (modify content, save, reopen to verify persistence), 'handles corrupted project file gracefully' (open corrupted fixture, verify error dialog). Create `tests/e2e/layout.spec.ts` with tests: 'toggles sidebar with Ctrl+B' (verify visibility change), 'resizes panels using drag handle' (drag handle, verify size changes), 'switches sidebar tabs' (click each tab, verify content changes), 'remembers layout after restart' (modify layout, restart app, verify layout restored). Create `tests/e2e/modbus.spec.ts` with tests: 'starts and stops Modbus TCP server' (click start, verify status shows Running, click stop, verify Stopped), 'displays memory values' (start server, write values, verify display updates), 'handles server errors gracefully' (attempt invalid port, verify error message).",
            "status": "done",
            "testStrategy": "Run full test suite with 'npm run test:e2e' and verify all tests pass. Check screenshot capture works on intentional failures. Verify tests are isolated and can run in any order.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T09:44:26.446Z"
          },
          {
            "id": 5,
            "title": "Add data-testid Attributes to Application Components",
            "description": "Update existing React components to include data-testid attributes following a consistent naming convention for reliable E2E test element selection.",
            "dependencies": [
              4
            ],
            "details": "Establish naming convention: component-name or component-action format (e.g., 'menu-bar', 'new-project-btn', 'sidebar-tab-explorer'). Update MenuBar component: add data-testid='menu-bar', 'menu-file', 'menu-edit', 'menu-view', 'menu-new-project', 'menu-open-project', 'menu-save'. Update Sidebar component: add data-testid='sidebar', 'sidebar-toggle', 'sidebar-tab-explorer', 'sidebar-tab-search', 'sidebar-tab-modbus', 'sidebar-tab-settings'. Update Panel components: add data-testid='panel-container', 'panel-{id}', 'panel-header-{id}', 'resize-handle-horizontal', 'resize-handle-vertical'. Update Project UI: add data-testid='project-header', 'project-name-input', 'project-folder-select', 'create-btn', 'cancel-btn'. Update Modbus components: add data-testid='modbus-start-tcp', 'modbus-stop-tcp', 'tcp-status', 'tcp-port-input', 'memory-visualizer'. Document all data-testid values in selectors.ts for synchronization.",
            "status": "done",
            "testStrategy": "Verify all selectors from selectors.ts can locate corresponding elements in the running application. Run E2E test suite to confirm all element selections work correctly. Check no duplicate data-testid values exist in the component tree.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T09:47:30.697Z"
          }
        ],
        "updatedAt": "2026-01-27T09:47:30.697Z"
      },
      {
        "id": "27",
        "title": "Create Memory Visualizer Type Definitions and Utility Functions",
        "description": "Define TypeScript types for Memory Visualizer configuration, view settings, favorites, and create value formatting utility functions for different display formats (DEC, HEX, BINARY, SIGNED, FLOAT32).",
        "details": "Create the following files:\n\n1. `src/components/MemoryVisualizer/types.ts`:\n```typescript\nimport type { MemoryType } from '../../types/modbus';\n\n// Display format for values\nexport type DisplayFormat = 'DEC' | 'HEX' | 'BINARY' | 'SIGNED' | 'FLOAT32';\n\n// View configuration for memory table\nexport interface MemoryViewConfig {\n  memoryType: MemoryType;\n  startAddress: number;\n  count: number;\n  columns: number; // 1-16\n  displayFormat: DisplayFormat;\n}\n\n// Favorite item\nexport interface FavoriteItem {\n  id: string;\n  memoryType: MemoryType;\n  address: number;\n  label: string;\n  color?: string; // hex color\n  displayFormat: DisplayFormat;\n}\n\n// Context menu position\nexport interface ContextMenuPosition {\n  x: number;\n  y: number;\n}\n\n// Cell selection state\nexport interface CellSelection {\n  memoryType: MemoryType;\n  address: number;\n  value: boolean | number;\n}\n```\n\n2. `src/components/MemoryVisualizer/utils/formatters.ts`:\n```typescript\nimport type { DisplayFormat } from '../types';\n\nexport function formatValue(value: number, format: DisplayFormat): string {\n  switch (format) {\n    case 'DEC': return value.toString();\n    case 'HEX': return '0x' + value.toString(16).toUpperCase().padStart(4, '0');\n    case 'BINARY': return value.toString(2).padStart(16, '0');\n    case 'SIGNED': return (value > 32767 ? value - 65536 : value).toString();\n    case 'FLOAT32': return 'N/A'; // Requires 2 registers, handled separately\n    default: return value.toString();\n  }\n}\n\nexport function parseInputValue(input: string, format: DisplayFormat): number | null {\n  // Parse user input based on current format\n  try {\n    let value: number;\n    if (format === 'HEX' || input.startsWith('0x')) {\n      value = parseInt(input.replace('0x', ''), 16);\n    } else if (format === 'BINARY') {\n      value = parseInt(input, 2);\n    } else if (format === 'SIGNED') {\n      const signed = parseInt(input, 10);\n      value = signed < 0 ? signed + 65536 : signed;\n    } else {\n      value = parseInt(input, 10);\n    }\n    if (isNaN(value) || value < 0 || value > 65535) return null;\n    return value;\n  } catch {\n    return null;\n  }\n}\n\nexport function formatFloat32(highWord: number, lowWord: number): string {\n  // Combine two 16-bit registers into 32-bit float (Big Endian)\n  const buffer = new ArrayBuffer(4);\n  const view = new DataView(buffer);\n  view.setUint16(0, highWord, false);\n  view.setUint16(2, lowWord, false);\n  return view.getFloat32(0, false).toFixed(3);\n}\n```\n\n3. `src/components/MemoryVisualizer/utils/addressUtils.ts`:\n```typescript\nimport type { MemoryType } from '../../../types/modbus';\n\nexport function formatAddress(address: number, format: 'DEC' | 'HEX' = 'DEC'): string {\n  return format === 'HEX' \n    ? '0x' + address.toString(16).toUpperCase().padStart(4, '0')\n    : address.toString();\n}\n\nexport function getModbusAddressPrefix(type: MemoryType): string {\n  switch (type) {\n    case 'coil': return '0';\n    case 'discrete': return '1';\n    case 'input': return '3';\n    case 'holding': return '4';\n    default: return '';\n  }\n}\n\nexport function calculateRowCount(count: number, columns: number): number {\n  return Math.ceil(count / columns);\n}\n\nexport function getAddressForCell(startAddress: number, row: number, col: number, columns: number): number {\n  return startAddress + (row * columns) + col;\n}\n```",
        "testStrategy": "1. Unit test formatters.ts: Test formatValue() with all DisplayFormat options, verify HEX padding, SIGNED conversion for values > 32767, BINARY padding.\n2. Unit test parseInputValue(): Test parsing HEX with/without 0x prefix, BINARY strings, negative SIGNED values.\n3. Unit test formatFloat32(): Create known float values and verify correct conversion.\n4. Unit test addressUtils: Verify address formatting in both DEC and HEX, row/column calculations.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript Interfaces for MemoryVisualizer Types",
            "description": "Create the types.ts file with DisplayFormat type alias and all required interfaces (MemoryViewConfig, FavoriteItem, ContextMenuPosition, CellSelection) for the Memory Visualizer component.",
            "dependencies": [],
            "details": "Create `src/components/MemoryVisualizer/types.ts` with:\n\n1. Import MemoryType from '../../types/modbus'\n2. Define DisplayFormat union type: 'DEC' | 'HEX' | 'BINARY' | 'SIGNED' | 'FLOAT32'\n3. Define MemoryViewConfig interface with memoryType, startAddress, count, columns (1-16), and displayFormat fields\n4. Define FavoriteItem interface with id, memoryType, address, label, optional color (hex), and displayFormat fields\n5. Define ContextMenuPosition interface with x and y number coordinates\n6. Define CellSelection interface with memoryType, address, and value (boolean | number) fields\n\nExport all types for use by other Memory Visualizer components.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation passes. Import types in a test file and ensure all interfaces can be used correctly with proper type checking for each field. Test that DisplayFormat type only accepts valid string literals.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:40:55.544Z"
          },
          {
            "id": 2,
            "title": "Implement Value Formatting Utility Functions",
            "description": "Create formatters.ts with formatValue(), parseInputValue(), and formatFloat32() functions for converting between different display formats with proper validation and error handling.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/MemoryVisualizer/utils/formatters.ts` with:\n\n1. formatValue(value: number, format: DisplayFormat): string\n   - DEC: return value.toString()\n   - HEX: return '0x' + value.toString(16).toUpperCase().padStart(4, '0')\n   - BINARY: return value.toString(2).padStart(16, '0')\n   - SIGNED: return (value > 32767 ? value - 65536 : value).toString()\n   - FLOAT32: return 'N/A' (requires 2 registers)\n\n2. parseInputValue(input: string, format: DisplayFormat): number | null\n   - Handle HEX with/without 0x prefix\n   - Handle BINARY string parsing\n   - Handle SIGNED negative value conversion (add 65536 if negative)\n   - Validate range 0-65535, return null for invalid input\n\n3. formatFloat32(highWord: number, lowWord: number): string\n   - Use ArrayBuffer and DataView for IEEE 754 conversion\n   - Big Endian byte order\n   - Return float value with 3 decimal places",
            "status": "done",
            "testStrategy": "Unit tests for formatValue() with all DisplayFormat options: verify HEX padding (e.g., 255 -> '0x00FF'), SIGNED conversion for values > 32767, BINARY padding to 16 bits. Test parseInputValue() with valid/invalid inputs for each format. Test formatFloat32() with known IEEE 754 values.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:41:33.239Z"
          },
          {
            "id": 3,
            "title": "Implement Address Utility Functions",
            "description": "Create addressUtils.ts with formatAddress(), getModbusAddressPrefix(), calculateRowCount(), and getAddressForCell() utility functions for memory table address calculations.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/MemoryVisualizer/utils/addressUtils.ts` with:\n\n1. Import MemoryType from '../../../types/modbus'\n\n2. formatAddress(address: number, format: 'DEC' | 'HEX' = 'DEC'): string\n   - HEX: return '0x' + address.toString(16).toUpperCase().padStart(4, '0')\n   - DEC: return address.toString()\n\n3. getModbusAddressPrefix(type: MemoryType): string\n   - coil: return '0'\n   - discrete: return '1'\n   - input: return '3'\n   - holding: return '4'\n   - default: return ''\n\n4. calculateRowCount(count: number, columns: number): number\n   - return Math.ceil(count / columns)\n\n5. getAddressForCell(startAddress: number, row: number, col: number, columns: number): number\n   - return startAddress + (row * columns) + col\n\nExport all functions for use by Memory Visualizer table components.",
            "status": "done",
            "testStrategy": "Unit tests for formatAddress() with DEC/HEX formats. Test getModbusAddressPrefix() returns correct prefix for each MemoryType. Test calculateRowCount() with edge cases (count < columns, exact multiple, partial row). Test getAddressForCell() with various row/col/column combinations.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:42:26.861Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into: 1) Define TypeScript interfaces for MemoryVisualizer types (DisplayFormat, MemoryViewConfig, FavoriteItem, ContextMenuPosition, CellSelection) in types.ts. 2) Implement formatters.ts with formatValue(), parseInputValue(), and formatFloat32() functions with proper validation and error handling. 3) Implement addressUtils.ts with formatAddress(), getModbusAddressPrefix(), calculateRowCount(), and getAddressForCell() utility functions.",
        "updatedAt": "2026-01-28T11:42:26.861Z"
      },
      {
        "id": "28",
        "title": "Implement Memory Table Core Component with Grid Layout",
        "description": "Create the main MemoryTable component that displays memory values in a configurable grid format with row headers showing addresses and support for variable column counts (1-16).",
        "details": "Create `src/components/MemoryVisualizer/MemoryTable.tsx`:\n\n```typescript\nimport { useMemo } from 'react';\nimport type { MemoryType } from '../../types/modbus';\nimport type { DisplayFormat } from './types';\nimport { MemoryCell } from './MemoryCell';\nimport { formatAddress, calculateRowCount, getAddressForCell } from './utils/addressUtils';\n\ninterface MemoryTableProps {\n  memoryType: MemoryType;\n  startAddress: number;\n  values: (boolean | number)[];\n  columns: number;\n  displayFormat: DisplayFormat;\n  isReadOnly: boolean; // discrete and input are read-only\n  onCellClick: (address: number, value: boolean | number) => void;\n  onCellContextMenu: (e: React.MouseEvent, address: number, value: boolean | number) => void;\n}\n\nexport function MemoryTable({\n  memoryType,\n  startAddress,\n  values,\n  columns,\n  displayFormat,\n  isReadOnly,\n  onCellClick,\n  onCellContextMenu,\n}: MemoryTableProps) {\n  const rowCount = useMemo(() => calculateRowCount(values.length, columns), [values.length, columns]);\n  const isBooleanType = memoryType === 'coil' || memoryType === 'discrete';\n\n  const rows = useMemo(() => {\n    const result: Array<{ rowAddress: number; cells: Array<{ address: number; value: boolean | number } | null> }> = [];\n    \n    for (let row = 0; row < rowCount; row++) {\n      const rowAddress = startAddress + (row * columns);\n      const cells: Array<{ address: number; value: boolean | number } | null> = [];\n      \n      for (let col = 0; col < columns; col++) {\n        const index = (row * columns) + col;\n        if (index < values.length) {\n          cells.push({\n            address: startAddress + index,\n            value: values[index],\n          });\n        } else {\n          cells.push(null);\n        }\n      }\n      result.push({ rowAddress, cells });\n    }\n    return result;\n  }, [startAddress, values, columns, rowCount]);\n\n  return (\n    <div className=\"overflow-auto h-full\">\n      <table className=\"w-full border-collapse text-sm font-mono\">\n        <thead className=\"sticky top-0 bg-gray-800 z-10\">\n          <tr>\n            <th className=\"p-1 border border-gray-700 text-gray-400 w-16\">Addr</th>\n            {Array.from({ length: columns }, (_, i) => (\n              <th key={i} className=\"p-1 border border-gray-700 text-gray-400 w-16\">+{i}</th>\n            ))}\n          </tr>\n        </thead>\n        <tbody>\n          {rows.map(({ rowAddress, cells }) => (\n            <tr key={rowAddress}>\n              <td className=\"p-1 border border-gray-700 text-gray-400 bg-gray-800\">\n                {formatAddress(rowAddress, displayFormat === 'HEX' ? 'HEX' : 'DEC')}\n              </td>\n              {cells.map((cell, colIndex) => (\n                <td key={colIndex} className=\"p-0 border border-gray-700\">\n                  {cell ? (\n                    <MemoryCell\n                      address={cell.address}\n                      value={cell.value}\n                      isBooleanType={isBooleanType}\n                      displayFormat={displayFormat}\n                      isReadOnly={isReadOnly}\n                      onClick={() => onCellClick(cell.address, cell.value)}\n                      onContextMenu={(e) => onCellContextMenu(e, cell.address, cell.value)}\n                    />\n                  ) : (\n                    <div className=\"h-8 bg-gray-900\" />\n                  )}\n                </td>\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n```\n\nThe component should:\n- Display memory values in a grid format with configurable columns (1-16)\n- Show row header with starting address for each row\n- Support both boolean (coil/discrete) and number (holding/input) value types\n- Use sticky header for address column headers\n- Properly handle sparse data (empty cells at end)",
        "testStrategy": "1. Render test: Mount with 100 values and 8 columns, verify 13 rows rendered (100/8 = 12.5, rounded up).\n2. Address verification: Check row headers show correct start addresses (0, 8, 16, ...).\n3. Column header test: Verify +0 through +7 displayed for 8 columns.\n4. Empty cell test: With count not divisible by columns, verify trailing cells are empty/disabled.\n5. Integration: Connect to useModbusHoldingRegisters hook and verify values update on memory change events.",
        "priority": "high",
        "dependencies": [
          "27"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create MemoryTable Component Structure with Props Interface",
            "description": "Set up the foundational MemoryTable component with TypeScript interface definitions for props including memoryType, startAddress, values array, columns count, displayFormat, and event handlers.",
            "dependencies": [],
            "details": "Create `src/components/MemoryVisualizer/MemoryTable.tsx` with the MemoryTableProps interface defining: memoryType (MemoryType), startAddress (number), values ((boolean | number)[]), columns (number, 1-16), displayFormat (DisplayFormat), isReadOnly (boolean), onCellClick and onCellContextMenu handlers. Import required types from '../../types/modbus' and './types'. Set up the basic functional component skeleton with proper TypeScript typing and export statement.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation passes with no type errors. Test that component renders without crashing when provided valid props. Validate prop types are correctly enforced.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:43:41.164Z"
          },
          {
            "id": 2,
            "title": "Implement Row and Cell Generation Logic with useMemo Optimization",
            "description": "Build the core logic for generating rows and cells from the values array, calculating row count based on columns, and optimizing with useMemo for performance.",
            "dependencies": [
              1
            ],
            "details": "Implement calculateRowCount utility to determine number of rows needed (Math.ceil(values.length / columns)). Create useMemo-wrapped rows computation that generates array of row objects containing rowAddress (startAddress + row * columns) and cells array. Each cell should have address and value, or null for empty cells beyond values.length. Determine isBooleanType from memoryType ('coil' or 'discrete'). Ensure proper memoization dependencies to avoid unnecessary recalculations.",
            "status": "done",
            "testStrategy": "Unit test: 100 values with 8 columns should produce 13 rows. Test row addresses are correct (0, 8, 16...). Test last row handles partial fill correctly. Test memo doesn't recalculate when unrelated props change.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:43:41.175Z"
          },
          {
            "id": 3,
            "title": "Add Sticky Header and Scrolling Behavior",
            "description": "Implement the table structure with sticky header row showing column offsets (+0, +1, etc.), sticky address column, and proper overflow scrolling for large datasets.",
            "dependencies": [
              1
            ],
            "details": "Create HTML table structure with thead containing sticky header row (position: sticky, top: 0) with 'Addr' column and column offset headers (+0 through +columns-1). Apply z-index to ensure header stays above scrolling content. Wrap table in overflow-auto container with h-full for proper scrolling. Style header cells with bg-gray-800 and border-gray-700. Use CSS classes for sticky behavior: 'sticky top-0 bg-gray-800 z-10' for thead. Ensure address column in tbody also has appropriate background for visual consistency.",
            "status": "done",
            "testStrategy": "Visual test: scroll vertically, verify header stays visible. Test column headers show correct offsets for columns=1, 8, 16. Test horizontal scroll works when content is wide. Test z-index prevents content overlap with header.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:43:41.186Z"
          },
          {
            "id": 4,
            "title": "Integrate MemoryCell Component and Event Propagation",
            "description": "Wire up the MemoryCell component for rendering each cell and implement proper event handler propagation for click and context menu interactions.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Import MemoryCell from './MemoryCell'. In tbody rows, render MemoryCell for each non-null cell passing: address, value, isBooleanType, displayFormat, isReadOnly, onClick (wrapping onCellClick with cell's address and value), onContextMenu (wrapping onCellContextMenu with event and cell data). For null cells (empty positions), render placeholder div with 'h-8 bg-gray-900' styling. Use formatAddress utility from './utils/addressUtils' for row address display. Ensure event handlers are properly typed and pass correct parameters.",
            "status": "done",
            "testStrategy": "Test click on cell triggers onCellClick with correct address and value. Test right-click triggers onCellContextMenu with event and cell data. Test empty cells don't trigger events. Test boolean vs number cells render correctly with MemoryCell.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:43:41.197Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create the basic MemoryTable component structure with props interface and grid layout using CSS grid or HTML table. 2) Implement row/cell generation logic using useMemo for performance optimization. 3) Add sticky header functionality and proper scrolling behavior. 4) Integrate with MemoryCell component for cell rendering and handle click/context menu events propagation.",
        "updatedAt": "2026-01-28T11:43:41.197Z"
      },
      {
        "id": "29",
        "title": "Implement MemoryCell Component with Coil Toggle and Register Display",
        "description": "Create the MemoryCell component that handles display and interaction for individual memory cells, including toggle functionality for coils and click-to-edit for registers.",
        "details": "Create `src/components/MemoryVisualizer/MemoryCell.tsx`:\n\n```typescript\nimport { memo } from 'react';\nimport type { DisplayFormat } from './types';\nimport { formatValue } from './utils/formatters';\n\ninterface MemoryCellProps {\n  address: number;\n  value: boolean | number;\n  isBooleanType: boolean;\n  displayFormat: DisplayFormat;\n  isReadOnly: boolean;\n  onClick: () => void;\n  onContextMenu: (e: React.MouseEvent) => void;\n}\n\nexport const MemoryCell = memo(function MemoryCell({\n  address,\n  value,\n  isBooleanType,\n  displayFormat,\n  isReadOnly,\n  onClick,\n  onContextMenu,\n}: MemoryCellProps) {\n  if (isBooleanType) {\n    // Coil or Discrete Input - Boolean display\n    const boolValue = value as boolean;\n    return (\n      <button\n        className={`w-full h-8 flex items-center justify-center transition-colors ${\n          boolValue\n            ? 'bg-green-600 hover:bg-green-500 text-white'\n            : 'bg-gray-700 hover:bg-gray-600 text-gray-300'\n        } ${isReadOnly ? 'cursor-default' : 'cursor-pointer'}`}\n        onClick={!isReadOnly ? onClick : undefined}\n        onContextMenu={onContextMenu}\n        disabled={isReadOnly}\n        title={`Address: ${address}\\nValue: ${boolValue ? 'ON (1)' : 'OFF (0)'}`}\n      >\n        {boolValue ? '1' : '0'}\n      </button>\n    );\n  }\n\n  // Register - Numeric display\n  const numValue = value as number;\n  const displayValue = formatValue(numValue, displayFormat);\n\n  return (\n    <button\n      className={`w-full h-8 px-1 flex items-center justify-center text-xs truncate\n        bg-gray-800 hover:bg-gray-700 text-gray-200\n        ${isReadOnly ? 'cursor-default' : 'cursor-pointer'}`}\n      onClick={!isReadOnly ? onClick : undefined}\n      onContextMenu={onContextMenu}\n      title={`Address: ${address}\\nDEC: ${numValue}\\nHEX: 0x${numValue.toString(16).toUpperCase()}`}\n    >\n      {displayValue}\n    </button>\n  );\n});\n```\n\nKey features:\n- Coil cells: Display as toggle buttons with ON (green, \"1\") / OFF (gray, \"0\") states\n- Register cells: Display formatted value based on displayFormat prop\n- Memo optimization to prevent unnecessary re-renders\n- Tooltip showing address and value in multiple formats\n- Visual distinction between read-only (discrete/input) and writable (coil/holding) cells\n- Click handler for editing (triggers popover in parent)\n- Context menu handler for right-click options",
        "testStrategy": "1. Boolean cell rendering: Render with value=true, verify green background and '1' text.\n2. Boolean toggle: Render coil cell, click, verify onClick called.\n3. Read-only boolean: Render discrete input, click, verify onClick NOT called.\n4. Register display: Render with value=255, format='HEX', verify '0x00FF' displayed.\n5. Register display formats: Test DEC, HEX, BINARY, SIGNED with value=65280 (0xFF00).\n6. Context menu: Right-click on cell, verify onContextMenu called with event.\n7. Tooltip: Hover over cell, verify title attribute contains address and value info.",
        "priority": "high",
        "dependencies": [
          "27"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create base MemoryCell component with props interface and memo wrapper",
            "description": "Set up the foundational MemoryCell component file with TypeScript props interface, React.memo optimization wrapper, and basic component structure for performance-optimized cell rendering.",
            "dependencies": [],
            "details": "Create `src/components/MemoryVisualizer/MemoryCell.tsx` with:\n\n1. Import React memo and required types:\n   - `import { memo } from 'react'`\n   - `import type { DisplayFormat } from './types'`\n   - `import { formatValue } from './utils/formatters'`\n\n2. Define MemoryCellProps interface with all required props:\n   - address: number (memory address for display)\n   - value: boolean | number (cell value, union type for both cell types)\n   - isBooleanType: boolean (determines coil vs register rendering)\n   - displayFormat: DisplayFormat (HEX, DEC, BIN for registers)\n   - isReadOnly: boolean (discrete/input vs coil/holding)\n   - onClick: () => void (triggers edit popover in parent)\n   - onContextMenu: (e: React.MouseEvent) => void (right-click menu)\n\n3. Create memo-wrapped component shell:\n   - Use named function inside memo for React DevTools display\n   - Destructure all props in function signature\n   - Add conditional rendering branch for isBooleanType\n   - Export as named export for tree-shaking",
            "status": "done",
            "testStrategy": "1. Unit test: Verify component renders without crashing with minimal props.\n2. Test memo behavior: Render twice with same props, verify render count is 1.\n3. Test memo invalidation: Change value prop, verify re-render occurs.\n4. Snapshot test: Capture component structure for regression detection.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:43:10.736Z"
          },
          {
            "id": 2,
            "title": "Implement boolean cell rendering for coils and discrete inputs",
            "description": "Implement the boolean cell branch (isBooleanType === true) with toggle button styling, ON/OFF visual states, green/gray color coding, and proper read-only handling for discrete inputs.",
            "dependencies": [
              1
            ],
            "details": "Implement the boolean rendering branch when isBooleanType is true:\n\n1. Visual styling for ON state (value === true):\n   - Background: bg-green-600, hover: bg-green-500\n   - Text: white, display '1'\n   - Clear visual indication of active state\n\n2. Visual styling for OFF state (value === false):\n   - Background: bg-gray-700, hover: bg-gray-600\n   - Text: gray-300, display '0'\n   - Subdued appearance for inactive state\n\n3. Button element attributes:\n   - Full width/height: w-full h-8\n   - Flex centering: flex items-center justify-center\n   - Smooth transitions: transition-colors\n\n4. Interaction handling:\n   - Writable coils: onClick triggers handler, cursor-pointer\n   - Read-only discrete inputs: onClick undefined, cursor-default, disabled=true\n   - onContextMenu always attached for right-click menu\n\n5. Tooltip content:\n   - Format: 'Address: {address}\\nValue: {ON (1)|OFF (0)}'\n   - Uses title attribute for native browser tooltip",
            "status": "done",
            "testStrategy": "1. Render with value=true: Verify green background class and '1' text content.\n2. Render with value=false: Verify gray background class and '0' text content.\n3. Click writable coil: Verify onClick handler is called exactly once.\n4. Click read-only discrete input: Verify onClick is NOT called, button is disabled.\n5. Verify tooltip contains correct address and formatted boolean value.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:43:10.748Z"
          },
          {
            "id": 3,
            "title": "Implement register cell rendering with format-aware value display",
            "description": "Implement the register cell branch (isBooleanType === false) with format-aware value display using formatValue utility, multi-format tooltip, and click-to-edit interaction for holding registers.",
            "dependencies": [
              1
            ],
            "details": "Implement the register rendering branch when isBooleanType is false:\n\n1. Value display using formatValue utility:\n   - Call formatValue(numValue, displayFormat) for formatted output\n   - Support HEX, DEC, BIN display formats from DisplayFormat type\n   - Truncate long values with text-xs and truncate class\n\n2. Button styling:\n   - Full width: w-full h-8\n   - Padding for content: px-1\n   - Dark theme: bg-gray-800, hover: bg-gray-700\n   - Light text: text-gray-200\n   - Small font: text-xs for compact display\n\n3. Enhanced tooltip showing multiple formats:\n   - Line 1: 'Address: {address}'\n   - Line 2: 'DEC: {numValue}' (decimal)\n   - Line 3: 'HEX: 0x{numValue.toString(16).toUpperCase()}' (hex)\n   - Helps users see value in different representations\n\n4. Interaction handling:\n   - Writable holding registers: onClick triggers edit popover, cursor-pointer\n   - Read-only input registers: onClick undefined, cursor-default\n   - onContextMenu always attached for right-click options",
            "status": "done",
            "testStrategy": "1. Render with value=255, format='HEX': Verify displayed value is '0xFF' or 'FF'.\n2. Render with value=255, format='DEC': Verify displayed value is '255'.\n3. Render with value=5, format='BIN': Verify binary representation displays correctly.\n4. Verify tooltip contains address, DEC value, and HEX value in correct format.\n5. Click writable register: Verify onClick is called.\n6. Click read-only register: Verify onClick is NOT called.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:43:10.758Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into: 1) Create base MemoryCell component with props interface and memo wrapper for performance. 2) Implement boolean cell rendering for coils/discrete inputs with toggle button styling and ON/OFF states. 3) Implement register cell rendering with format-aware value display and tooltip showing multiple format representations.",
        "updatedAt": "2026-01-28T11:43:10.758Z"
      },
      {
        "id": "30",
        "title": "Implement Number Input Popover with Numpad Component",
        "description": "Create a popover component with a numpad interface for entering register values, supporting DEC/HEX input modes with appropriate key display.",
        "details": "Create two components:\n\n1. `src/components/MemoryVisualizer/Numpad.tsx`:\n```typescript\nimport { memo } from 'react';\n\ninterface NumpadProps {\n  isHexMode: boolean;\n  onKeyPress: (key: string) => void;\n  onBackspace: () => void;\n  onClear: () => void;\n}\n\nexport const Numpad = memo(function Numpad({ isHexMode, onKeyPress, onBackspace, onClear }: NumpadProps) {\n  const numKeys = ['7', '8', '9', '4', '5', '6', '1', '2', '3', '0'];\n  const hexKeys = ['A', 'B', 'C', 'D', 'E', 'F'];\n\n  const buttonClass = \"w-10 h-10 rounded bg-gray-700 hover:bg-gray-600 active:bg-gray-500 text-white font-mono text-lg flex items-center justify-center transition-colors\";\n\n  return (\n    <div className=\"flex gap-2\">\n      {/* Number keys */}\n      <div className=\"grid grid-cols-3 gap-1\">\n        {numKeys.map((key) => (\n          <button key={key} className={buttonClass} onClick={() => onKeyPress(key)}>{key}</button>\n        ))}\n        <button className={`${buttonClass} text-sm`} onClick={onClear}>CLR</button>\n        <button className={`${buttonClass} text-sm`} onClick={onBackspace}>⌫</button>\n      </div>\n      \n      {/* Hex keys - only show in HEX mode */}\n      {isHexMode && (\n        <div className=\"grid grid-cols-2 gap-1\">\n          {hexKeys.map((key) => (\n            <button key={key} className={buttonClass} onClick={() => onKeyPress(key)}>{key}</button>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n});\n```\n\n2. `src/components/MemoryVisualizer/NumberInputPopover.tsx`:\n```typescript\nimport { useState, useCallback, useEffect } from 'react';\nimport { X, Check } from 'lucide-react';\nimport { Numpad } from './Numpad';\nimport { parseInputValue, formatValue } from './utils/formatters';\nimport type { DisplayFormat } from './types';\n\ninterface NumberInputPopoverProps {\n  initialValue: number;\n  address: number;\n  onApply: (value: number) => void;\n  onCancel: () => void;\n  position: { x: number; y: number };\n}\n\nexport function NumberInputPopover({ initialValue, address, onApply, onCancel, position }: NumberInputPopoverProps) {\n  const [inputMode, setInputMode] = useState<'DEC' | 'HEX'>('DEC');\n  const [inputValue, setInputValue] = useState(formatValue(initialValue, inputMode));\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    setInputValue(formatValue(initialValue, inputMode));\n  }, [inputMode, initialValue]);\n\n  const handleKeyPress = useCallback((key: string) => {\n    setInputValue(prev => {\n      const newValue = prev === '0' ? key : prev + key;\n      const parsed = parseInputValue(newValue, inputMode);\n      if (parsed !== null && parsed <= 65535) {\n        setError(null);\n        return newValue;\n      }\n      return prev;\n    });\n  }, [inputMode]);\n\n  const handleBackspace = useCallback(() => {\n    setInputValue(prev => prev.length > 1 ? prev.slice(0, -1) : '0');\n    setError(null);\n  }, []);\n\n  const handleClear = useCallback(() => {\n    setInputValue('0');\n    setError(null);\n  }, []);\n\n  const handleApply = useCallback(() => {\n    const parsed = parseInputValue(inputValue, inputMode);\n    if (parsed !== null) {\n      onApply(parsed);\n    } else {\n      setError('Invalid value');\n    }\n  }, [inputValue, inputMode, onApply]);\n\n  // Keyboard support\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') onCancel();\n      if (e.key === 'Enter') handleApply();\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [onCancel, handleApply]);\n\n  return (\n    <div\n      className=\"fixed z-50 bg-gray-800 border border-gray-600 rounded-lg shadow-xl p-3\"\n      style={{ left: position.x, top: position.y }}\n    >\n      <div className=\"flex justify-between items-center mb-2\">\n        <span className=\"text-gray-400 text-sm\">Address: {address}</span>\n        <div className=\"flex gap-1\">\n          <button\n            className={`px-2 py-1 text-xs rounded ${inputMode === 'DEC' ? 'bg-blue-600' : 'bg-gray-700'}`}\n            onClick={() => setInputMode('DEC')}\n          >DEC</button>\n          <button\n            className={`px-2 py-1 text-xs rounded ${inputMode === 'HEX' ? 'bg-blue-600' : 'bg-gray-700'}`}\n            onClick={() => setInputMode('HEX')}\n          >HEX</button>\n        </div>\n      </div>\n      \n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        className=\"w-full bg-gray-900 border border-gray-600 rounded px-2 py-1 text-white font-mono text-lg mb-2\"\n        autoFocus\n      />\n      \n      {error && <p className=\"text-red-400 text-xs mb-2\">{error}</p>}\n      \n      <Numpad\n        isHexMode={inputMode === 'HEX'}\n        onKeyPress={handleKeyPress}\n        onBackspace={handleBackspace}\n        onClear={handleClear}\n      />\n      \n      <div className=\"flex gap-2 mt-3\">\n        <button\n          className=\"flex-1 flex items-center justify-center gap-1 bg-gray-700 hover:bg-gray-600 py-2 rounded\"\n          onClick={onCancel}\n        >\n          <X size={16} /> Cancel\n        </button>\n        <button\n          className=\"flex-1 flex items-center justify-center gap-1 bg-blue-600 hover:bg-blue-500 py-2 rounded\"\n          onClick={handleApply}\n        >\n          <Check size={16} /> Apply\n        </button>\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Initial value display: Open popover with initialValue=1000, verify '1000' shown in DEC mode.\n2. Mode toggle: Click HEX button, verify value converts to '0x03E8'.\n3. Numpad input: Click keys 1,2,3, verify input shows '123'.\n4. HEX keys: Switch to HEX mode, verify A-F buttons appear.\n5. Backspace: Enter '123', press backspace, verify '12' displayed.\n6. Clear: Enter value, press CLR, verify '0' displayed.\n7. Apply: Enter valid value, click Apply, verify onApply called with correct number.\n8. Cancel: Click Cancel or press Escape, verify onCancel called.\n9. Validation: Try to enter value > 65535, verify error or rejection.\n10. Keyboard: Press Enter, verify applies value; press Escape, verify cancels.",
        "priority": "high",
        "dependencies": [
          "27"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Numpad component with configurable key layout",
            "description": "Implement a reusable Numpad component that displays numeric keys (0-9) and conditionally shows hexadecimal keys (A-F) based on the input mode.",
            "dependencies": [],
            "details": "Create `src/components/MemoryVisualizer/Numpad.tsx` with the following features:\n\n1. Accept props: isHexMode (boolean), onKeyPress (key handler), onBackspace, onClear\n2. Render numeric keys 0-9 in a grid layout (3 columns): 7,8,9 | 4,5,6 | 1,2,3 | 0,CLR,⌫\n3. Conditionally render hex keys A-F in a separate 2-column grid when isHexMode is true\n4. Style buttons with consistent appearance: w-10 h-10, rounded, bg-gray-700, hover/active states\n5. Use React.memo for performance optimization\n6. Ensure proper button accessibility with clear visual feedback on interaction",
            "status": "done",
            "testStrategy": "Test key press events fire correctly. Verify hex keys A-F only appear when isHexMode=true. Test CLR and backspace buttons trigger correct callbacks. Visual test for button layout and hover states.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:44:42.952Z"
          },
          {
            "id": 2,
            "title": "Create NumberInputPopover component with positioning and mode toggle",
            "description": "Implement the main popover component that displays at specified coordinates with DEC/HEX mode toggle and integrates the Numpad component.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/MemoryVisualizer/NumberInputPopover.tsx` with:\n\n1. Props: initialValue, address, onApply, onCancel, position {x, y}\n2. State management: inputMode ('DEC' | 'HEX'), inputValue (string), error (string | null)\n3. Fixed positioning using position prop with z-50 for overlay behavior\n4. Header section showing address and DEC/HEX toggle buttons with active state styling\n5. Text input field displaying current value with font-mono styling\n6. Integrate Numpad component passing isHexMode based on inputMode state\n7. Footer with Cancel and Apply buttons using lucide-react icons (X, Check)\n8. Dark theme styling consistent with MemoryVisualizer (bg-gray-800, border-gray-600)",
            "status": "done",
            "testStrategy": "Test popover renders at specified position. Verify DEC/HEX toggle changes inputMode state. Test Numpad integration receives correct isHexMode prop. Verify Cancel/Apply buttons trigger correct callbacks.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:44:42.964Z"
          },
          {
            "id": 3,
            "title": "Implement input value parsing and mode conversion",
            "description": "Integrate value parsing utilities from task 27 to handle input validation and automatic format conversion when switching between DEC and HEX modes.",
            "dependencies": [
              2
            ],
            "details": "Enhance NumberInputPopover with value handling:\n\n1. Import parseInputValue and formatValue from './utils/formatters' (created in task 27)\n2. Initialize inputValue using formatValue(initialValue, inputMode) on mount\n3. Update inputValue when inputMode changes using useEffect: setInputValue(formatValue(currentNumericValue, newMode))\n4. handleKeyPress: Append key to input, validate with parseInputValue, reject if > 65535 or invalid\n5. handleBackspace: Remove last character, default to '0' if empty\n6. handleClear: Reset inputValue to '0'\n7. handleApply: Parse final value, show error if invalid, call onApply with numeric value\n8. Display validation error message when error state is set",
            "status": "done",
            "testStrategy": "Test initial value displays correctly in both DEC and HEX modes. Test mode toggle converts value (1000 DEC <-> 3E8 HEX). Test numpad input appends correctly. Test max value validation (65535). Test invalid input shows error.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:44:42.974Z"
          },
          {
            "id": 4,
            "title": "Add keyboard event handling and focus management",
            "description": "Implement global keyboard shortcuts (Enter to apply, Escape to cancel) and proper focus management for the popover input field.",
            "dependencies": [
              2
            ],
            "details": "Add keyboard and focus handling to NumberInputPopover:\n\n1. Add useEffect to attach window-level keydown listener on mount\n2. Handle 'Escape' key: call onCancel to close popover\n3. Handle 'Enter' key: call handleApply to submit value\n4. Properly clean up event listener on unmount (return cleanup function)\n5. Set autoFocus on the text input for immediate keyboard input\n6. Ensure numeric/hex key presses from physical keyboard also work (optional enhancement)\n7. Consider preventing event propagation to parent components\n8. Handle edge case where popover closes during key event processing",
            "status": "done",
            "testStrategy": "Test Escape key closes popover (calls onCancel). Test Enter key submits value (calls handleApply with parsed value). Test focus is on input when popover opens. Test event listeners are cleaned up on unmount. Test keyboard shortcuts don't interfere with text input.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:44:42.983Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create Numpad component with configurable key layout (0-9 and hex keys A-F). 2) Create NumberInputPopover component with positioning and DEC/HEX mode toggle. 3) Implement input value parsing and validation with format conversion between modes. 4) Add keyboard event handling (Enter to apply, Escape to cancel) and focus management.",
        "updatedAt": "2026-01-28T11:44:42.983Z"
      },
      {
        "id": "31",
        "title": "Implement MemoryToolbar with View Configuration Controls",
        "description": "Create a toolbar component for configuring memory table view settings including memory type selection, address range, column count, and display format toggle.",
        "details": "Create `src/components/MemoryVisualizer/MemoryToolbar.tsx`:\n\n```typescript\nimport { ChevronDown, RefreshCw } from 'lucide-react';\nimport type { MemoryType } from '../../types/modbus';\nimport type { DisplayFormat, MemoryViewConfig } from './types';\n\ninterface MemoryToolbarProps {\n  config: MemoryViewConfig;\n  onConfigChange: (config: Partial<MemoryViewConfig>) => void;\n  onRefresh: () => void;\n  isLoading: boolean;\n}\n\nconst MEMORY_TYPE_OPTIONS: { value: MemoryType; label: string }[] = [\n  { value: 'coil', label: 'Coils (0x)' },\n  { value: 'discrete', label: 'Discrete Inputs (1x)' },\n  { value: 'holding', label: 'Holding Registers (4x)' },\n  { value: 'input', label: 'Input Registers (3x)' },\n];\n\nconst COLUMN_OPTIONS = [1, 2, 4, 8, 10, 16];\n\nexport function MemoryToolbar({ config, onConfigChange, onRefresh, isLoading }: MemoryToolbarProps) {\n  return (\n    <div className=\"flex items-center gap-3 p-2 bg-gray-800 border-b border-gray-700\">\n      {/* Memory Type Selector */}\n      <div className=\"flex items-center gap-1\">\n        <label className=\"text-xs text-gray-400\">Type:</label>\n        <select\n          value={config.memoryType}\n          onChange={(e) => onConfigChange({ memoryType: e.target.value as MemoryType })}\n          className=\"bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm text-white\"\n        >\n          {MEMORY_TYPE_OPTIONS.map(opt => (\n            <option key={opt.value} value={opt.value}>{opt.label}</option>\n          ))}\n        </select>\n      </div>\n\n      {/* Start Address Input */}\n      <div className=\"flex items-center gap-1\">\n        <label className=\"text-xs text-gray-400\">Start:</label>\n        <input\n          type=\"number\"\n          min={0}\n          max={65535}\n          value={config.startAddress}\n          onChange={(e) => onConfigChange({ startAddress: parseInt(e.target.value) || 0 })}\n          className=\"w-20 bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm text-white\"\n        />\n      </div>\n\n      {/* Count Input */}\n      <div className=\"flex items-center gap-1\">\n        <label className=\"text-xs text-gray-400\">Count:</label>\n        <input\n          type=\"number\"\n          min={1}\n          max={1000}\n          value={config.count}\n          onChange={(e) => onConfigChange({ count: Math.min(1000, Math.max(1, parseInt(e.target.value) || 1)) })}\n          className=\"w-20 bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm text-white\"\n        />\n      </div>\n\n      {/* Columns Selector */}\n      <div className=\"flex items-center gap-1\">\n        <label className=\"text-xs text-gray-400\">Cols:</label>\n        <select\n          value={config.columns}\n          onChange={(e) => onConfigChange({ columns: parseInt(e.target.value) })}\n          className=\"bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm text-white\"\n        >\n          {COLUMN_OPTIONS.map(col => (\n            <option key={col} value={col}>{col}</option>\n          ))}\n        </select>\n      </div>\n\n      {/* Display Format Toggle */}\n      <div className=\"flex items-center gap-1\">\n        <label className=\"text-xs text-gray-400\">Format:</label>\n        <div className=\"flex\">\n          {(['DEC', 'HEX'] as const).map(fmt => (\n            <button\n              key={fmt}\n              onClick={() => onConfigChange({ displayFormat: fmt })}\n              className={`px-2 py-1 text-xs first:rounded-l last:rounded-r ${\n                config.displayFormat === fmt\n                  ? 'bg-blue-600 text-white'\n                  : 'bg-gray-700 text-gray-300 hover:bg-gray-600'\n              }`}\n            >\n              {fmt}\n            </button>\n          ))}\n        </div>\n      </div>\n\n      {/* Spacer */}\n      <div className=\"flex-1\" />\n\n      {/* Refresh Button */}\n      <button\n        onClick={onRefresh}\n        disabled={isLoading}\n        className=\"flex items-center gap-1 px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm text-white disabled:opacity-50\"\n      >\n        <RefreshCw size={14} className={isLoading ? 'animate-spin' : ''} />\n        Refresh\n      </button>\n    </div>\n  );\n}\n```\n\nFeatures:\n- Memory type dropdown with Modbus address prefixes (0x, 1x, 3x, 4x)\n- Start address number input (0-65535)\n- Count input with reasonable limits (1-1000)\n- Column count selector with common options (1, 2, 4, 8, 10, 16)\n- DEC/HEX format toggle buttons\n- Refresh button with loading state indicator",
        "testStrategy": "1. Memory type change: Select 'Holding Registers', verify onConfigChange called with { memoryType: 'holding' }.\n2. Start address: Enter 100, verify onConfigChange called with { startAddress: 100 }.\n3. Count limits: Enter 2000, verify clamped to 1000.\n4. Column selection: Select 16 columns, verify onConfigChange called.\n5. Format toggle: Click HEX button, verify displayFormat changes.\n6. Refresh button: Click refresh, verify onRefresh called.\n7. Loading state: Set isLoading=true, verify refresh button disabled and icon spinning.",
        "priority": "medium",
        "dependencies": [
          "27"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create MemoryToolbar component with layout structure and UI elements",
            "description": "Implement the MemoryToolbar component with all visual elements including memory type dropdown with Modbus address prefixes, start address and count number inputs, column count selector dropdown, DEC/HEX format toggle buttons, and refresh button with loading spinner.",
            "dependencies": [],
            "details": "Create `src/components/MemoryVisualizer/MemoryToolbar.tsx` with the following structure:\n\n1. Define component interface `MemoryToolbarProps` with config, onConfigChange, onRefresh, and isLoading props\n2. Define constants for MEMORY_TYPE_OPTIONS array with Modbus prefixes (0x Coils, 1x Discrete Inputs, 3x Input Registers, 4x Holding Registers) and COLUMN_OPTIONS array [1, 2, 4, 8, 10, 16]\n3. Create flex container layout with gap-3 spacing and gray-800 background with bottom border\n4. Implement memory type selector with label and styled select element\n5. Implement start address input field (number type, 0-65535 range, w-20 width)\n6. Implement count input field (number type, 1-1000 range, w-20 width)\n7. Implement columns dropdown selector\n8. Create DEC/HEX toggle button group with active state styling (blue-600 for selected)\n9. Add flex-1 spacer element\n10. Implement refresh button with RefreshCw icon from lucide-react, animate-spin class when isLoading is true, and disabled state styling",
            "status": "done",
            "testStrategy": "Visual testing to verify all UI elements render correctly. Verify memory type dropdown shows all 4 Modbus types with correct prefixes. Check input fields have correct min/max attributes. Verify toggle buttons show correct active/inactive states. Test refresh button shows spinning animation when isLoading=true and is disabled.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:45:19.924Z"
          },
          {
            "id": 2,
            "title": "Implement input validation and change handlers for configuration updates",
            "description": "Add onChange handlers for all form controls that validate input values, enforce bounds constraints, and call onConfigChange with partial config updates.",
            "dependencies": [
              1
            ],
            "details": "Implement the following change handlers and validation logic:\n\n1. Memory type selector onChange: Cast e.target.value to MemoryType and call onConfigChange({ memoryType: value })\n2. Start address input onChange: Parse integer from input, default to 0 if NaN, call onConfigChange({ startAddress: parsedValue }). Browser enforces 0-65535 via min/max attributes\n3. Count input onChange: Parse integer, clamp value between 1 and 1000 using Math.min(1000, Math.max(1, value)), default to 1 if NaN, call onConfigChange({ count: clampedValue })\n4. Columns selector onChange: Parse integer and call onConfigChange({ columns: parsedValue })\n5. Display format toggle buttons onClick: Call onConfigChange({ displayFormat: 'DEC' }) or onConfigChange({ displayFormat: 'HEX' }) based on clicked button\n6. Refresh button onClick: Call onRefresh() callback, disable button when isLoading is true\n\nEnsure all handlers properly type their parameters using TypeScript types from MemoryType and DisplayFormat imports.",
            "status": "done",
            "testStrategy": "1. Memory type change: Select 'Holding Registers', verify onConfigChange called with { memoryType: 'holding' }\n2. Start address: Enter 100, verify onConfigChange called with { startAddress: 100 }\n3. Start address invalid: Enter 'abc', verify defaults to 0\n4. Count limits: Enter 2000, verify clamped to 1000 in onConfigChange call\n5. Count minimum: Enter 0 or negative, verify clamped to 1\n6. Column selection: Select 16 columns, verify onConfigChange called with { columns: 16 }\n7. Format toggle: Click HEX button, verify onConfigChange called with { displayFormat: 'HEX' }\n8. Refresh: Click refresh, verify onRefresh called. Verify button disabled when isLoading=true",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:45:19.938Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break down into: 1) Create MemoryToolbar component with layout structure containing memory type dropdown, address inputs, column selector, and format toggle. 2) Implement input validation and change handlers that call onConfigChange with partial updates.",
        "updatedAt": "2026-01-28T11:45:19.938Z"
      },
      {
        "id": "32",
        "title": "Implement Favorites Panel with CRUD Operations",
        "description": "Create a FavoritesPanel component for managing favorite memory addresses with custom labels, color coding, and multiple display formats. Include useFavorites hook for state management.",
        "details": "Create three files:\n\n1. `src/components/MemoryVisualizer/hooks/useFavorites.ts`:\n```typescript\nimport { useState, useCallback, useEffect } from 'react';\nimport type { FavoriteItem } from '../types';\n\nconst STORAGE_KEY = 'modone-memory-favorites';\n\nexport function useFavorites() {\n  const [favorites, setFavorites] = useState<FavoriteItem[]>([]);\n\n  // Load from localStorage on mount\n  useEffect(() => {\n    const stored = localStorage.getItem(STORAGE_KEY);\n    if (stored) {\n      try {\n        setFavorites(JSON.parse(stored));\n      } catch (e) {\n        console.error('Failed to parse favorites:', e);\n      }\n    }\n  }, []);\n\n  // Save to localStorage on change\n  useEffect(() => {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(favorites));\n  }, [favorites]);\n\n  const addFavorite = useCallback((item: Omit<FavoriteItem, 'id'>) => {\n    const newItem: FavoriteItem = {\n      ...item,\n      id: crypto.randomUUID(),\n    };\n    setFavorites(prev => [...prev, newItem]);\n    return newItem;\n  }, []);\n\n  const updateFavorite = useCallback((id: string, updates: Partial<Omit<FavoriteItem, 'id'>>) => {\n    setFavorites(prev => prev.map(item =>\n      item.id === id ? { ...item, ...updates } : item\n    ));\n  }, []);\n\n  const removeFavorite = useCallback((id: string) => {\n    setFavorites(prev => prev.filter(item => item.id !== id));\n  }, []);\n\n  const reorderFavorites = useCallback((fromIndex: number, toIndex: number) => {\n    setFavorites(prev => {\n      const updated = [...prev];\n      const [removed] = updated.splice(fromIndex, 1);\n      updated.splice(toIndex, 0, removed);\n      return updated;\n    });\n  }, []);\n\n  return {\n    favorites,\n    addFavorite,\n    updateFavorite,\n    removeFavorite,\n    reorderFavorites,\n  };\n}\n```\n\n2. `src/components/MemoryVisualizer/FavoriteItem.tsx`:\n```typescript\nimport { memo } from 'react';\nimport { GripVertical, Pencil, Trash2 } from 'lucide-react';\nimport type { FavoriteItem as FavoriteItemType, DisplayFormat } from './types';\nimport { formatValue } from './utils/formatters';\n\ninterface FavoriteItemProps {\n  item: FavoriteItemType;\n  currentValue: boolean | number | undefined;\n  onEdit: () => void;\n  onRemove: () => void;\n  onContextMenu: (e: React.MouseEvent) => void;\n  isDragging?: boolean;\n}\n\nexport const FavoriteItem = memo(function FavoriteItem({\n  item,\n  currentValue,\n  onEdit,\n  onRemove,\n  onContextMenu,\n  isDragging,\n}: FavoriteItemProps) {\n  const displayValue = currentValue !== undefined\n    ? (typeof currentValue === 'boolean'\n        ? (currentValue ? 'ON' : 'OFF')\n        : formatValue(currentValue as number, item.displayFormat))\n    : '--';\n\n  return (\n    <div\n      className={`flex items-center gap-2 p-2 bg-gray-800 rounded border border-gray-700 hover:border-gray-600 ${\n        isDragging ? 'opacity-50' : ''\n      }`}\n      onContextMenu={onContextMenu}\n    >\n      <GripVertical size={14} className=\"text-gray-500 cursor-grab\" />\n      \n      {item.color && (\n        <div className=\"w-3 h-3 rounded-full\" style={{ backgroundColor: item.color }} />\n      )}\n      \n      <div className=\"flex-1 min-w-0\">\n        <div className=\"text-sm text-white truncate\">{item.label}</div>\n        <div className=\"text-xs text-gray-400\">\n          {item.memoryType}:{item.address} • {item.displayFormat}\n        </div>\n      </div>\n      \n      <div className=\"text-sm font-mono text-green-400 w-20 text-right\">\n        {displayValue}\n      </div>\n      \n      <button onClick={onEdit} className=\"p-1 hover:bg-gray-700 rounded\">\n        <Pencil size={14} className=\"text-gray-400\" />\n      </button>\n      <button onClick={onRemove} className=\"p-1 hover:bg-gray-700 rounded\">\n        <Trash2 size={14} className=\"text-gray-400\" />\n      </button>\n    </div>\n  );\n});\n```\n\n3. `src/components/MemoryVisualizer/FavoritesPanel.tsx`:\n```typescript\nimport { useState } from 'react';\nimport { Star, Plus } from 'lucide-react';\nimport { useFavorites } from './hooks/useFavorites';\nimport { FavoriteItem } from './FavoriteItem';\nimport type { FavoriteItem as FavoriteItemType, ContextMenuPosition } from './types';\n\ninterface FavoritesPanelProps {\n  onNavigateToAddress: (memoryType: string, address: number) => void;\n  getValueForAddress: (memoryType: string, address: number) => boolean | number | undefined;\n  onContextMenu: (e: React.MouseEvent, item: FavoriteItemType, position: ContextMenuPosition) => void;\n}\n\nexport function FavoritesPanel({ onNavigateToAddress, getValueForAddress, onContextMenu }: FavoritesPanelProps) {\n  const { favorites, addFavorite, updateFavorite, removeFavorite, reorderFavorites } = useFavorites();\n  const [isExpanded, setIsExpanded] = useState(true);\n\n  return (\n    <div className=\"border-t border-gray-700\">\n      <button\n        onClick={() => setIsExpanded(!isExpanded)}\n        className=\"w-full flex items-center gap-2 p-2 hover:bg-gray-800\"\n      >\n        <Star size={14} className=\"text-yellow-500\" />\n        <span className=\"text-sm font-medium\">Favorites</span>\n        <span className=\"text-xs text-gray-500\">({favorites.length})</span>\n      </button>\n      \n      {isExpanded && (\n        <div className=\"p-2 space-y-1 max-h-48 overflow-y-auto\">\n          {favorites.length === 0 ? (\n            <p className=\"text-xs text-gray-500 text-center py-4\">\n              Right-click on a cell and select \"Add to Favorites\" to add items here.\n            </p>\n          ) : (\n            favorites.map((item, index) => (\n              <FavoriteItem\n                key={item.id}\n                item={item}\n                currentValue={getValueForAddress(item.memoryType, item.address)}\n                onEdit={() => {/* Open edit dialog */}}\n                onRemove={() => removeFavorite(item.id)}\n                onContextMenu={(e) => onContextMenu(e, item, { x: e.clientX, y: e.clientY })}\n              />\n            ))\n          )}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\nFor now, use localStorage for persistence. In a future task, Tauri commands will be added for proper file-based storage.",
        "testStrategy": "1. Add favorite: Call addFavorite with item data, verify item appears in list with generated ID.\n2. Remove favorite: Add item, call removeFavorite with ID, verify item removed.\n3. Update favorite: Add item, call updateFavorite to change label, verify label updated.\n4. Reorder: Add 3 items, call reorderFavorites(0, 2), verify first item now last.\n5. Persistence: Add favorite, reload page, verify favorite still present (localStorage).\n6. Value display: Mock getValueForAddress to return 1000, verify formatted value shown.\n7. Empty state: Render with no favorites, verify placeholder message displayed.\n8. Expand/collapse: Click header, verify panel collapses; click again, verify expands.",
        "priority": "medium",
        "dependencies": [
          "27",
          "28",
          "29"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create useFavorites hook with localStorage persistence",
            "description": "Implement the useFavorites custom hook that manages favorite memory addresses with full CRUD operations and localStorage persistence for data retention across sessions.",
            "dependencies": [],
            "details": "Create `src/components/MemoryVisualizer/hooks/useFavorites.ts` with the following implementation:\n\n1. **State Management**: Use useState for favorites array of FavoriteItem type\n\n2. **localStorage Persistence**:\n   - Load favorites from localStorage on mount using useEffect\n   - Save to localStorage whenever favorites change using another useEffect\n   - Use STORAGE_KEY = 'modone-memory-favorites'\n   - Handle JSON parse errors gracefully\n\n3. **CRUD Operations** (all wrapped in useCallback for memoization):\n   - `addFavorite(item: Omit<FavoriteItem, 'id'>)`: Generate UUID with crypto.randomUUID(), return new item\n   - `updateFavorite(id: string, updates: Partial<...>)`: Map and merge updates\n   - `removeFavorite(id: string)`: Filter out by ID\n   - `reorderFavorites(fromIndex: number, toIndex: number)`: Splice-based reordering for drag-drop\n\n4. **Return Object**: Export favorites array and all four operations\n\nEnsure FavoriteItem type is imported from '../types' (should include: id, label, address, memoryType, displayFormat, color).",
            "status": "done",
            "testStrategy": "Test addFavorite generates unique IDs and appends to list. Test updateFavorite modifies only specified fields. Test removeFavorite filters correctly. Test reorderFavorites moves items between indices. Test localStorage load on mount with valid/invalid JSON. Test localStorage save triggers on favorites change.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:46:46.135Z"
          },
          {
            "id": 2,
            "title": "Create FavoriteItem component with value display and actions",
            "description": "Build a memoized FavoriteItem component that displays a single favorite entry with its label, address info, real-time value, color indicator, and action buttons for editing and removal.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/MemoryVisualizer/FavoriteItem.tsx`:\n\n1. **Props Interface**:\n   - item: FavoriteItemType (the favorite data)\n   - currentValue: boolean | number | undefined (live value from memory)\n   - onEdit: () => void\n   - onRemove: () => void\n   - onContextMenu: (e: React.MouseEvent) => void\n   - isDragging?: boolean (for drag-drop visual feedback)\n\n2. **Value Formatting**:\n   - Boolean values: 'ON' or 'OFF'\n   - Numeric values: Use formatValue(value, displayFormat) from '../utils/formatters'\n   - Undefined: Display '--'\n\n3. **Visual Elements**:\n   - GripVertical icon for drag handle (cursor-grab)\n   - Color indicator dot (if item.color set)\n   - Label text (truncated)\n   - Address info: memoryType:address • displayFormat\n   - Formatted value (green-400, monospace)\n   - Edit button (Pencil icon)\n   - Remove button (Trash2 icon)\n\n4. **Styling**:\n   - Use Tailwind: bg-gray-800, border-gray-700, hover:border-gray-600\n   - Apply opacity-50 when isDragging\n\n5. **Memoization**: Wrap with memo() for performance",
            "status": "done",
            "testStrategy": "Test renders label and address correctly. Test boolean value displays ON/OFF. Test numeric value formatting with different displayFormat values. Test undefined value shows '--'. Test color indicator visibility. Test onEdit/onRemove callbacks fire on button clicks. Test isDragging applies opacity style.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:46:46.148Z"
          },
          {
            "id": 3,
            "title": "Create FavoritesPanel with collapsible section and empty state",
            "description": "Implement the FavoritesPanel container component that renders the collapsible favorites section, integrates the useFavorites hook, and handles the empty state display.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/components/MemoryVisualizer/FavoritesPanel.tsx`:\n\n1. **Props Interface**:\n   - onNavigateToAddress: (memoryType: string, address: number) => void\n   - getValueForAddress: (memoryType: string, address: number) => boolean | number | undefined\n   - onContextMenu: (e: React.MouseEvent, item: FavoriteItemType, position: ContextMenuPosition) => void\n\n2. **State Management**:\n   - Use useFavorites hook for favorites data and operations\n   - Local isExpanded state (default: true) for collapse/expand\n\n3. **Header Section**:\n   - Click to toggle expansion\n   - Star icon (yellow-500)\n   - 'Favorites' label\n   - Count badge showing (favorites.length)\n\n4. **Content Section** (when expanded):\n   - Max height 48 (max-h-48) with overflow-y-auto\n   - Empty state: Helpful text explaining how to add favorites via right-click\n   - Populated state: Map through favorites rendering FavoriteItem components\n\n5. **FavoriteItem Integration**:\n   - Pass currentValue from getValueForAddress(item.memoryType, item.address)\n   - Wire onRemove to removeFavorite(item.id)\n   - Wire onContextMenu to pass item and position\n   - onEdit placeholder (for future edit dialog)\n\n6. **Styling**: border-t border-gray-700 for top separator",
            "status": "done",
            "testStrategy": "Test initial expanded state renders favorites list. Test collapse/expand toggle hides/shows content. Test empty state message displays when no favorites. Test favorites count updates in header. Test FavoriteItem receives correct currentValue from getValueForAddress. Test onRemove removes item from list.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:46:46.158Z"
          },
          {
            "id": 4,
            "title": "Implement drag-and-drop reordering with @dnd-kit",
            "description": "Add drag-and-drop functionality to the FavoritesPanel using @dnd-kit library, enabling users to reorder their favorites by dragging items to new positions.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Enhance FavoritesPanel and FavoriteItem with @dnd-kit:\n\n1. **Install Check**: Verify @dnd-kit/core and @dnd-kit/sortable are in dependencies\n\n2. **FavoritesPanel Updates**:\n   - Import: DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors\n   - Import: SortableContext, verticalListSortingStrategy\n   - Wrap favorites list in DndContext and SortableContext\n   - Configure sensors: PointerSensor, KeyboardSensor with sortableKeyboardCoordinates\n   - Handle onDragEnd: Extract active.id and over.id, find indices, call reorderFavorites(oldIndex, newIndex)\n   - Pass items={favorites.map(f => f.id)} to SortableContext\n\n3. **Create SortableFavoriteItem Wrapper**:\n   - Use useSortable hook with id={item.id}\n   - Apply attributes, listeners to drag handle\n   - Apply transform and transition styles\n   - Pass isDragging to FavoriteItem\n\n4. **FavoriteItem Updates**:\n   - Accept dragHandleProps for GripVertical icon\n   - Apply {...dragHandleProps} to handle element\n\n5. **Accessibility**:\n   - Ensure keyboard navigation works\n   - Add aria-labels for drag handles\n\n6. **Visual Feedback**:\n   - Transform during drag\n   - Opacity change on dragging item\n   - Smooth transition animation",
            "status": "pending",
            "testStrategy": "Test drag handle initiates drag operation. Test dropping item at new position updates order. Test reorderFavorites called with correct indices. Test keyboard navigation for accessibility. Test visual feedback during drag (opacity, transform). Test order persists to localStorage after reorder.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create useFavorites hook with localStorage persistence, add/update/remove/reorder operations. 2) Create FavoriteItem component displaying label, address, current value, and action buttons. 3) Create FavoritesPanel component with collapsible section and empty state handling. 4) Implement drag-and-drop reordering functionality for favorites list.",
        "updatedAt": "2026-01-28T11:46:46.169Z"
      },
      {
        "id": "33",
        "title": "Implement Context Menus for Table Cells and Favorites",
        "description": "Create a reusable ContextMenu component and implement context menu options for table cells (Add to Favorites, Copy Address/Value, Set to 0/1) and favorite items (Edit Label, Change Color/Format, Move Up/Down, Remove).",
        "details": "Create `src/components/MemoryVisualizer/ContextMenu.tsx`:\n\n```typescript\nimport { useEffect, useRef } from 'react';\nimport { Star, Copy, ArrowUp, ArrowDown, Pencil, Palette, Hash, Trash2 } from 'lucide-react';\nimport type { ContextMenuPosition, CellSelection, FavoriteItem, DisplayFormat } from './types';\n\ninterface MenuItem {\n  label: string;\n  icon?: React.ReactNode;\n  onClick: () => void;\n  disabled?: boolean;\n  divider?: boolean;\n}\n\ninterface ContextMenuProps {\n  position: ContextMenuPosition;\n  onClose: () => void;\n  items: MenuItem[];\n}\n\nexport function ContextMenu({ position, onClose, items }: ContextMenuProps) {\n  const menuRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e: MouseEvent) => {\n      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {\n        onClose();\n      }\n    };\n    const handleEscape = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') onClose();\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    document.addEventListener('keydown', handleEscape);\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n      document.removeEventListener('keydown', handleEscape);\n    };\n  }, [onClose]);\n\n  // Adjust position if menu would go off-screen\n  const adjustedPosition = { ...position };\n  // (In real implementation, calculate based on menu size and viewport)\n\n  return (\n    <div\n      ref={menuRef}\n      className=\"fixed z-50 bg-gray-800 border border-gray-600 rounded-lg shadow-xl py-1 min-w-40\"\n      style={{ left: adjustedPosition.x, top: adjustedPosition.y }}\n    >\n      {items.map((item, index) => (\n        item.divider ? (\n          <hr key={index} className=\"border-gray-700 my-1\" />\n        ) : (\n          <button\n            key={index}\n            onClick={() => { item.onClick(); onClose(); }}\n            disabled={item.disabled}\n            className=\"w-full flex items-center gap-2 px-3 py-1.5 text-sm text-left hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed\"\n          >\n            {item.icon}\n            {item.label}\n          </button>\n        )\n      ))}\n    </div>\n  );\n}\n\n// Helper to build cell context menu items\nexport function buildCellMenuItems(\n  cell: CellSelection,\n  isReadOnly: boolean,\n  handlers: {\n    onAddToFavorites: () => void;\n    onCopyAddress: () => void;\n    onCopyValue: () => void;\n    onSetValue: (value: number) => void;\n  }\n): MenuItem[] {\n  const items: MenuItem[] = [\n    {\n      label: 'Add to Favorites',\n      icon: <Star size={14} className=\"text-yellow-500\" />,\n      onClick: handlers.onAddToFavorites,\n    },\n    { divider: true } as MenuItem,\n    {\n      label: 'Copy Address',\n      icon: <Copy size={14} />,\n      onClick: handlers.onCopyAddress,\n    },\n    {\n      label: 'Copy Value',\n      icon: <Copy size={14} />,\n      onClick: handlers.onCopyValue,\n    },\n  ];\n\n  if (!isReadOnly) {\n    items.push(\n      { divider: true } as MenuItem,\n      {\n        label: 'Set to 0',\n        icon: <Hash size={14} />,\n        onClick: () => handlers.onSetValue(0),\n      },\n      {\n        label: 'Set to 1',\n        icon: <Hash size={14} />,\n        onClick: () => handlers.onSetValue(1),\n      }\n    );\n  }\n\n  return items;\n}\n\n// Helper to build favorite item context menu\nexport function buildFavoriteMenuItems(\n  favorite: FavoriteItem,\n  handlers: {\n    onEditLabel: () => void;\n    onChangeColor: () => void;\n    onChangeFormat: (format: DisplayFormat) => void;\n    onMoveUp: () => void;\n    onMoveDown: () => void;\n    onRemove: () => void;\n  },\n  canMoveUp: boolean,\n  canMoveDown: boolean\n): MenuItem[] {\n  return [\n    {\n      label: 'Edit Label',\n      icon: <Pencil size={14} />,\n      onClick: handlers.onEditLabel,\n    },\n    {\n      label: 'Change Color',\n      icon: <Palette size={14} />,\n      onClick: handlers.onChangeColor,\n    },\n    { divider: true } as MenuItem,\n    {\n      label: 'Format: DEC',\n      onClick: () => handlers.onChangeFormat('DEC'),\n      disabled: favorite.displayFormat === 'DEC',\n    },\n    {\n      label: 'Format: HEX',\n      onClick: () => handlers.onChangeFormat('HEX'),\n      disabled: favorite.displayFormat === 'HEX',\n    },\n    {\n      label: 'Format: BINARY',\n      onClick: () => handlers.onChangeFormat('BINARY'),\n      disabled: favorite.displayFormat === 'BINARY',\n    },\n    { divider: true } as MenuItem,\n    {\n      label: 'Move Up',\n      icon: <ArrowUp size={14} />,\n      onClick: handlers.onMoveUp,\n      disabled: !canMoveUp,\n    },\n    {\n      label: 'Move Down',\n      icon: <ArrowDown size={14} />,\n      onClick: handlers.onMoveDown,\n      disabled: !canMoveDown,\n    },\n    { divider: true } as MenuItem,\n    {\n      label: 'Remove',\n      icon: <Trash2 size={14} className=\"text-red-400\" />,\n      onClick: handlers.onRemove,\n    },\n  ];\n}\n```",
        "testStrategy": "1. Menu positioning: Render at position {x: 100, y: 200}, verify menu appears at that location.\n2. Click outside: Click outside menu, verify onClose called.\n3. Escape key: Press Escape, verify menu closes.\n4. Menu item click: Click on item, verify onClick called and menu closes.\n5. Disabled item: Render with disabled item, verify cannot be clicked.\n6. Dividers: Verify dividers render as horizontal lines.\n7. Cell menu - Add to Favorites: Build cell menu, click 'Add to Favorites', verify handler called.\n8. Cell menu - Copy Address: Click 'Copy Address', verify clipboard updated.\n9. Cell menu - Read-only: Build menu for discrete input, verify 'Set to 0/1' not present.\n10. Favorite menu - Format change: Click 'Format: HEX', verify onChangeFormat called with 'HEX'.",
        "priority": "medium",
        "dependencies": [
          "27",
          "32"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Reusable ContextMenu Component with Positioning and Event Handling",
            "description": "Build the base ContextMenu component in `src/components/MemoryVisualizer/ContextMenu.tsx` with intelligent viewport-aware positioning, click-outside detection, keyboard navigation (Escape to close, arrow keys for navigation, Enter to select), and smooth animations.",
            "dependencies": [],
            "details": "Implement the ContextMenu component with the following features:\n\n1. **Viewport-Aware Positioning:**\n   - Calculate menu dimensions using `getBoundingClientRect()` after initial render\n   - Adjust position to prevent overflow beyond viewport boundaries\n   - Support anchor point configuration (top-left, top-right, etc.)\n\n2. **Event Handling:**\n   - Click-outside detection using `mousedown` event listener on document\n   - Escape key to close via `keydown` event listener\n   - Clean up all event listeners on unmount\n\n3. **Keyboard Navigation:**\n   - Arrow Up/Down to navigate between menu items\n   - Track focused item index in state\n   - Enter key to trigger focused item's onClick\n   - Skip disabled items and dividers during navigation\n\n4. **Component Structure:**\n   - Accept `MenuItem[]` prop with label, icon, onClick, disabled, divider fields\n   - Use `useRef` for menu container reference\n   - Render dividers as `<hr>` elements\n   - Apply focus styling to keyboard-navigated items\n\n5. **Styling:**\n   - Dark theme: `bg-gray-800 border-gray-600`\n   - Hover states: `hover:bg-gray-700`\n   - Disabled states: `opacity-50 cursor-not-allowed`\n   - Smooth fade-in animation on mount",
            "status": "done",
            "testStrategy": "1. Render menu at position {x: 100, y: 200}, verify element style matches position.\n2. Render menu near right edge (x: window.innerWidth - 50), verify menu repositions to stay within viewport.\n3. Click outside menu element, verify onClose callback is invoked.\n4. Press Escape key, verify onClose callback is invoked.\n5. Press ArrowDown, verify focus moves to first non-disabled item.\n6. Press ArrowDown multiple times, verify focus skips dividers and disabled items.\n7. Press Enter on focused item, verify item's onClick is called and menu closes.\n8. Mount and unmount component, verify no memory leaks from event listeners.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:47:51.433Z"
          },
          {
            "id": 2,
            "title": "Implement buildCellMenuItems Helper for Table Cell Context Menus",
            "description": "Create the `buildCellMenuItems` helper function that generates context menu items for memory table cells, including Add to Favorites, Copy Address/Value, and conditional Set to 0/1 options based on read-only status.",
            "dependencies": [
              1
            ],
            "details": "Implement the buildCellMenuItems function in `src/components/MemoryVisualizer/ContextMenu.tsx`:\n\n1. **Function Signature:**\n   ```typescript\n   export function buildCellMenuItems(\n     cell: CellSelection,\n     isReadOnly: boolean,\n     handlers: {\n       onAddToFavorites: () => void;\n       onCopyAddress: () => void;\n       onCopyValue: () => void;\n       onSetValue: (value: number) => void;\n     }\n   ): MenuItem[]\n   ```\n\n2. **Menu Items Structure:**\n   - 'Add to Favorites' with Star icon (yellow-500)\n   - Divider\n   - 'Copy Address' with Copy icon\n   - 'Copy Value' with Copy icon\n   - Conditional section (only if !isReadOnly):\n     - Divider\n     - 'Set to 0' with Hash icon\n     - 'Set to 1' with Hash icon\n\n3. **Icon Imports:**\n   - Use lucide-react icons: Star, Copy, Hash\n   - Icon size: 14px for consistency\n\n4. **Type Requirements:**\n   - Ensure MenuItem interface is properly exported\n   - CellSelection type should include address and current value\n   - All handler functions are required (not optional)\n\n5. **Integration Points:**\n   - Will be called from MemoryTable when right-clicking a cell\n   - Handlers will invoke clipboard API and Modbus write commands",
            "status": "done",
            "testStrategy": "1. Call buildCellMenuItems with isReadOnly=false, verify returned array contains 7 items (including 2 dividers).\n2. Call buildCellMenuItems with isReadOnly=true, verify returned array contains 4 items (no set value options).\n3. Verify 'Add to Favorites' item has correct Star icon and label.\n4. Click 'Copy Address' menu item, verify onCopyAddress handler is called.\n5. Click 'Set to 0' menu item, verify onSetValue handler is called with argument 0.\n6. Click 'Set to 1' menu item, verify onSetValue handler is called with argument 1.\n7. Verify divider items have divider: true property set.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:47:51.445Z"
          },
          {
            "id": 3,
            "title": "Implement buildFavoriteMenuItems Helper for Favorite Item Context Menus",
            "description": "Create the `buildFavoriteMenuItems` helper function that generates context menu items for favorite items, including Edit Label, Change Color, Format selection (DEC/HEX/BINARY), Move Up/Down, and Remove options with appropriate disabled states.",
            "dependencies": [
              1
            ],
            "details": "Implement the buildFavoriteMenuItems function in `src/components/MemoryVisualizer/ContextMenu.tsx`:\n\n1. **Function Signature:**\n   ```typescript\n   export function buildFavoriteMenuItems(\n     favorite: FavoriteItem,\n     handlers: {\n       onEditLabel: () => void;\n       onChangeColor: () => void;\n       onChangeFormat: (format: DisplayFormat) => void;\n       onMoveUp: () => void;\n       onMoveDown: () => void;\n       onRemove: () => void;\n     },\n     canMoveUp: boolean,\n     canMoveDown: boolean\n   ): MenuItem[]\n   ```\n\n2. **Menu Items Structure:**\n   - 'Edit Label' with Pencil icon\n   - 'Change Color' with Palette icon\n   - Divider\n   - 'Format: DEC' - disabled if current format is DEC\n   - 'Format: HEX' - disabled if current format is HEX\n   - 'Format: BINARY' - disabled if current format is BINARY\n   - Divider\n   - 'Move Up' with ArrowUp icon - disabled if canMoveUp=false\n   - 'Move Down' with ArrowDown icon - disabled if canMoveDown=false\n   - Divider\n   - 'Remove' with Trash2 icon (red-400)\n\n3. **Icon Imports:**\n   - Use lucide-react: Pencil, Palette, ArrowUp, ArrowDown, Trash2\n   - Trash2 should have text-red-400 class for visual warning\n\n4. **Disabled State Logic:**\n   - Format items disabled based on `favorite.displayFormat` comparison\n   - Move items disabled based on canMoveUp/canMoveDown boolean props\n\n5. **Type Requirements:**\n   - DisplayFormat type: 'DEC' | 'HEX' | 'BINARY'\n   - FavoriteItem must include displayFormat property",
            "status": "done",
            "testStrategy": "1. Call buildFavoriteMenuItems with favorite.displayFormat='HEX', verify 'Format: HEX' item has disabled=true.\n2. Call with canMoveUp=false, verify 'Move Up' item has disabled=true.\n3. Call with canMoveDown=false, verify 'Move Down' item has disabled=true.\n4. Click 'Edit Label', verify onEditLabel handler is called.\n5. Click 'Format: DEC', verify onChangeFormat is called with 'DEC' argument.\n6. Verify 'Remove' item has Trash2 icon with red-400 styling.\n7. Call with canMoveUp=true, canMoveDown=true, verify both move items are enabled.\n8. Verify total of 12 items returned (9 actions + 3 dividers).",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:47:51.457Z"
          },
          {
            "id": 4,
            "title": "Add Clipboard Operations and Modbus Write Command Integration",
            "description": "Implement clipboard operations using the navigator.clipboard API for copying addresses and values, and integrate Modbus write commands for setting cell values through Tauri invoke calls with proper error handling and user feedback.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement clipboard and Modbus integrations:\n\n1. **Clipboard Operations (create `src/components/MemoryVisualizer/utils/clipboard.ts`):**\n   ```typescript\n   export async function copyToClipboard(text: string): Promise<boolean> {\n     try {\n       await navigator.clipboard.writeText(text);\n       return true;\n     } catch (error) {\n       console.error('Failed to copy to clipboard:', error);\n       return false;\n     }\n   }\n   \n   export function formatAddressForCopy(address: number, type: 'coil' | 'discrete' | 'holding' | 'input'): string {\n     // Format as standard Modbus notation (e.g., 40001 for holding register 0)\n   }\n   \n   export function formatValueForCopy(value: number, format: DisplayFormat): string {\n     // Format value based on display format\n   }\n   ```\n\n2. **Modbus Write Integration:**\n   - Use existing Tauri invoke for `modbus_write_register` or `modbus_write_coil`\n   - Handle async operation with loading state\n   - Display toast notification on success/failure\n   - Validate value range before write (coils: 0/1, registers: 0-65535)\n\n3. **Integration in MemoryTable:**\n   - Wire up context menu handlers to clipboard/Modbus functions\n   - Show toast feedback: 'Address copied to clipboard', 'Value set successfully'\n   - Handle errors gracefully with user-friendly messages\n\n4. **Error Handling:**\n   - Clipboard API may fail in insecure contexts (non-HTTPS)\n   - Modbus write may fail due to connection issues or permissions\n   - Wrap async operations in try-catch blocks\n\n5. **Type Safety:**\n   - Ensure proper typing for Tauri invoke responses\n   - Use existing error handling patterns from project",
            "status": "done",
            "testStrategy": "1. Mock navigator.clipboard.writeText, call copyToClipboard, verify text is written.\n2. Test copyToClipboard with rejected promise, verify returns false and logs error.\n3. Test formatAddressForCopy with holding register address 0, verify returns '40001'.\n4. Test formatValueForCopy with value 255 and format 'HEX', verify returns '0xFF'.\n5. Mock Tauri invoke, call Modbus write handler, verify correct command is invoked.\n6. Test Modbus write with network error, verify error toast is shown.\n7. Integration test: right-click cell -> Copy Address -> verify clipboard contains formatted address.\n8. Integration test: right-click cell -> Set to 0 -> verify Modbus write command sent with value 0.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:47:51.469Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create reusable ContextMenu component with positioning, click-outside handling, and keyboard navigation. 2) Implement buildCellMenuItems helper function generating menu items for table cells. 3) Implement buildFavoriteMenuItems helper function generating menu items for favorites. 4) Add clipboard operations (navigator.clipboard API) and Modbus write integrations.",
        "updatedAt": "2026-01-28T11:47:51.469Z"
      },
      {
        "id": "34",
        "title": "Assemble Main MemoryVisualizer Panel Component",
        "description": "Create the main MemoryVisualizer component that assembles all sub-components (Toolbar, MemoryTable, Favorites, Context Menus) and manages state coordination between them, including real-time memory updates.",
        "details": "Update `src/components/panels/content/MemoryVisualizerPanel.tsx` to be the full implementation:\n\n```typescript\nimport { useState, useCallback, useMemo } from 'react';\nimport { MemoryToolbar } from '../../MemoryVisualizer/MemoryToolbar';\nimport { MemoryTable } from '../../MemoryVisualizer/MemoryTable';\nimport { FavoritesPanel } from '../../MemoryVisualizer/FavoritesPanel';\nimport { NumberInputPopover } from '../../MemoryVisualizer/NumberInputPopover';\nimport { ContextMenu, buildCellMenuItems, buildFavoriteMenuItems } from '../../MemoryVisualizer/ContextMenu';\nimport { useFavorites } from '../../MemoryVisualizer/hooks/useFavorites';\nimport { useModbusMemory } from '../../../hooks/useModbusMemory';\nimport { modbusService } from '../../../services/modbusService';\nimport type { MemoryViewConfig, CellSelection, ContextMenuPosition, FavoriteItem, DisplayFormat } from '../../MemoryVisualizer/types';\nimport type { MemoryType } from '../../../types/modbus';\n\nconst DEFAULT_CONFIG: MemoryViewConfig = {\n  memoryType: 'holding',\n  startAddress: 0,\n  count: 100,\n  columns: 8,\n  displayFormat: 'DEC',\n};\n\nexport function MemoryVisualizerPanel() {\n  const [config, setConfig] = useState<MemoryViewConfig>(DEFAULT_CONFIG);\n  \n  // Memory data subscription\n  const { values, isLoading, error, refresh } = useModbusMemory(\n    config.memoryType,\n    config.startAddress,\n    config.count\n  );\n\n  // Favorites management\n  const { favorites, addFavorite, updateFavorite, removeFavorite, reorderFavorites } = useFavorites();\n\n  // Popover state\n  const [popoverState, setPopoverState] = useState<{\n    isOpen: boolean;\n    address: number;\n    value: number;\n    position: { x: number; y: number };\n  } | null>(null);\n\n  // Context menu state\n  const [contextMenu, setContextMenu] = useState<{\n    position: ContextMenuPosition;\n    type: 'cell' | 'favorite';\n    cell?: CellSelection;\n    favorite?: FavoriteItem;\n  } | null>(null);\n\n  // Handle config changes\n  const handleConfigChange = useCallback((updates: Partial<MemoryViewConfig>) => {\n    setConfig(prev => ({ ...prev, ...updates }));\n  }, []);\n\n  // Handle cell click (for editing)\n  const handleCellClick = useCallback((address: number, value: boolean | number) => {\n    const isBoolean = config.memoryType === 'coil' || config.memoryType === 'discrete';\n    \n    if (isBoolean) {\n      // Toggle coil directly\n      if (config.memoryType === 'coil') {\n        modbusService.writeCoil(address, !(value as boolean));\n      }\n    } else {\n      // Open number input popover for registers\n      if (config.memoryType === 'holding') {\n        setPopoverState({\n          isOpen: true,\n          address,\n          value: value as number,\n          position: { x: window.innerWidth / 2 - 150, y: window.innerHeight / 2 - 200 },\n        });\n      }\n    }\n  }, [config.memoryType]);\n\n  // Handle cell context menu\n  const handleCellContextMenu = useCallback((e: React.MouseEvent, address: number, value: boolean | number) => {\n    e.preventDefault();\n    setContextMenu({\n      position: { x: e.clientX, y: e.clientY },\n      type: 'cell',\n      cell: { memoryType: config.memoryType, address, value },\n    });\n  }, [config.memoryType]);\n\n  // Apply register value from popover\n  const handleApplyValue = useCallback(async (value: number) => {\n    if (popoverState && config.memoryType === 'holding') {\n      await modbusService.writeHoldingRegister(popoverState.address, value);\n    }\n    setPopoverState(null);\n  }, [popoverState, config.memoryType]);\n\n  // Determine if current memory type is read-only\n  const isReadOnly = config.memoryType === 'discrete' || config.memoryType === 'input';\n\n  // Get value for favorites display\n  const getValueForAddress = useCallback((memoryType: string, address: number) => {\n    if (memoryType === config.memoryType && address >= config.startAddress && address < config.startAddress + config.count) {\n      return values[address - config.startAddress];\n    }\n    return undefined;\n  }, [config, values]);\n\n  return (\n    <div className=\"h-full flex flex-col bg-gray-900 text-white\">\n      <MemoryToolbar\n        config={config}\n        onConfigChange={handleConfigChange}\n        onRefresh={refresh}\n        isLoading={isLoading}\n      />\n      \n      {error && (\n        <div className=\"px-3 py-2 bg-red-900/50 text-red-300 text-sm\">\n          {error}\n        </div>\n      )}\n      \n      <div className=\"flex-1 overflow-hidden\">\n        <MemoryTable\n          memoryType={config.memoryType}\n          startAddress={config.startAddress}\n          values={values}\n          columns={config.columns}\n          displayFormat={config.displayFormat}\n          isReadOnly={isReadOnly}\n          onCellClick={handleCellClick}\n          onCellContextMenu={handleCellContextMenu}\n        />\n      </div>\n      \n      <FavoritesPanel\n        onNavigateToAddress={(type, addr) => handleConfigChange({ memoryType: type as MemoryType, startAddress: addr })}\n        getValueForAddress={getValueForAddress}\n        onContextMenu={(e, item, pos) => setContextMenu({ position: pos, type: 'favorite', favorite: item })}\n      />\n      \n      {/* Number Input Popover */}\n      {popoverState && (\n        <NumberInputPopover\n          initialValue={popoverState.value}\n          address={popoverState.address}\n          onApply={handleApplyValue}\n          onCancel={() => setPopoverState(null)}\n          position={popoverState.position}\n        />\n      )}\n      \n      {/* Context Menu */}\n      {contextMenu && (\n        <ContextMenu\n          position={contextMenu.position}\n          onClose={() => setContextMenu(null)}\n          items={contextMenu.type === 'cell' && contextMenu.cell\n            ? buildCellMenuItems(contextMenu.cell, isReadOnly, {\n                onAddToFavorites: () => addFavorite({\n                  memoryType: contextMenu.cell!.memoryType,\n                  address: contextMenu.cell!.address,\n                  label: `${contextMenu.cell!.memoryType}:${contextMenu.cell!.address}`,\n                  displayFormat: config.displayFormat,\n                }),\n                onCopyAddress: () => navigator.clipboard.writeText(String(contextMenu.cell!.address)),\n                onCopyValue: () => navigator.clipboard.writeText(String(contextMenu.cell!.value)),\n                onSetValue: (val) => {\n                  if (config.memoryType === 'coil') {\n                    modbusService.writeCoil(contextMenu.cell!.address, val === 1);\n                  } else if (config.memoryType === 'holding') {\n                    modbusService.writeHoldingRegister(contextMenu.cell!.address, val);\n                  }\n                },\n              })\n            : contextMenu.favorite\n              ? buildFavoriteMenuItems(contextMenu.favorite, {\n                  onEditLabel: () => {/* TODO: Open edit dialog */},\n                  onChangeColor: () => {/* TODO: Open color picker */},\n                  onChangeFormat: (fmt) => updateFavorite(contextMenu.favorite!.id, { displayFormat: fmt }),\n                  onMoveUp: () => {/* TODO: Implement */},\n                  onMoveDown: () => {/* TODO: Implement */},\n                  onRemove: () => removeFavorite(contextMenu.favorite!.id),\n                }, false, false)\n              : []\n          }\n        />\n      )}\n    </div>\n  );\n}\n```\n\nThis component:\n- Coordinates all sub-components\n- Manages view configuration state\n- Subscribes to real-time memory updates via useModbusMemory hook\n- Handles cell interactions (click for edit, right-click for context menu)\n- Integrates favorites panel with memory display\n- Shows error states from memory operations",
        "testStrategy": "1. Initial render: Mount component, verify toolbar, empty table, and favorites panel render.\n2. Memory type switch: Change to 'coil', verify table re-fetches coil data.\n3. Coil toggle: Click on coil cell, verify writeCoil called with toggled value.\n4. Register edit: Click on holding register cell, verify popover opens with current value.\n5. Popover apply: Enter new value in popover, click Apply, verify writeHoldingRegister called.\n6. Real-time update: Simulate memory change event, verify table cell updates.\n7. Context menu - Add to Favorites: Right-click cell, select 'Add to Favorites', verify item appears in favorites panel.\n8. Context menu - Copy: Right-click, select 'Copy Value', verify clipboard contains value.\n9. Error display: Mock service to throw error, verify error message shown.\n10. Read-only mode: Switch to 'discrete' or 'input', verify cells are not clickable.",
        "priority": "high",
        "dependencies": [
          "28",
          "29",
          "30",
          "31",
          "32",
          "33"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up component structure with state management",
            "description": "Create the MemoryVisualizerPanel component skeleton with all necessary state hooks for config, popover, and context menu management.",
            "dependencies": [],
            "details": "Update `src/components/panels/content/MemoryVisualizerPanel.tsx` with:\n1. Import all required dependencies: useState, useCallback from React\n2. Import sub-components: MemoryToolbar, MemoryTable, FavoritesPanel, NumberInputPopover, ContextMenu, buildCellMenuItems, buildFavoriteMenuItems\n3. Import hooks: useFavorites, useModbusMemory\n4. Import services: modbusService\n5. Import types: MemoryViewConfig, CellSelection, ContextMenuPosition, FavoriteItem, DisplayFormat, MemoryType\n6. Define DEFAULT_CONFIG constant with memoryType: 'holding', startAddress: 0, count: 100, columns: 8, displayFormat: 'DEC'\n7. Set up useState for config (MemoryViewConfig)\n8. Set up useState for popoverState ({ isOpen, address, value, position } | null)\n9. Set up useState for contextMenu ({ position, type, cell?, favorite? } | null)\n10. Create handleConfigChange callback using useCallback",
            "status": "done",
            "testStrategy": "Verify component mounts without errors. Test that useState hooks initialize with correct default values. Verify DEFAULT_CONFIG matches expected structure. Test handleConfigChange updates config state correctly with partial updates.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:50:52.002Z"
          },
          {
            "id": 2,
            "title": "Integrate useModbusMemory hook for real-time data",
            "description": "Wire up the useModbusMemory hook to subscribe to memory data based on current configuration and handle loading/error states.",
            "dependencies": [
              1
            ],
            "details": "Add real-time memory data integration:\n1. Call useModbusMemory hook with config.memoryType, config.startAddress, config.count\n2. Destructure returned values: values, isLoading, error, refresh\n3. Create isReadOnly computed value: true if memoryType is 'discrete' or 'input'\n4. Create getValueForAddress callback that returns the value for a given memoryType and address from the values array, returning undefined if outside the current view range\n5. Pass isLoading to MemoryToolbar for loading indicator\n6. Pass refresh function to MemoryToolbar for manual refresh button\n7. Add error display JSX: conditional div with red background showing error message when error is truthy",
            "status": "done",
            "testStrategy": "Mock useModbusMemory hook. Verify hook is called with correct parameters when config changes. Test that memory type switch triggers re-fetch. Verify error state displays error message. Test refresh function is passed and callable. Verify isReadOnly computation for all 4 memory types.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:50:52.014Z"
          },
          {
            "id": 3,
            "title": "Implement cell click handling for coil toggle and register edit",
            "description": "Create handleCellClick callback that distinguishes between boolean memory types (coil toggle) and numeric types (opens number input popover).",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement handleCellClick callback:\n1. Accept address (number) and value (boolean | number) parameters\n2. Determine if current memoryType is boolean: config.memoryType === 'coil' || config.memoryType === 'discrete'\n3. For boolean types:\n   - If memoryType is 'coil', call modbusService.writeCoil(address, !value) to toggle\n   - Discrete inputs are read-only, so no action needed\n4. For numeric types (holding/input registers):\n   - If memoryType is 'holding', open NumberInputPopover by setting popoverState with isOpen: true, address, value, and centered position\n   - Input registers are read-only, so no action needed\n5. Create handleApplyValue callback for popover:\n   - If popoverState exists and memoryType is 'holding', call modbusService.writeHoldingRegister\n   - Close popover by setting popoverState to null\n6. Wrap both callbacks in useCallback with appropriate dependencies",
            "status": "done",
            "testStrategy": "Test coil cell click calls writeCoil with toggled value. Test discrete input click does nothing (read-only). Test holding register click opens popover with correct initial value and address. Test input register click does nothing (read-only). Test handleApplyValue writes to holding register and closes popover.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:50:52.025Z"
          },
          {
            "id": 4,
            "title": "Implement context menu handling with favorites integration",
            "description": "Create handleCellContextMenu callback and wire up context menu actions including Add to Favorites, copy operations, and write value operations.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement context menu functionality:\n1. Create handleCellContextMenu callback:\n   - Prevent default browser context menu\n   - Set contextMenu state with position (clientX, clientY), type: 'cell', and cell data (memoryType, address, value)\n2. Initialize useFavorites hook to get favorites, addFavorite, updateFavorite, removeFavorite, reorderFavorites\n3. Build cell context menu items using buildCellMenuItems with handlers:\n   - onAddToFavorites: call addFavorite with memoryType, address, default label, and current displayFormat\n   - onCopyAddress: use navigator.clipboard.writeText with address\n   - onCopyValue: use navigator.clipboard.writeText with value\n   - onSetValue: write to modbusService based on memoryType (writeCoil for coil, writeHoldingRegister for holding)\n4. Build favorite context menu items using buildFavoriteMenuItems with handlers:\n   - onEditLabel: placeholder TODO for edit dialog\n   - onChangeColor: placeholder TODO for color picker\n   - onChangeFormat: call updateFavorite with new displayFormat\n   - onMoveUp/onMoveDown: placeholder TODO for reordering\n   - onRemove: call removeFavorite\n5. Pass isReadOnly to disable write operations for read-only memory types",
            "status": "done",
            "testStrategy": "Test right-click on cell opens context menu at correct position. Test Add to Favorites creates favorite with correct data. Test copy operations write to clipboard. Test Set Value calls appropriate modbusService method. Test favorite context menu actions update/remove favorites. Verify read-only types disable write menu items.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:50:52.037Z"
          },
          {
            "id": 5,
            "title": "Wire up all sub-components with proper data flow",
            "description": "Render and connect all sub-components (Toolbar, Table, Favorites, Popover, ContextMenu) with correct props and establish complete data flow between them.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Complete the component JSX structure:\n1. Root container: div with h-full flex flex-col bg-gray-900 text-white\n2. MemoryToolbar: pass config, onConfigChange (handleConfigChange), onRefresh (refresh), isLoading\n3. Error display: conditional div with error styling when error exists\n4. Main content area: div with flex-1 overflow-hidden containing MemoryTable\n5. MemoryTable: pass memoryType, startAddress, values, columns, displayFormat, isReadOnly, onCellClick, onCellContextMenu\n6. FavoritesPanel: pass onNavigateToAddress (calls handleConfigChange with type and address), getValueForAddress, onContextMenu handler\n7. NumberInputPopover (conditional): render when popoverState is truthy, pass initialValue, address, onApply, onCancel, position\n8. ContextMenu (conditional): render when contextMenu is truthy, pass position, onClose, and items built from buildCellMenuItems or buildFavoriteMenuItems based on context type\n9. Ensure all callbacks are memoized with useCallback to prevent unnecessary re-renders",
            "status": "done",
            "testStrategy": "Integration test: verify complete component renders all sub-components. Test toolbar config changes propagate to table. Test favorites panel navigation updates config. Test popover renders on holding register click and closes on apply/cancel. Test context menu renders on right-click and closes on selection or outside click. E2E test complete user workflow: change memory type, click cell, add to favorites, verify favorite displays current value.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T11:50:52.054Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Set up component structure with state management for config, popover, and context menu. 2) Integrate useModbusMemory hook for real-time memory data subscription. 3) Implement cell click handling distinguishing between coil toggle and register edit. 4) Implement context menu handling with Add to Favorites and write operations. 5) Wire up all sub-components (Toolbar, Table, Favorites, Popover, ContextMenu) with proper data flow.",
        "updatedAt": "2026-01-28T11:50:52.054Z"
      },
      {
        "id": "35",
        "title": "Define OneCanvas Type System and Data Structures",
        "description": "Create TypeScript types and interfaces for all OneCanvas data structures including components, wires, ports, simulation state, and the YAML circuit schema.",
        "details": "Create `src/components/OneCanvas/types.ts` with:\n\n1. **Block Types:**\n```typescript\ntype BlockType = 'power_24v' | 'power_12v' | 'gnd' | 'plc_out' | 'plc_in' | 'led' | 'button' | 'scope';\n\ninterface Position { x: number; y: number; }\n\ninterface Port {\n  id: string;\n  type: 'input' | 'output' | 'bidirectional';\n  label: string;\n  position: 'top' | 'bottom' | 'left' | 'right';\n}\n\ninterface BaseBlock {\n  id: string;\n  type: BlockType;\n  position: Position;\n  ports: Port[];\n  selected?: boolean;\n}\n```\n\n2. **Specialized Block Properties:**\n- `PlcOutBlockProps`: address, normallyOpen, inverted\n- `PlcInBlockProps`: address, thresholdVoltage, inverted  \n- `LedBlockProps`: color ('red'|'green'|'blue'|'yellow'|'white'), forwardVoltage\n- `ButtonBlockProps`: momentary/stationary, contactConfig ('1a'|'1b'|'1a1b'|'2a'|'2b'|'2a2b'|'3a3b')\n- `ScopeBlockProps`: channels (1-4), triggerMode, timeBase\n\n3. **Wire Types:**\n```typescript\ninterface WireEndpoint { componentId: string; portId: string; }\ninterface Wire { id: string; from: WireEndpoint; to: WireEndpoint; }\n```\n\n4. **Circuit State:**\n```typescript\ninterface CircuitState {\n  components: Map<string, Block>;\n  wires: Wire[];\n  metadata: { name: string; description: string; tags: string[]; };\n}\n```\n\n5. **Simulation State:**\n```typescript\ninterface SimulationState {\n  running: boolean;\n  voltages: Map<string, number>; // portId -> voltage\n  currentPaths: string[][]; // arrays of connected port IDs\n}\n```\n\n6. **YAML Schema Types** matching the PRD's circuit.yaml format for serialization.",
        "testStrategy": "Unit tests validating type guards, discriminated unions work correctly, and all block types can be instantiated with required properties. Test that the types are compatible with the YAML schema through round-trip serialization.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Base Block Types and Discriminated Union",
            "description": "Create the foundational type definitions including BlockType literal union, Position interface, Port interface, and BaseBlock interface with discriminated union pattern for type-safe block handling.",
            "dependencies": [],
            "details": "Create `src/components/OneCanvas/types.ts` and define:\n\n1. **BlockType literal union:**\n```typescript\nexport type BlockType = 'power_24v' | 'power_12v' | 'gnd' | 'plc_out' | 'plc_in' | 'led' | 'button' | 'scope';\n```\n\n2. **Position interface:**\n```typescript\nexport interface Position {\n  x: number;\n  y: number;\n}\n```\n\n3. **Port interface:**\n```typescript\nexport type PortType = 'input' | 'output' | 'bidirectional';\nexport type PortPosition = 'top' | 'bottom' | 'left' | 'right';\n\nexport interface Port {\n  id: string;\n  type: PortType;\n  label: string;\n  position: PortPosition;\n}\n```\n\n4. **BaseBlock interface:**\n```typescript\nexport interface BaseBlock<T extends BlockType = BlockType> {\n  id: string;\n  type: T;\n  position: Position;\n  ports: Port[];\n  selected?: boolean;\n  label?: string;\n}\n```\n\nEnsure proper exports and JSDoc comments for documentation.",
            "status": "pending",
            "testStrategy": "Write unit tests verifying: 1) BlockType union accepts only valid block type strings, 2) Position interface requires x and y as numbers, 3) Port interface validates all required fields, 4) BaseBlock generic type constraint works correctly with discriminated unions.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define Specialized Block Property Interfaces",
            "description": "Create TypeScript interfaces for each specialized block type extending BaseBlock with their unique properties including PlcOutBlock, PlcInBlock, LedBlock, ButtonBlock, and ScopeBlock.",
            "dependencies": [
              1
            ],
            "details": "Add specialized block interfaces to `src/components/OneCanvas/types.ts`:\n\n1. **PlcOutBlock:**\n```typescript\nexport interface PlcOutBlock extends BaseBlock<'plc_out'> {\n  address: string;          // e.g., 'Y:0x0010'\n  normallyOpen: boolean;\n  inverted: boolean;\n}\n```\n\n2. **PlcInBlock:**\n```typescript\nexport interface PlcInBlock extends BaseBlock<'plc_in'> {\n  address: string;          // e.g., 'X:0x0000'\n  thresholdVoltage: number; // default 12V\n  inverted: boolean;\n}\n```\n\n3. **LedBlock:**\n```typescript\nexport type LedColor = 'red' | 'green' | 'blue' | 'yellow' | 'white';\n\nexport interface LedBlock extends BaseBlock<'led'> {\n  color: LedColor;\n  forwardVoltage: number;   // typical 2.0V for red, 3.0V for blue/white\n}\n```\n\n4. **ButtonBlock:**\n```typescript\nexport type ButtonMode = 'momentary' | 'stationary';\nexport type ContactConfig = '1a' | '1b' | '1a1b' | '2a' | '2b' | '2a2b' | '3a3b';\n\nexport interface ButtonBlock extends BaseBlock<'button'> {\n  mode: ButtonMode;\n  contactConfig: ContactConfig;\n  pressed?: boolean;\n}\n```\n\n5. **ScopeBlock:**\n```typescript\nexport type TriggerMode = 'auto' | 'normal' | 'single';\n\nexport interface ScopeBlock extends BaseBlock<'scope'> {\n  channels: 1 | 2 | 3 | 4;\n  triggerMode: TriggerMode;\n  timeBase: number;         // ms per division\n}\n```\n\n6. **Power and Ground blocks:**\n```typescript\nexport interface Power24vBlock extends BaseBlock<'power_24v'> {}\nexport interface Power12vBlock extends BaseBlock<'power_12v'> {}\nexport interface GndBlock extends BaseBlock<'gnd'> {}\n```\n\n7. **Block discriminated union:**\n```typescript\nexport type Block = \n  | Power24vBlock\n  | Power12vBlock\n  | GndBlock\n  | PlcOutBlock\n  | PlcInBlock\n  | LedBlock\n  | ButtonBlock\n  | ScopeBlock;\n```",
            "status": "pending",
            "testStrategy": "Write unit tests verifying: 1) Each specialized block type correctly narrows the discriminated union, 2) Type guards work for each block type (e.g., `isLedBlock(block)`), 3) All required properties are enforced by TypeScript, 4) Optional properties like `pressed` on ButtonBlock work correctly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Define Wire and Circuit State Types",
            "description": "Create TypeScript interfaces for wire connections including WireEndpoint, Wire, and the overall CircuitState that holds the complete circuit diagram data structure.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add wire and circuit state types to `src/components/OneCanvas/types.ts`:\n\n1. **WireEndpoint interface:**\n```typescript\nexport interface WireEndpoint {\n  componentId: string;  // References Block.id\n  portId: string;       // References Port.id\n}\n```\n\n2. **Wire interface:**\n```typescript\nexport interface Wire {\n  id: string;\n  from: WireEndpoint;\n  to: WireEndpoint;\n  selected?: boolean;\n  color?: string;       // Optional wire color for visual grouping\n}\n```\n\n3. **Circuit metadata:**\n```typescript\nexport interface CircuitMetadata {\n  name: string;\n  description: string;\n  tags: string[];\n  author?: string;\n  createdAt?: string;   // ISO date string\n  modifiedAt?: string;  // ISO date string\n  version?: string;\n}\n```\n\n4. **CircuitState interface:**\n```typescript\nexport interface CircuitState {\n  components: Map<string, Block>;  // blockId -> Block\n  wires: Wire[];\n  metadata: CircuitMetadata;\n  selectedIds?: Set<string>;       // Selected component/wire IDs\n  viewport?: {\n    zoom: number;\n    panX: number;\n    panY: number;\n  };\n}\n```\n\n5. **Helper types for serialization (Map doesn't serialize to JSON directly):**\n```typescript\nexport interface SerializableCircuitState {\n  components: Record<string, Block>;\n  wires: Wire[];\n  metadata: CircuitMetadata;\n}\n```\n\n6. **Add utility type for creating new circuits:**\n```typescript\nexport type NewCircuitState = Omit<CircuitState, 'components'> & {\n  components: Map<string, Block>;\n};\n```",
            "status": "pending",
            "testStrategy": "Write unit tests verifying: 1) WireEndpoint correctly references valid component and port IDs, 2) CircuitState can store and retrieve Block instances by ID, 3) Serialization helpers convert Map to Record and back correctly, 4) Wire connections can be validated against existing components.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Define Simulation State and YAML Schema Types",
            "description": "Create TypeScript interfaces for simulation runtime state including voltage tracking and current paths, plus YAML-compatible schema types for circuit file serialization matching the PRD format.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add simulation and YAML schema types to `src/components/OneCanvas/types.ts`:\n\n1. **SimulationState interface:**\n```typescript\nexport interface SimulationState {\n  running: boolean;\n  paused?: boolean;\n  stepMode?: boolean;\n  voltages: Map<string, number>;      // portId -> voltage in volts\n  currents: Map<string, number>;      // wireId -> current in amps\n  currentPaths: string[][];           // Arrays of connected port IDs forming complete circuits\n  simulationTime: number;             // Current simulation time in ms\n  tickRate: number;                   // Simulation ticks per second\n}\n```\n\n2. **Serializable simulation state:**\n```typescript\nexport interface SerializableSimulationState {\n  running: boolean;\n  voltages: Record<string, number>;\n  currents: Record<string, number>;\n  currentPaths: string[][];\n  simulationTime: number;\n}\n```\n\n3. **YAML Circuit Schema types (matching PRD format):**\n```typescript\nexport interface YamlBlockDefinition {\n  id: string;\n  type: BlockType;\n  position: { x: number; y: number };\n  properties?: Record<string, unknown>;  // Block-specific properties\n  ports?: Array<{\n    id: string;\n    type: string;\n    label: string;\n    position: string;\n  }>;\n}\n\nexport interface YamlWireDefinition {\n  id: string;\n  from: { component: string; port: string };\n  to: { component: string; port: string };\n}\n\nexport interface YamlCircuitSchema {\n  version: string;          // Schema version for migrations\n  metadata: {\n    name: string;\n    description: string;\n    tags: string[];\n    created?: string;\n    modified?: string;\n  };\n  components: YamlBlockDefinition[];\n  wires: YamlWireDefinition[];\n}\n```\n\n4. **Add type guards and conversion utilities:**\n```typescript\nexport function isValidBlockType(type: string): type is BlockType {\n  return ['power_24v', 'power_12v', 'gnd', 'plc_out', 'plc_in', 'led', 'button', 'scope'].includes(type);\n}\n\nexport function circuitStateToYaml(state: CircuitState): YamlCircuitSchema;\nexport function yamlToCircuitState(yaml: YamlCircuitSchema): CircuitState;\n```\n\n5. **Export all types:**\n```typescript\nexport type {\n  BlockType, Position, Port, PortType, PortPosition,\n  BaseBlock, Block,\n  PlcOutBlock, PlcInBlock, LedBlock, ButtonBlock, ScopeBlock,\n  Power24vBlock, Power12vBlock, GndBlock,\n  WireEndpoint, Wire, CircuitMetadata, CircuitState,\n  SimulationState, YamlCircuitSchema,\n  // ... all other types\n};\n```",
            "status": "pending",
            "testStrategy": "Write unit tests verifying: 1) SimulationState correctly tracks voltages and currents by port/wire ID, 2) YAML schema types match the PRD specification format, 3) Round-trip serialization (CircuitState -> YamlCircuitSchema -> CircuitState) preserves all data, 4) Type guard functions correctly identify valid/invalid block types, 5) Conversion utilities handle edge cases (empty circuits, missing optional fields).",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Define base types (BlockType, Position, Port, BaseBlock) with discriminated union for block types. 2) Define specialized block property interfaces (PlcOutBlockProps, PlcInBlockProps, LedBlockProps, ButtonBlockProps, ScopeBlockProps). 3) Define wire and connection types (WireEndpoint, Wire, CircuitState). 4) Define simulation state types and YAML schema types for serialization.",
        "updatedAt": "2026-01-28T11:53:58.247Z"
      },
      {
        "id": "36",
        "title": "Implement Canvas State Management Store",
        "description": "Create a Zustand store for managing canvas state including components, wires, selection, viewport (zoom/pan), grid settings, and undo/redo history.",
        "details": "Create `src/stores/canvasStore.ts` following existing patterns from modbusStore.ts:\n\n1. **State Interface:**\n```typescript\ninterface CanvasState {\n  // Circuit data\n  components: Map<string, Block>;\n  wires: Wire[];\n  \n  // Selection\n  selectedIds: Set<string>;\n  \n  // Viewport\n  zoom: number; // 0.1 to 4.0 (10% to 400%)\n  pan: Position;\n  \n  // Grid\n  gridSize: number; // default 20px\n  snapToGrid: boolean;\n  showGrid: boolean;\n  \n  // Interaction state\n  tool: 'select' | 'wire' | 'pan';\n  wireDrawing: { from: WireEndpoint; tempPosition: Position; } | null;\n  \n  // History for undo/redo\n  history: CircuitState[];\n  historyIndex: number;\n}\n```\n\n2. **Actions:**\n- `addComponent(type, position)`, `removeComponent(id)`, `updateComponent(id, updates)`\n- `addWire(from, to)`, `removeWire(id)`\n- `setSelection(ids)`, `addToSelection(id)`, `clearSelection()`\n- `setZoom(zoom)`, `setPan(pan)`, `zoomToFit()`\n- `toggleGrid()`, `toggleSnap()`, `setGridSize()`\n- `undo()`, `redo()`, `pushHistory()`\n- `loadCircuit(data)`, `getCircuitData()`\n\n3. **Selectors:**\n- `selectSelectedComponents`, `selectVisibleBounds`, `selectCanUndo/Redo`\n\nUse immer middleware for immutable updates like modbusStore. Implement `devtools` for debugging.",
        "testStrategy": "Unit tests for all state mutations ensuring immutability. Test history management (undo/redo limits, proper state restoration). Test selection operations including multi-select. Verify zoom/pan boundaries are enforced.",
        "priority": "high",
        "dependencies": [
          "35"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define State Interface and Store Setup with Zustand",
            "description": "Create the TypeScript interfaces for CanvasState and CanvasActions, set up the Zustand store with immer and devtools middleware, and define initial state values.",
            "dependencies": [],
            "details": "Create `src/stores/canvasStore.ts` following patterns from modbusStore.ts. Define the CanvasState interface with: components (Map<string, Block>), wires (Wire[]), selectedIds (Set<string>), zoom (number with range 0.1-4.0), pan (Position), gridSize (number default 20), snapToGrid (boolean), showGrid (boolean), tool ('select' | 'wire' | 'pan'), wireDrawing state for in-progress wire creation, history (CircuitState[]) for undo/redo, and historyIndex (number). Define CanvasActions interface with all action signatures. Set up the store using create<CanvasStore>()(devtools(immer((set, get) => ({...})), { name: 'canvas-store' })). Initialize all state with sensible defaults: zoom=1, gridSize=20, snapToGrid=true, showGrid=true, tool='select', empty collections. Import types from the OneCanvas types that Task 35 will create (Block, Wire, Position, WireEndpoint, CircuitState). Add placeholder type imports that will be resolved when Task 35 completes.",
            "status": "pending",
            "testStrategy": "Verify store initializes without errors. Test that initial state values match expected defaults. Verify immer middleware allows direct state mutations. Check devtools integration shows store name in Redux DevTools.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Component CRUD Actions with Map Handling",
            "description": "Implement addComponent, removeComponent, and updateComponent actions with proper Map operations and unique ID generation using immer middleware.",
            "dependencies": [
              1
            ],
            "details": "Implement three component management actions: 1) `addComponent(type: BlockType, position: Position)` - generates unique ID using `${type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, creates Block instance with the type-specific defaults, adds to components Map, and pushes history snapshot. 2) `removeComponent(id: string)` - removes component from Map, also removes all wires connected to this component (filter wires array where from.componentId or to.componentId matches), removes from selectedIds if present, pushes history. 3) `updateComponent(id: string, updates: Partial<Block>)` - retrieves existing component, merges updates using object spread, sets updated component back to Map, pushes history. All actions should use immer's set() with action names for devtools (e.g., 'addComponent/${type}'). Handle edge cases: updateComponent on non-existent ID should be no-op, removeComponent should clean up all references.",
            "status": "pending",
            "testStrategy": "Unit test addComponent creates component with correct type and position. Test removeComponent deletes component and associated wires. Test updateComponent merges partial updates correctly. Verify Map operations work with immer (Map.set, Map.delete). Test that history is pushed for each operation.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Wire Management Actions with Connection Validation",
            "description": "Implement addWire, removeWire actions with endpoint validation to ensure connections are valid and prevent duplicate wires.",
            "dependencies": [
              1
            ],
            "details": "Implement wire management actions: 1) `addWire(from: WireEndpoint, to: WireEndpoint)` - validate both endpoints exist (check components Map for componentId, verify port exists on component), prevent self-connections (from.componentId !== to.componentId), prevent duplicate wires (no existing wire with same from/to or reversed), generate unique wire ID, create Wire object with id, from, to, add to wires array, push history. 2) `removeWire(id: string)` - filter wires array to remove matching ID, push history. 3) Add helper validation function `validateWireEndpoint(endpoint: WireEndpoint): boolean` that checks component exists and has the specified port. 4) Implement `setWireDrawing(state: WireDrawingState | null)` for managing in-progress wire creation visual state (from endpoint + temp mouse position). 5) Implement `completeWireDrawing(to: WireEndpoint)` that calls addWire with wireDrawing.from and the to endpoint, then clears wireDrawing state. Use action names like 'addWire/${from.componentId}-${to.componentId}' for devtools.",
            "status": "pending",
            "testStrategy": "Test addWire creates wire with valid endpoints. Test validation rejects wires to non-existent components. Test duplicate wire prevention (same endpoints in either direction). Test removeWire filters correctly. Test wireDrawing state management for visual feedback during wire creation.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Selection Operations and Viewport Controls",
            "description": "Implement selection management (single, multi, add, clear) and viewport controls (zoom with bounds, pan, zoomToFit) with proper Set operations.",
            "dependencies": [
              1
            ],
            "details": "Implement selection actions: 1) `setSelection(ids: string[])` - replace selectedIds Set with new Set from ids array. 2) `addToSelection(id: string)` - add single ID to existing Set. 3) `removeFromSelection(id: string)` - delete ID from Set. 4) `toggleSelection(id: string)` - add if not present, remove if present. 5) `clearSelection()` - create new empty Set. 6) `selectAll()` - set selectedIds to all component IDs from Map.keys(). Implement viewport controls: 7) `setZoom(zoom: number)` - clamp value between 0.1 and 4.0, update state. 8) `setPan(pan: Position)` - update pan position directly. 9) `zoomToFit(padding: number = 50)` - calculate bounding box of all components, compute zoom and pan to fit all components within viewport with padding. 10) `setTool(tool: 'select' | 'wire' | 'pan')` - update active tool. 11) `toggleGrid()` - flip showGrid boolean. 12) `toggleSnap()` - flip snapToGrid boolean. 13) `setGridSize(size: number)` - update gridSize with validation (minimum 5px). All viewport changes should NOT push history (they're view-only, not data changes).",
            "status": "pending",
            "testStrategy": "Test setSelection replaces entire selection. Test addToSelection with existing and new IDs. Test clearSelection empties Set. Test zoom clamping at boundaries (0.1 and 4.0). Test zoomToFit calculates correct bounds. Test tool switching updates state correctly. Test grid toggles flip boolean values.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Undo/Redo History Management with State Snapshots",
            "description": "Implement pushHistory, undo, redo actions with proper state cloning, history size limits, and selectors for undo/redo availability.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement history management: 1) `pushHistory()` - create deep clone of current circuit state (components Map converted to array of entries, wires array spread), truncate any redo history (slice history to historyIndex + 1), push new snapshot, limit history size to 50 entries (shift oldest if exceeded), update historyIndex. 2) `undo()` - if historyIndex > 0, decrement historyIndex, restore state from history[historyIndex] by reconstructing components Map from entries and cloning wires array. 3) `redo()` - if historyIndex < history.length - 1, increment historyIndex, restore state from history[historyIndex]. Create helper function `createCircuitSnapshot(): CircuitState` that deep clones components Map (iterate and clone each Block) and wires array. Create helper `restoreCircuitSnapshot(snapshot: CircuitState)` that rebuilds Map and array from snapshot. Add selectors: `selectCanUndo = (state) => state.historyIndex > 0`, `selectCanRedo = (state) => state.historyIndex < state.history.length - 1`. Add `getCircuitData()` action that returns serializable circuit data for saving. Add `loadCircuit(data: CircuitState)` that replaces current state and resets history. Consider using structuredClone() for deep cloning if browser support is sufficient, otherwise implement manual deep clone.",
            "status": "pending",
            "testStrategy": "Test pushHistory creates snapshot and increments index. Test undo restores previous state and decrements index. Test redo restores next state and increments index. Test history limit of 50 entries. Test that undo after new action clears redo history. Test selectors return correct boolean values. Test loadCircuit replaces state and clears history. Test deep cloning prevents reference sharing between snapshots.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Define state interface with components, wires, selection, viewport, grid, and history arrays. 2) Implement component CRUD actions (add, remove, update) with proper Map handling. 3) Implement wire management actions with connection validation. 4) Implement selection operations (single, multi, range, clear) and viewport controls (zoom, pan). 5) Implement undo/redo history management with state snapshots.",
        "updatedAt": "2026-01-28T13:18:06.763Z"
      },
      {
        "id": "37",
        "title": "Create Base Canvas Component with Pan/Zoom/Grid",
        "description": "Implement the foundational Canvas component with infinite canvas scrolling, mouse/wheel-based pan and zoom, configurable grid background, and coordinate transformation utilities.",
        "details": "Create core canvas components in `src/components/OneCanvas/`:\n\n1. **GridBackground.tsx:**\n```tsx\n// SVG pattern-based grid that scales with zoom\n// Props: gridSize, showGrid, zoom\n// Use CSS pattern or SVG defs for performance\n```\n\n2. **Canvas.tsx:**\n```tsx\nfunction Canvas({ children }: { children: React.ReactNode }) {\n  const { zoom, pan, setZoom, setPan } = useCanvasStore();\n  \n  // Transform matrix: translate(pan.x, pan.y) scale(zoom)\n  const transform = `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`;\n  \n  // Wheel handler for zoom (Ctrl+wheel) and pan (wheel)\n  const handleWheel = (e: WheelEvent) => {\n    if (e.ctrlKey) {\n      // Zoom towards cursor position\n      const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;\n      setZoom(clamp(zoom * zoomDelta, 0.1, 4));\n    } else {\n      // Pan\n      setPan({ x: pan.x - e.deltaX, y: pan.y - e.deltaY });\n    }\n  };\n  \n  // Space+drag for pan mode\n  return (\n    <div className=\"relative w-full h-full overflow-hidden\">\n      <GridBackground />\n      <div style={{ transform, transformOrigin: '0 0' }}>\n        {children}\n      </div>\n    </div>\n  );\n}\n```\n\n3. **Coordinate Utilities in `utils/canvasCoordinates.ts`:**\n- `screenToCanvas(screenPos, pan, zoom)`: Convert screen coordinates to canvas coordinates\n- `canvasToScreen(canvasPos, pan, zoom)`: Reverse transformation\n- `snapToGrid(position, gridSize)`: Snap position to nearest grid point\n\n4. **Touch Support:** Handle pinch-to-zoom on trackpads.",
        "testStrategy": "Integration tests verifying zoom bounds (10%-400%), pan works in all directions, grid scales correctly with zoom. Test coordinate transformations are mathematically correct (round-trip test). Test keyboard+mouse combinations (Space+drag for pan).",
        "priority": "high",
        "dependencies": [
          "36"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create GridBackground Component with SVG Pattern",
            "description": "Implement the GridBackground component using SVG pattern definitions that properly scale with zoom level for optimal rendering performance.",
            "dependencies": [],
            "details": "Create `src/components/OneCanvas/GridBackground.tsx`:\n\n1. **Component Props Interface:**\n   - `gridSize: number` - Base grid cell size in pixels (default: 20)\n   - `showGrid: boolean` - Toggle grid visibility\n   - `zoom: number` - Current zoom level for pattern scaling\n\n2. **SVG Pattern Implementation:**\n   - Use `<defs>` with `<pattern>` element for GPU-accelerated tiling\n   - Pattern ID should be unique to avoid conflicts\n   - Stroke width should scale inversely with zoom for consistent visual weight\n   - Minor grid lines (every cell) and major grid lines (every 5 cells)\n\n3. **Zoom Scaling Logic:**\n   - Pattern size = gridSize * zoom\n   - At zoom < 0.5, hide minor grid lines for clarity\n   - At zoom > 2, optionally show sub-grid\n\n4. **Styling:**\n   - Grid lines: subtle gray (#e0e0e0 for minor, #c0c0c0 for major)\n   - Background: white or transparent\n   - Full viewport coverage with `width: 100%` and `height: 100%`",
            "status": "pending",
            "testStrategy": "Test grid renders at various zoom levels (0.1, 0.5, 1, 2, 4). Verify pattern scales correctly with zoom. Test showGrid toggle hides/shows grid. Snapshot test for visual regression. Performance test: ensure no jank during rapid zoom changes.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Canvas Component with Pan/Zoom Transform Rendering",
            "description": "Implement the main Canvas component that manages CSS transform-based pan and zoom rendering, integrating with Zustand store for state management.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/OneCanvas/Canvas.tsx`:\n\n1. **Component Structure:**\n   - Outer container: `relative w-full h-full overflow-hidden` with ref for event handling\n   - GridBackground component positioned absolutely\n   - Transform container wrapping children with `transformOrigin: '0 0'`\n\n2. **Zustand Store Integration:**\n   - Import from `useCanvasStore` (assumes store exists from Task 36)\n   - Access: `zoom`, `pan`, `setZoom`, `setPan`\n   - Pan stored as `{ x: number, y: number }`\n\n3. **Transform Calculation:**\n   ```tsx\n   const transform = `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`;\n   ```\n\n4. **Component Props:**\n   - `children: React.ReactNode` - Canvas content (nodes, connections)\n   - `className?: string` - Optional additional styling\n   - `gridSize?: number` - Grid configuration passthrough\n   - `showGrid?: boolean` - Grid visibility passthrough\n\n5. **Cursor States:**\n   - Default: `cursor-default`\n   - Space held: `cursor-grab`\n   - Space + dragging: `cursor-grabbing`",
            "status": "pending",
            "testStrategy": "Test transform string is correctly computed from zoom and pan values. Test children render inside transform container. Test GridBackground receives correct zoom prop. Integration test with store: verify transform updates when store state changes.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Wheel Event Handler for Zoom and Pan",
            "description": "Create wheel event handling logic for Ctrl+wheel zoom (towards cursor position) and regular wheel pan, including smooth transitions and Space+drag pan mode.",
            "dependencies": [
              2
            ],
            "details": "Add to `Canvas.tsx` or create `src/components/OneCanvas/hooks/useCanvasInteraction.ts`:\n\n1. **Wheel Event Handler:**\n   ```tsx\n   const handleWheel = useCallback((e: WheelEvent) => {\n     e.preventDefault();\n     if (e.ctrlKey || e.metaKey) {\n       // Zoom towards cursor\n       const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;\n       const newZoom = clamp(zoom * zoomFactor, 0.1, 4);\n       // Calculate cursor position relative to canvas\n       // Adjust pan to keep cursor point stationary\n     } else {\n       // Pan: invert deltaY for natural scrolling\n       setPan({ x: pan.x - e.deltaX, y: pan.y - e.deltaY });\n     }\n   }, [zoom, pan]);\n   ```\n\n2. **Zoom Towards Cursor Math:**\n   - Get cursor position relative to container\n   - Calculate canvas point under cursor before zoom\n   - After zoom, adjust pan so same canvas point remains under cursor\n\n3. **Space+Drag Pan Mode:**\n   - Track `isSpaceHeld` and `isPanning` state\n   - `keydown/keyup` listeners for Space key\n   - `mousedown/mousemove/mouseup` for drag when Space held\n   - Update cursor style based on state\n\n4. **Smooth Transitions:**\n   - Optional CSS transition on transform for smooth zoom\n   - Disable transition during continuous wheel events\n\n5. **Zoom Bounds:** Min 0.1 (10%), Max 4 (400%)",
            "status": "pending",
            "testStrategy": "Test Ctrl+wheel zooms in/out. Test zoom clamps at 0.1 and 4 boundaries. Test regular wheel pans canvas. Test zoom-towards-cursor keeps point stationary (round-trip coordinate test). Test Space+drag initiates pan mode with correct cursor. Test rapid wheel events don't cause jank.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create Coordinate Utilities and Touch/Trackpad Support",
            "description": "Implement coordinate transformation utilities for screen-to-canvas conversion and add pinch-to-zoom support for trackpads and touch devices.",
            "dependencies": [
              2
            ],
            "details": "Create `src/components/OneCanvas/utils/canvasCoordinates.ts`:\n\n1. **screenToCanvas Function:**\n   ```typescript\n   export function screenToCanvas(\n     screenPos: { x: number; y: number },\n     pan: { x: number; y: number },\n     zoom: number\n   ): { x: number; y: number } {\n     return {\n       x: (screenPos.x - pan.x) / zoom,\n       y: (screenPos.y - pan.y) / zoom\n     };\n   }\n   ```\n\n2. **canvasToScreen Function:** (inverse transform)\n   ```typescript\n   export function canvasToScreen(\n     canvasPos: { x: number; y: number },\n     pan: { x: number; y: number },\n     zoom: number\n   ): { x: number; y: number } {\n     return {\n       x: canvasPos.x * zoom + pan.x,\n       y: canvasPos.y * zoom + pan.y\n     };\n   }\n   ```\n\n3. **snapToGrid Function:**\n   ```typescript\n   export function snapToGrid(\n     position: { x: number; y: number },\n     gridSize: number\n   ): { x: number; y: number } {\n     return {\n       x: Math.round(position.x / gridSize) * gridSize,\n       y: Math.round(position.y / gridSize) * gridSize\n     };\n   }\n   ```\n\n4. **Touch/Trackpad Pinch-to-Zoom:**\n   - Use `gesturestart/gesturechange/gestureend` for Safari\n   - Use touch events with two-finger detection for other browsers\n   - Calculate pinch center and scale factor from touch point distances\n   - Apply zoom towards pinch center point",
            "status": "pending",
            "testStrategy": "Unit tests for coordinate utilities: verify screenToCanvas and canvasToScreen are inverse operations (round-trip test at various zoom/pan values). Test snapToGrid snaps to nearest grid point correctly. Integration test: verify pinch gesture triggers zoom. Test touch events on simulated touch device.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create GridBackground component with SVG pattern that scales with zoom. 2) Create Canvas component with CSS transform-based pan/zoom rendering. 3) Implement wheel event handler for zoom (Ctrl+wheel) and pan (wheel) with smooth transitions. 4) Create coordinate transformation utilities (screenToCanvas, canvasToScreen, snapToGrid) and implement touch/trackpad pinch-to-zoom support.",
        "updatedAt": "2026-01-28T13:20:09.005Z"
      },
      {
        "id": "38",
        "title": "Implement Block Rendering System and Port Component",
        "description": "Create the BlockRenderer component that dispatches to specific block components, the Port component for connection points, and the visual representation for Power, GND, LED, and basic blocks.",
        "details": "Create block components in `src/components/OneCanvas/components/`:\n\n1. **Port.tsx:**\n```tsx\ninterface PortProps {\n  port: Port;\n  blockId: string;\n  voltage?: number; // For visual feedback\n  onStartWire: (blockId: string, portId: string) => void;\n  onEndWire: (blockId: string, portId: string) => void;\n}\n\n// Visual: 8px circle, positioned based on port.position\n// Colors: connected=green, disconnected=gray, hover=blue\n// Cursor: crosshair when hovering\n```\n\n2. **BlockRenderer.tsx:**\n```tsx\nfunction BlockRenderer({ block }: { block: Block }) {\n  switch (block.type) {\n    case 'power_24v':\n    case 'power_12v': return <PowerBlock block={block} />;\n    case 'gnd': return <GndBlock block={block} />;\n    case 'led': return <LedBlock block={block} />;\n    case 'plc_out': return <PlcOutBlock block={block} />;\n    case 'plc_in': return <PlcInBlock block={block} />;\n    case 'button': return <ButtonBlock block={block} />;\n    case 'scope': return <ScopeBlock block={block} />;\n  }\n}\n```\n\n3. **PowerBlock.tsx:** Red rectangle with voltage label (+24V or +12V), single output port on bottom\n\n4. **GndBlock.tsx:** Black ground symbol (三 shape), single input port on top\n\n5. **LedBlock.tsx:** \n- LED shape with configurable color property\n- Input port (top) and output port (bottom)\n- Glowing effect when powered (use CSS box-shadow)\n\n6. **Base styling:**\n- Selection ring (blue border when selected)\n- Drag handle area\n- 60x60px minimum block size",
        "testStrategy": "Visual regression tests for each block type. Test port positioning on all four sides. Test selection visual feedback. Verify LED glow effect activates based on voltage prop.",
        "priority": "high",
        "dependencies": [
          "37"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Port component with visual states and wire interaction handlers",
            "description": "Implement the Port.tsx component that renders connection points on blocks with visual feedback for different states (connected, disconnected, hover) and handlers for wire creation interactions.",
            "dependencies": [],
            "details": "Create `src/components/OneCanvas/components/Port.tsx`:\n\n1. Define PortProps interface:\n   - port: Port (from types)\n   - blockId: string\n   - voltage?: number (for visual feedback)\n   - isConnected: boolean\n   - onStartWire: (blockId: string, portId: string) => void\n   - onEndWire: (blockId: string, portId: string) => void\n\n2. Visual styling:\n   - 8px diameter circle using CSS or SVG\n   - Position based on port.position (top, bottom, left, right)\n   - Colors: connected=green (#22c55e), disconnected=gray (#6b7280), hover=blue (#3b82f6)\n   - Cursor: crosshair on hover\n   - Transition effects for smooth state changes\n\n3. Event handlers:\n   - onMouseDown: Call onStartWire to initiate wire creation\n   - onMouseUp: Call onEndWire to complete wire connection\n   - onMouseEnter/Leave: Toggle hover state\n\n4. Positioning logic:\n   - Calculate absolute position based on port.position enum\n   - top: center-x, 0\n   - bottom: center-x, 100%\n   - left: 0, center-y\n   - right: 100%, center-y",
            "status": "pending",
            "testStrategy": "Unit tests: Verify correct rendering of port circle with 8px size. Test color changes for connected/disconnected/hover states. Test onStartWire callback fires on mousedown. Test onEndWire callback fires on mouseup. Test cursor style is 'crosshair' on hover. Test positioning calculations for all four port positions (top, bottom, left, right).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create BlockRenderer dispatch component",
            "description": "Implement the BlockRenderer.tsx component that acts as a switch statement dispatching to specific block type components based on the block.type property.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/OneCanvas/components/BlockRenderer.tsx`:\n\n1. Define BlockRendererProps interface:\n   - block: Block\n   - isSelected: boolean\n   - onSelect: (blockId: string) => void\n   - onStartWire: (blockId: string, portId: string) => void\n   - onEndWire: (blockId: string, portId: string) => void\n\n2. Implement switch statement for block types:\n   ```tsx\n   function BlockRenderer({ block, ...props }: BlockRendererProps) {\n     const commonProps = { block, ...props };\n     \n     switch (block.type) {\n       case 'power_24v':\n       case 'power_12v':\n         return <PowerBlock {...commonProps} />;\n       case 'gnd':\n         return <GndBlock {...commonProps} />;\n       case 'led':\n         return <LedBlock {...commonProps} />;\n       case 'plc_out':\n         return <PlcOutBlock {...commonProps} />;\n       case 'plc_in':\n         return <PlcInBlock {...commonProps} />;\n       case 'button':\n         return <ButtonBlock {...commonProps} />;\n       case 'scope':\n         return <ScopeBlock {...commonProps} />;\n       default:\n         return <UnknownBlock {...commonProps} />;\n     }\n   }\n   ```\n\n3. Add wrapper div for common positioning:\n   - Use absolute positioning with block.position.x/y\n   - Apply transform for drag offset if needed\n   - Include data-block-id attribute for DOM queries",
            "status": "pending",
            "testStrategy": "Unit tests: Test that each block type string correctly renders the corresponding component. Test unknown block types render UnknownBlock fallback. Test that common props (isSelected, onSelect, etc.) are passed through correctly. Snapshot tests for each block type rendering.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement PowerBlock and GndBlock components",
            "description": "Create the PowerBlock component for +24V/+12V power sources with voltage label display and GndBlock component with ground symbol visual, each with appropriate single port configuration.",
            "dependencies": [
              1
            ],
            "details": "Create power and ground block components:\n\n**PowerBlock.tsx** (`src/components/OneCanvas/components/blocks/PowerBlock.tsx`):\n1. Visual design:\n   - 60x40px red rectangle (#ef4444)\n   - Rounded corners (4px border-radius)\n   - White text label: '+24V' or '+12V' based on block.type\n   - Font: bold, centered\n\n2. Port configuration:\n   - Single output port on bottom center\n   - Port renders using Port component from subtask 1\n\n3. Props:\n   - block: Block (with type 'power_24v' | 'power_12v')\n   - Wire interaction handlers passed to Port\n\n**GndBlock.tsx** (`src/components/OneCanvas/components/blocks/GndBlock.tsx`):\n1. Visual design:\n   - Ground symbol (三 shape) using SVG or CSS\n   - 40x50px overall size\n   - Black color (#000000) for symbol\n   - Three horizontal lines decreasing in width\n\n2. Port configuration:\n   - Single input port on top center\n\n3. SVG implementation:\n   ```tsx\n   <svg viewBox=\"0 0 40 50\">\n     <line x1=\"10\" y1=\"15\" x2=\"30\" y2=\"15\" stroke=\"black\" strokeWidth=\"3\"/>\n     <line x1=\"14\" y1=\"25\" x2=\"26\" y2=\"25\" stroke=\"black\" strokeWidth=\"3\"/>\n     <line x1=\"18\" y1=\"35\" x2=\"22\" y2=\"35\" stroke=\"black\" strokeWidth=\"3\"/>\n   </svg>\n   ```",
            "status": "pending",
            "testStrategy": "Visual regression tests: Snapshot tests for PowerBlock with both +24V and +12V types. Verify voltage label displays correctly. Test GndBlock renders ground symbol with correct proportions. Test port positioning on PowerBlock (bottom) and GndBlock (top). Test minimum dimensions meet 60x40px for power, 40x50px for ground.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement LedBlock component with glow effect",
            "description": "Create the LedBlock component with configurable color property, input/output ports, and CSS-based glowing effect that activates when the LED receives power (based on voltage prop).",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/OneCanvas/components/blocks/LedBlock.tsx`:\n\n1. Props interface:\n   ```tsx\n   interface LedBlockProps {\n     block: Block & {\n       properties?: {\n         color?: string; // 'red' | 'green' | 'yellow' | 'blue' | hex color\n       };\n     };\n     voltage?: number; // Received from simulation, triggers glow\n     // ... common block props\n   }\n   ```\n\n2. Visual design:\n   - 40x60px overall size\n   - LED bulb shape: rounded rectangle or circle (top portion)\n   - Base/legs section (bottom portion)\n   - Configurable color from block.properties.color (default: red)\n\n3. Glow effect (when voltage > 0):\n   ```css\n   .led-powered {\n     filter: brightness(1.3);\n     box-shadow: \n       0 0 10px currentColor,\n       0 0 20px currentColor,\n       0 0 30px currentColor;\n     animation: pulse 1s ease-in-out infinite;\n   }\n   \n   @keyframes pulse {\n     0%, 100% { opacity: 1; }\n     50% { opacity: 0.8; }\n   }\n   ```\n\n4. Port configuration:\n   - Input port on top (anode)\n   - Output port on bottom (cathode)\n\n5. Color mapping:\n   - red: #ef4444, green: #22c55e, yellow: #eab308, blue: #3b82f6\n   - Support hex color strings for custom colors",
            "status": "pending",
            "testStrategy": "Unit tests: Test LED renders with default red color. Test color prop changes LED appearance for all preset colors (red, green, yellow, blue). Test custom hex color support. Visual test: Verify glow effect activates when voltage > 0. Test glow effect deactivates when voltage = 0 or undefined. Test both input and output ports are rendered at correct positions. CSS animation test for pulse effect smoothness.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add common block styling and interaction handlers",
            "description": "Implement shared block styling including selection ring (blue border when selected), drag handle area, minimum size constraints, and common interaction handlers for selection and dragging.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create shared block utilities and styles:\n\n**1. BlockWrapper component** (`src/components/OneCanvas/components/blocks/BlockWrapper.tsx`):\n```tsx\ninterface BlockWrapperProps {\n  blockId: string;\n  isSelected: boolean;\n  children: React.ReactNode;\n  onSelect: (blockId: string) => void;\n  className?: string;\n}\n```\n\n**2. Selection ring styling:**\n```css\n.block-wrapper {\n  min-width: 60px;\n  min-height: 60px;\n  position: relative;\n  cursor: grab;\n}\n\n.block-wrapper.selected {\n  outline: 2px solid #3b82f6;\n  outline-offset: 2px;\n  border-radius: 4px;\n}\n\n.block-wrapper:active {\n  cursor: grabbing;\n}\n```\n\n**3. Drag handle implementation:**\n- Make entire block draggable\n- Exclude port areas from drag initiation\n- Use data attributes for drag state tracking\n\n**4. Click handling:**\n- onClick: Select block (call onSelect with blockId)\n- Prevent selection when clicking ports\n- Support multi-select with Ctrl/Cmd key\n\n**5. Common styles file** (`src/components/OneCanvas/components/blocks/blockStyles.ts`):\n- Export shared Tailwind classes or CSS-in-JS styles\n- Define color palette for block types\n- Animation keyframes for powered states\n\n**6. Update all block components** to use BlockWrapper:\n- PowerBlock, GndBlock, LedBlock wrap content with BlockWrapper\n- Pass isSelected and onSelect through props",
            "status": "pending",
            "testStrategy": "Integration tests: Test selection ring appears when block isSelected=true. Test selection ring hidden when isSelected=false. Test click on block triggers onSelect callback. Test minimum size constraint of 60x60px. Test drag cursor states (grab vs grabbing). Test Ctrl+click for multi-select behavior. Test clicking port does not trigger block selection. Visual regression test for selection ring styling across all block types.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Create Port component with visual styling based on state (connected, disconnected, hover) and wire interaction handlers. 2) Create BlockRenderer component that dispatches to specific block components based on type. 3) Implement PowerBlock and GndBlock components with voltage display and single port. 4) Implement LedBlock component with configurable color and glow effect based on voltage. 5) Add common block styling (selection ring, drag handle) and interaction handlers.",
        "updatedAt": "2026-01-28T13:24:06.367Z"
      },
      {
        "id": "39",
        "title": "Implement Block Drag-and-Drop from Toolbox",
        "description": "Create the Toolbox panel with categorized block types and implement drag-and-drop functionality to place new blocks on the canvas with proper coordinate transformation and grid snapping.",
        "details": "Create toolbox and drag-drop functionality:\n\n1. **Toolbox.tsx:**\n```tsx\nconst BLOCK_CATEGORIES = [\n  { name: 'Power', blocks: ['power_24v', 'power_12v', 'gnd'] },\n  { name: 'PLC I/O', blocks: ['plc_out', 'plc_in'] },\n  { name: 'Components', blocks: ['led', 'button'] },\n  { name: 'Instruments', blocks: ['scope'] },\n];\n\n// Collapsible categories, drag preview on drag start\n```\n\n2. **Draggable Toolbox Item:**\n- Use HTML5 drag and drop or @dnd-kit (already in dependencies)\n- Set drag data: `e.dataTransfer.setData('blockType', type)`\n- Show ghost preview during drag\n\n3. **Canvas Drop Handler:**\n```tsx\nconst handleDrop = (e: DragEvent) => {\n  const blockType = e.dataTransfer.getData('blockType');\n  const screenPos = { x: e.clientX, y: e.clientY };\n  const canvasPos = screenToCanvas(screenPos, pan, zoom);\n  const snappedPos = snapToGrid(canvasPos, gridSize);\n  \n  addComponent(blockType, snappedPos);\n};\n```\n\n4. **useDragDrop.ts Hook:**\n- Track drag state (isDragging, dragType)\n- Handle drag preview rendering\n- Manage drop zone highlighting\n\n5. **Component Movement:**\n- Dragging existing components repositions them\n- Multi-select drag moves all selected components together\n- Snapping feedback (show snap lines when near grid)",
        "testStrategy": "E2E test: drag block from toolbox, verify it appears at correct position. Test grid snapping works correctly. Test multi-select drag maintains relative positions. Test drag cancellation (Escape key).",
        "priority": "high",
        "dependencies": [
          "38"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Toolbox component with categorized block items and collapsible sections",
            "description": "Build the Toolbox.tsx component that displays block categories (Power, PLC I/O, Components, Instruments) with collapsible accordion sections and styled block items for each category.",
            "dependencies": [],
            "details": "Create src/components/OneCanvas/Toolbox.tsx with the following implementation:\n\n1. Define BLOCK_CATEGORIES constant with categorized blocks:\n   - Power: power_24v, power_12v, gnd\n   - PLC I/O: plc_out, plc_in\n   - Components: led, button\n   - Instruments: scope\n\n2. Create collapsible category sections using Radix UI Accordion or similar:\n   - Each category header shows name and expand/collapse icon\n   - Categories can be individually expanded/collapsed\n   - Store expanded state in local component state\n\n3. Style block items within categories:\n   - Display block name/icon for each block type\n   - Add hover state styling\n   - Make items visually indicate they are draggable (cursor: grab)\n\n4. Position Toolbox as a sidebar panel on the left side of the canvas area\n\n5. Export Toolbox component for use in the OneCanvas layout",
            "status": "pending",
            "testStrategy": "Unit test that Toolbox renders all categories and block items. Test collapsible sections expand/collapse correctly. Snapshot test for consistent styling.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement draggable toolbox items using @dnd-kit with drag preview",
            "description": "Make toolbox block items draggable using @dnd-kit library with visual drag preview showing a ghost representation of the block being dragged.",
            "dependencies": [
              1
            ],
            "details": "Enhance Toolbox with @dnd-kit drag functionality:\n\n1. Set up @dnd-kit DndContext at the appropriate level (likely in OneCanvas parent component)\n\n2. Create DraggableBlockItem component:\n   - Use useDraggable hook from @dnd-kit/core\n   - Set drag data containing blockType identifier\n   - Apply transform styles during drag\n\n3. Implement drag preview/overlay:\n   - Use DragOverlay component from @dnd-kit\n   - Create BlockDragPreview component showing block visualization\n   - Track active drag state to show/hide overlay\n\n4. Create useDragDrop.ts hook to encapsulate drag state:\n   - Track isDragging, dragType, activeId\n   - Handle drag start/end events\n   - Provide context for drag state throughout app\n\n5. Add visual feedback:\n   - Change cursor to grabbing during drag\n   - Reduce opacity of source item while dragging\n   - Style drag preview to match block appearance",
            "status": "pending",
            "testStrategy": "Test drag start fires with correct block type data. Test drag preview renders during drag. Test drag end cleanup. Integration test with mouse events simulating drag operations.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement canvas drop handler with coordinate transformation and grid snapping",
            "description": "Create the drop zone on the canvas that accepts dragged blocks, transforms screen coordinates to canvas coordinates, applies grid snapping, and creates new components at the drop position.",
            "dependencies": [
              2
            ],
            "details": "Implement canvas drop handling:\n\n1. Set up canvas as droppable area:\n   - Use useDroppable hook from @dnd-kit/core on canvas container\n   - Handle onDragEnd event in DndContext\n\n2. Implement coordinate transformation in handleDrop:\n   ```typescript\n   const handleDrop = (event: DragEndEvent) => {\n     const { active, over } = event;\n     if (!over || over.id !== 'canvas') return;\n     \n     const blockType = active.data.current?.blockType;\n     const screenPos = { x: event.activatorEvent.clientX, y: event.activatorEvent.clientY };\n     const canvasPos = screenToCanvas(screenPos, pan, zoom);\n     const snappedPos = snapToGrid(canvasPos, gridSize);\n     \n     addComponent(blockType, snappedPos);\n   };\n   ```\n\n3. Create/update coordinate utilities in src/components/OneCanvas/utils/:\n   - screenToCanvas(screenPos, pan, zoom): Convert screen coordinates to canvas space\n   - canvasToScreen(canvasPos, pan, zoom): Reverse transformation\n   - snapToGrid(pos, gridSize): Snap position to nearest grid intersection\n\n4. Integrate with component store:\n   - Call addComponent with block type and snapped position\n   - Generate unique ID for new component\n   - Apply default configuration for block type\n\n5. Add drop zone visual feedback:\n   - Highlight canvas border when dragging over\n   - Show grid-snapped preview position",
            "status": "pending",
            "testStrategy": "Test coordinate transformation accuracy at various pan/zoom levels. Test grid snapping rounds to correct positions. Test dropping creates component at expected location. E2E test: drag block from toolbox, verify it appears at correct snapped position.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add existing component drag-to-move with multi-select and snap-line feedback",
            "description": "Enable dragging existing components on the canvas to reposition them, support moving multiple selected components together while maintaining relative positions, and show visual snap-line indicators when near grid lines.",
            "dependencies": [
              3
            ],
            "details": "Implement component movement on canvas:\n\n1. Make canvas components draggable:\n   - Wrap rendered components with useDraggable\n   - Differentiate from toolbox drag by data type\n   - Apply position updates on drag end\n\n2. Implement multi-select drag:\n   - When dragging a selected component, move all selected components\n   - Calculate offset from drag handle to each selected component\n   - Maintain relative positions: newPos = originalPos + dragDelta\n   - Update all selected components' positions atomically\n\n3. Create snap-line feedback system:\n   - During drag, calculate distance to nearest grid lines\n   - When within threshold (e.g., 5px), show snap line overlay\n   - Render vertical and horizontal snap lines as thin colored lines\n   - Snap lines extend across canvas at grid positions\n\n4. Create SnapLineOverlay component:\n   - Receives current drag position and grid settings\n   - Calculates and renders visible snap lines\n   - Uses CSS for performant rendering (transform, will-change)\n\n5. Handle edge cases:\n   - Escape key cancels drag and reverts positions\n   - Prevent dragging off canvas bounds\n   - Update selection if component was not previously selected",
            "status": "pending",
            "testStrategy": "Test single component drag updates position correctly. Test multi-select drag maintains relative positions between components. Test snap-lines appear when near grid. Test Escape key cancels drag and reverts to original positions. Performance test with 50+ components being dragged.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create Toolbox component with categorized block items and collapsible sections. 2) Implement draggable toolbox items using @dnd-kit with drag preview. 3) Implement canvas drop handler with coordinate transformation and grid snapping. 4) Add existing component drag-to-move functionality with multi-select drag support and snap-line feedback.",
        "updatedAt": "2026-01-28T13:28:29.731Z"
      },
      {
        "id": "40",
        "title": "Implement Wire Drawing and Connection System",
        "description": "Create the wire drawing interaction (click-drag from port to port), wire component rendering with visual current flow, and connection validation logic.",
        "details": "Create wire system in `src/components/OneCanvas/`:\n\n1. **Wire.tsx:**\n```tsx\ninterface WireProps {\n  wire: Wire;\n  fromPos: Position; // Calculated from component/port\n  toPos: Position;\n  isActive?: boolean; // Current flowing\n  type: 'power' | 'ground' | 'signal' | 'inactive';\n}\n\n// SVG path: straight lines with rounded corners or bezier curves\n// Colors: power=red, ground=black, signal=blue, inactive=gray\n// Animation: dashed line animation when current flows\n```\n\n2. **useWireDrawing.ts Hook:**\n```tsx\nfunction useWireDrawing() {\n  const [drawing, setDrawing] = useState<{ from: WireEndpoint; tempPos: Position } | null>(null);\n  \n  const startWire = (blockId: string, portId: string) => {\n    setDrawing({ from: { componentId: blockId, portId }, tempPos: getPortPosition(...) });\n  };\n  \n  const updateWirePreview = (mousePos: Position) => {\n    if (drawing) setDrawing({ ...drawing, tempPos: mousePos });\n  };\n  \n  const endWire = (blockId: string, portId: string) => {\n    if (drawing && isValidConnection(drawing.from, { componentId: blockId, portId })) {\n      addWire(drawing.from, { componentId: blockId, portId });\n    }\n    setDrawing(null);\n  };\n}\n```\n\n3. **Connection Validation:**\n- Cannot connect port to itself\n- Cannot connect two ports on same component\n- Must respect port direction (output->input for signal flow)\n- Allow multiple wires per port (branching)\n\n4. **Wire Path Calculation:**\n- Calculate port positions from component position + port offset\n- Use orthogonal routing (horizontal/vertical segments) or direct bezier\n\n5. **Temporary Wire Preview:** Rendered while drawing, follows mouse cursor",
        "testStrategy": "Test wire creation between valid ports. Test validation rejects invalid connections. Test wire preview updates correctly during draw. Test wire deletion (select + Delete key). Test visual feedback for hovering over valid drop targets.",
        "priority": "high",
        "dependencies": [
          "38"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Wire Component with SVG Path Rendering",
            "description": "Implement Wire.tsx component that renders wire connections as SVG paths with support for straight lines with rounded corners and bezier curves, color coding by wire type (power=red, ground=black, signal=blue, inactive=gray), and dashed line animation for active current flow.",
            "dependencies": [],
            "details": "Create `src/components/OneCanvas/Wire.tsx` with the following implementation:\n\n1. Define WireProps interface with wire data, fromPos, toPos, isActive flag, and type enum\n2. Implement SVG path generation supporting two modes:\n   - Straight mode: orthogonal routing with horizontal/vertical segments and rounded corners (use quadratic bezier for corners)\n   - Bezier mode: smooth cubic bezier curve from start to end point\n3. Apply color styling based on wire type using CSS classes or inline styles\n4. Implement current flow animation using CSS keyframes with stroke-dasharray and stroke-dashoffset animation\n5. Add hover state styling for wire selection feedback\n6. Export Wire component with memo() for performance optimization\n\nCSS animation example:\n```css\n@keyframes current-flow {\n  from { stroke-dashoffset: 20; }\n  to { stroke-dashoffset: 0; }\n}\n```",
            "status": "pending",
            "testStrategy": "Unit test Wire component renders correct SVG path for given from/to positions. Test each wire type renders with correct color. Test isActive prop triggers animation class. Snapshot test for path generation consistency.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create useWireDrawing Hook for Wire Creation State",
            "description": "Implement useWireDrawing custom hook that manages the complete wire drawing interaction state including starting a wire from a port, updating the preview position as mouse moves, and completing the wire when dropped on a valid target port.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/OneCanvas/hooks/useWireDrawing.ts`:\n\n1. Define DrawingState interface: { from: WireEndpoint; tempPos: Position } | null\n2. Implement startWire(blockId, portId) function:\n   - Set drawing state with the source endpoint\n   - Calculate initial tempPos from port's absolute position\n3. Implement updateWirePreview(mousePos) function:\n   - Update tempPos in drawing state as mouse moves\n   - Should be called from canvas mousemove handler\n4. Implement endWire(blockId, portId) function:\n   - Validate connection using validation logic (subtask 3)\n   - If valid, call canvasStore.addWire() to persist the wire\n   - Clear drawing state regardless of success\n5. Implement cancelWire() function for ESC key handling\n6. Return { drawing, startWire, updateWirePreview, endWire, cancelWire, isDrawing }\n\nIntegrate with OneCanvas component's mouse event handlers.",
            "status": "pending",
            "testStrategy": "Test startWire initializes drawing state correctly. Test updateWirePreview updates tempPos. Test endWire adds wire on valid connection and clears state. Test cancelWire clears drawing state. Test isDrawing computed correctly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Connection Validation Logic",
            "description": "Create validation utilities that enforce circuit connection rules: preventing self-connections, same-component connections, enforcing port direction compatibility (output to input for signal flow), and optionally detecting duplicate wire connections.",
            "dependencies": [],
            "details": "Create `src/components/OneCanvas/utils/connectionValidator.ts`:\n\n1. Define ValidationResult type: { valid: boolean; reason?: string }\n2. Implement isValidConnection(from: WireEndpoint, to: WireEndpoint, existingWires: Wire[], blocks: Block[]):\n   - Check 1: from.componentId !== to.componentId (not same component)\n   - Check 2: !(from.componentId === to.componentId && from.portId === to.portId) (not same port)\n   - Check 3: Port direction compatibility:\n     * Get port definitions from source and target blocks\n     * Output port can connect to input port\n     * Input port can connect to output port\n     * Power/ground ports have special rules\n   - Check 4 (optional): Check for duplicate wires in existingWires\n3. Implement getPortDirection(block: Block, portId: string): 'input' | 'output' | 'bidirectional'\n4. Implement canAcceptConnection(block: Block, portId: string): boolean for checking if port can accept more connections\n5. Export all validation functions for use in useWireDrawing hook",
            "status": "pending",
            "testStrategy": "Unit test each validation rule individually. Test valid output-to-input connection returns valid. Test same-component connection returns invalid with reason. Test same-port connection returns invalid. Test duplicate wire detection.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Wire Path Calculation from Component/Port Positions",
            "description": "Create utility functions to calculate wire endpoint positions based on component positions and port offsets, supporting dynamic recalculation when components are moved on the canvas.",
            "dependencies": [],
            "details": "Create `src/components/OneCanvas/utils/wirePathCalculator.ts`:\n\n1. Implement getPortAbsolutePosition(block: Block, portId: string): Position\n   - Get component position from block.position\n   - Get port relative offset from port definition in componentDefinitions\n   - Return absolute position: { x: block.position.x + port.offset.x, y: block.position.y + port.offset.y }\n\n2. Implement calculateWirePath(fromPos: Position, toPos: Position, mode: 'straight' | 'bezier'): string\n   - Straight mode: Generate orthogonal path with midpoint routing\n     * Calculate horizontal distance, route horizontally to midpoint, then vertically, then horizontally to end\n     * Return SVG path string: `M ${fromPos.x} ${fromPos.y} H ${midX} V ${toPos.y} H ${toPos.x}`\n   - Bezier mode: Generate smooth cubic bezier\n     * Calculate control points based on port directions\n     * Return SVG path string: `M ... C ...`\n\n3. Implement getWireEndpoints(wire: Wire, blocks: Block[]): { from: Position; to: Position }\n   - Look up source and target blocks\n   - Calculate absolute positions for both endpoints\n\n4. Export functions for use in Wire component and useWireDrawing hook",
            "status": "pending",
            "testStrategy": "Unit test getPortAbsolutePosition calculates correct absolute coordinates. Test calculateWirePath generates valid SVG path strings for both modes. Test getWireEndpoints correctly resolves wire endpoints from block data.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Temporary Wire Preview with Valid Target Highlighting",
            "description": "Implement the temporary wire preview that renders during the wire drawing operation, following the mouse cursor from the source port, with visual highlighting of valid drop target ports.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Enhance Wire.tsx and OneCanvas.tsx for preview rendering:\n\n1. Create WirePreview component or extend Wire.tsx:\n   - Render a wire from drawing.from port position to drawing.tempPos\n   - Use distinct styling (dashed line, different color, or opacity) to distinguish from permanent wires\n   - Wire preview should update in real-time as mouse moves\n\n2. Implement valid target highlighting in OneCanvas:\n   - When drawing is active, iterate through all ports\n   - For each port, call isValidConnection to check if it's a valid drop target\n   - Apply highlight styling (glow, color change, scale) to valid target ports\n   - Remove highlight when drawing ends or is cancelled\n\n3. Add visual feedback states:\n   - Port hover during draw: show connection point indicator\n   - Invalid target hover: show red indicator or subtle shake\n   - Valid target hover: show green indicator or pulse animation\n\n4. Integrate with Port component to handle mouseenter/mouseleave events during draw mode\n\n5. Use CSS transitions for smooth highlight animations",
            "status": "pending",
            "testStrategy": "Test wire preview renders from source port to mouse position. Test preview updates smoothly on mouse move. Test valid ports are highlighted during draw. Test invalid ports show rejection feedback. Test highlights clear on draw completion or cancel.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Create Wire component with SVG path rendering supporting straight/bezier modes and color coding by type. 2) Create useWireDrawing hook managing wire creation state (start, preview, end). 3) Implement connection validation logic (port direction, same-component check, duplicate wire check). 4) Implement wire path calculation from component/port positions. 5) Add temporary wire preview rendering during draw operation with valid target highlighting.",
        "updatedAt": "2026-01-28T13:30:55.216Z"
      },
      {
        "id": "41",
        "title": "Implement PLC I/O Blocks with ModServer Integration",
        "description": "Create plc_out and plc_in blocks that interface with the existing Modbus store to read/write coil and discrete input values, enabling real-time PLC simulation.",
        "details": "Create PLC blocks with Modbus integration:\n\n1. **PlcOutBlock.tsx:**\n```tsx\nfunction PlcOutBlock({ block }: { block: PlcOutBlock }) {\n  const { address, normallyOpen, inverted } = block.properties;\n  const coilValue = useModbusStore(selectCoil(address));\n  \n  // Determine if circuit is connected\n  const isConnected = normallyOpen \n    ? (coilValue !== inverted) \n    : (coilValue === inverted);\n  \n  return (\n    <div className={`plc-out-block ${isConnected ? 'connected' : 'open'}`}>\n      <span>M{address.toString().padStart(4, '0')}</span>\n      <span>{normallyOpen ? 'NO' : 'NC'}</span>\n      <Port port={inputPort} />\n      <Port port={outputPort} />\n    </div>\n  );\n}\n```\n\n2. **PlcInBlock.tsx:**\n```tsx\nfunction PlcInBlock({ block, voltage }: { block: PlcInBlock; voltage: number }) {\n  const { address, thresholdVoltage, inverted } = block.properties;\n  const { writeDiscreteInput } = useModbusStore();\n  \n  // Write to discrete input based on voltage threshold\n  useEffect(() => {\n    const isHigh = voltage >= thresholdVoltage;\n    const value = inverted ? !isHigh : isHigh;\n    writeDiscreteInput(address, value);\n  }, [voltage, address, thresholdVoltage, inverted]);\n  \n  return (...);\n}\n```\n\n3. **Address Format:** Display as M0001, M0002 (coil address format per PLC convention)\n\n4. **Properties Panel Integration:**\n- Address input (numeric, 0-9999 range)\n- Normally Open/Closed toggle\n- Invert checkbox\n- Threshold voltage slider for plc_in (0-30V range)\n\n5. **Real-time Subscription:**\n- Use Modbus event listeners from modbusStore for instant updates\n- Subscribe to `modbus:memory-changed` events",
        "testStrategy": "Integration test: set coil via modbusService, verify plc_out block state changes. Test plc_in writes correct value to discrete input based on circuit voltage. Test NO/NC logic with inverted flag combinations. Test address display formatting.",
        "priority": "high",
        "dependencies": [
          "40"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PlcOutBlock component with Modbus coil reading",
            "description": "Implement PlcOutBlock.tsx that displays Modbus address and NO/NC state by reading coil values from the existing modbusStore.",
            "dependencies": [],
            "details": "Create PlcOutBlock component in src/components/OneCanvas/blocks/ that:\n1. Accepts block props with PlcOutBlock type containing address, normallyOpen, and inverted properties\n2. Uses useModbusStore with selectCoil(address) selector to read current coil value\n3. Implements connection logic: for NO contacts, circuit connects when coil is true (XOR with inverted); for NC contacts, circuit connects when coil is false (XOR with inverted)\n4. Renders visual representation showing connection state (connected/open styling)\n5. Displays address in M0001 format placeholder (actual formatting in subtask 3)\n6. Includes input and output Port components for circuit connections\n7. Apply CSS classes for visual feedback: 'connected' state shows closed contact, 'open' state shows open contact",
            "status": "pending",
            "testStrategy": "Unit test NO/NC logic with inverted flag combinations (4 test cases). Test that component re-renders when modbusStore coil value changes. Test visual state matches connection logic. Mock useModbusStore to verify correct selector usage.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create PlcInBlock component with discrete input writing",
            "description": "Implement PlcInBlock.tsx that writes to discrete inputs in modbusStore based on incoming circuit voltage threshold.",
            "dependencies": [],
            "details": "Create PlcInBlock component in src/components/OneCanvas/blocks/ that:\n1. Accepts block props with PlcInBlock type containing address, thresholdVoltage, and inverted properties\n2. Receives voltage prop from circuit simulation (provided by parent/simulation engine)\n3. Uses useModbusStore to access writeDiscreteInput function\n4. Implements useEffect that triggers on voltage/address/thresholdVoltage/inverted changes:\n   - Compares voltage >= thresholdVoltage to determine isHigh state\n   - Applies inverted logic: value = inverted ? !isHigh : isHigh\n   - Calls writeDiscreteInput(address, value) to update Modbus memory\n5. Renders visual representation showing current input state (high/low)\n6. Displays address in DI format placeholder (actual formatting in subtask 3)\n7. Includes input Port component for circuit connection",
            "status": "pending",
            "testStrategy": "Unit test threshold comparison logic with various voltage values. Test inverted flag correctly flips output. Mock writeDiscreteInput and verify it's called with correct address and value. Test useEffect cleanup prevents stale writes. Test with edge case voltages (exactly at threshold, zero, max).",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement address formatting and properties panel integration",
            "description": "Create M0001 address formatting utility and integrate both PLC blocks with the properties panel for configuration.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement address formatting and properties panel:\n1. Create formatPlcAddress utility function:\n   - Takes numeric address (0-9999) and returns 'M' + padStart(4, '0') format (e.g., M0001, M0042)\n   - Handle edge cases: negative numbers, numbers > 9999\n2. Update PlcOutBlock and PlcInBlock to use formatPlcAddress for display\n3. Create/extend properties panel components for PLC blocks:\n   - Address input: numeric field with 0-9999 range validation, step=1\n   - Normally Open/Closed toggle (for PlcOutBlock): switch or radio buttons\n   - Invert checkbox: boolean toggle for signal inversion\n   - Threshold voltage slider (for PlcInBlock): range 0-30V with 0.1V step, display current value\n4. Wire properties panel to block.properties updates via appropriate store actions\n5. Add validation feedback for invalid address ranges",
            "status": "pending",
            "testStrategy": "Unit test formatPlcAddress with boundary values (0, 1, 9999, 10000). Test properties panel renders correct inputs for each block type. Test property changes update block state. Test validation rejects out-of-range addresses. Test threshold slider updates with correct precision.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Set up real-time subscription to Modbus memory change events",
            "description": "Implement event subscription to modbus:memory-changed events for instant UI updates when Modbus values change externally.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement real-time Modbus event subscription:\n1. Identify existing Modbus event emission in modbusStore/modbusService:\n   - Look for 'modbus:memory-changed' event pattern\n   - Understand event payload structure (address, value, type)\n2. Create useModbusSubscription hook or extend existing hooks:\n   - Subscribe to memory change events on mount\n   - Filter events by address range relevant to component\n   - Trigger re-render or state update on relevant changes\n3. Update PlcOutBlock to use subscription for coil changes:\n   - Ensure instant update when external source (e.g., ModServer) changes coil value\n   - Compare performance vs polling approach\n4. Update PlcInBlock to emit events when writing discrete inputs:\n   - Ensure other subscribers can react to input changes\n5. Implement cleanup in useEffect return to unsubscribe on unmount\n6. Add debouncing if needed to prevent excessive re-renders during rapid changes",
            "status": "pending",
            "testStrategy": "Integration test: emit modbus:memory-changed event and verify PlcOutBlock updates. Test subscription cleanup on component unmount prevents memory leaks. Test event filtering correctly ignores irrelevant address changes. Performance test with rapid event emission (100+ events/second). Test bidirectional: PlcInBlock write triggers event that other components receive.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create PlcOutBlock component displaying Modbus address and NO/NC state, reading from modbusStore. 2) Create PlcInBlock component that writes to discrete input based on circuit voltage. 3) Implement address formatting (M0001 format) and properties panel integration. 4) Set up real-time subscription to modbus:memory-changed events for instant updates.",
        "updatedAt": "2026-01-28T13:34:54.278Z"
      },
      {
        "id": "42",
        "title": "Implement Circuit Simulation Engine",
        "description": "Create the circuit simulation engine that calculates current paths from power sources through switches to loads and ground, determining which components receive power.",
        "details": "Create simulation engine in `src/components/OneCanvas/utils/`:\n\n1. **circuitSimulator.ts:**\n```typescript\ninterface SimulationResult {\n  nodeVoltages: Map<string, number>; // nodeId -> voltage\n  currentPaths: CurrentPath[];\n  poweredComponents: Set<string>;\n}\n\nfunction simulateCircuit(components: Block[], wires: Wire[]): SimulationResult {\n  // 1. Build circuit graph\n  const graph = buildCircuitGraph(components, wires);\n  \n  // 2. Find all power sources (+24V, +12V blocks)\n  const powerSources = components.filter(c => c.type.startsWith('power_'));\n  \n  // 3. For each power source, trace paths to GND\n  // Using modified nodal analysis or simple path tracing\n  \n  // 4. Determine switch states (plc_out, button)\n  // Switches either connect or break the path\n  \n  // 5. Calculate which nodes have voltage\n  // Propagate voltage through closed switches\n  \n  return { nodeVoltages, currentPaths, poweredComponents };\n}\n```\n\n2. **pathfinder.ts:**\n```typescript\n// BFS/DFS to find all paths from power to ground\nfunction findCurrentPaths(graph: CircuitGraph, powerNodeId: string, groundNodeId: string): string[][] {\n  // Return all paths that connect power to ground through closed switches\n}\n```\n\n3. **Graph Building:**\n- Each port is a node\n- Wires connect nodes\n- Switches are conditional edges (open/closed based on state)\n- Components consume/provide voltage\n\n4. **useSimulation.ts Hook:**\n```typescript\nfunction useSimulation() {\n  const { components, wires } = useCanvasStore();\n  const [result, setResult] = useState<SimulationResult | null>(null);\n  \n  useEffect(() => {\n    if (running) {\n      const interval = setInterval(() => {\n        setResult(simulateCircuit(components, wires));\n      }, 50); // 20Hz update rate\n      return () => clearInterval(interval);\n    }\n  }, [running, components, wires]);\n}\n```\n\n5. **Current Flow Animation:**\n- Powered wires show animated dashes\n- Direction indicated by animation direction",
        "testStrategy": "Unit tests for pathfinding algorithm. Test simple circuit: +24V -> switch(ON) -> LED -> GND = LED powered. Test switch OFF breaks circuit. Test branching circuits. Test multiple power sources don't interfere. Performance test with 100+ components.",
        "priority": "high",
        "dependencies": [
          "41"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Circuit Graph Builder",
            "description": "Create the graph building utilities that convert canvas components and wires into a traversable graph structure suitable for circuit simulation.",
            "dependencies": [],
            "details": "Create `src/components/OneCanvas/utils/circuitGraph.ts` with:\n\n1. **CircuitGraph Interface:**\n```typescript\ninterface CircuitNode {\n  id: string;\n  componentId: string;\n  portId: string;\n  type: 'power' | 'ground' | 'switch' | 'load' | 'junction';\n  voltage?: number;\n}\n\ninterface CircuitEdge {\n  from: string;  // nodeId\n  to: string;    // nodeId\n  wireId?: string;\n  conductance: boolean;  // false if open switch\n}\n\ninterface CircuitGraph {\n  nodes: Map<string, CircuitNode>;\n  edges: Map<string, CircuitEdge[]>;  // adjacency list\n  powerNodes: string[];\n  groundNodes: string[];\n}\n```\n\n2. **buildCircuitGraph(components: Block[], wires: Wire[]): CircuitGraph**\n- Create nodes for each component port\n- Mark power source nodes (+24V, +12V) as 'power' type\n- Mark GND blocks as 'ground' type\n- Create edges from wires connecting ports\n- Handle switch components as conditional edges\n\n3. **Node ID Generation:**\n- Use format: `${componentId}:${portId}` for unique node identification\n- Map wire endpoints to their connected nodes\n\n4. **Edge Building:**\n- For regular wires: bidirectional edges with conductance=true\n- For switches: edges that will be evaluated later based on state",
            "status": "done",
            "testStrategy": "Unit tests: Test graph building with simple 3-component circuit (power -> LED -> GND). Verify correct node types assigned. Test wire connections create proper edges. Test switch components create conditional edges. Test component with multiple ports creates multiple nodes.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T13:36:23.160Z"
          },
          {
            "id": 2,
            "title": "Implement Path Finding Algorithm",
            "description": "Create BFS/DFS-based path finding utilities to discover all current paths from power sources to ground nodes through the circuit graph.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/OneCanvas/utils/pathFinder.ts` with:\n\n1. **CurrentPath Interface:**\n```typescript\ninterface CurrentPath {\n  nodes: string[];      // Ordered list of node IDs from power to ground\n  powerSource: string;  // Starting power node ID\n  voltage: number;      // Voltage level of this path\n  isComplete: boolean;  // True if reaches ground\n}\n```\n\n2. **findCurrentPaths(graph: CircuitGraph, powerNodeId: string): CurrentPath[]**\n- Use BFS to find all paths from power node to ground nodes\n- Only traverse edges where conductance=true (closed switches)\n- Track visited nodes to prevent cycles\n- Return all complete paths that reach ground\n\n3. **findAllCircuitPaths(graph: CircuitGraph): CurrentPath[]**\n- Iterate over all power nodes in graph.powerNodes\n- Call findCurrentPaths for each power source\n- Aggregate and return all paths\n\n4. **Path Validation:**\n- Ensure paths don't create short circuits (power directly to ground)\n- Handle branching circuits where current splits\n- Support multiple independent power sources\n\n5. **Performance Optimization:**\n- Early termination when path reaches ground\n- Limit max path length to prevent infinite loops in malformed circuits\n- Use Set for O(1) visited node lookups",
            "status": "done",
            "testStrategy": "Unit tests: Test simple linear path (power -> switch -> LED -> GND). Test branching path (power splits to 2 LEDs). Test path not found when switch open. Test multiple power sources find independent paths. Test cycle detection doesn't hang. Performance test with 50+ node graph completes in <10ms.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T13:37:24.973Z"
          },
          {
            "id": 3,
            "title": "Implement Switch State Evaluation",
            "description": "Create the switch state evaluation system that determines whether switches are open or closed based on PLC outputs, button states, and other component states.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/OneCanvas/utils/switchEvaluator.ts` with:\n\n1. **SwitchState Interface:**\n```typescript\ninterface SwitchState {\n  componentId: string;\n  isOpen: boolean;       // true = no current flow, false = current flows\n  stateSource: 'plc' | 'button' | 'relay' | 'manual';\n}\n\ninterface SwitchStateMap {\n  states: Map<string, SwitchState>;\n}\n```\n\n2. **evaluateSwitchStates(components: Block[], runtimeState: RuntimeState): SwitchStateMap**\n- For 'plc_out' components: check corresponding PLC output bit state\n- For 'button' components: check if button is currently pressed\n- For 'relay' components: check if relay coil is energized\n- For 'toggle_switch': check manual toggle state\n\n3. **RuntimeState Integration:**\n```typescript\ninterface RuntimeState {\n  plcOutputs: Map<string, boolean>;    // address -> state\n  buttonStates: Map<string, boolean>;   // componentId -> pressed\n  manualOverrides: Map<string, boolean>; // componentId -> forced state\n}\n```\n\n4. **applySwitchStatesToGraph(graph: CircuitGraph, switchStates: SwitchStateMap): CircuitGraph**\n- Update edge conductance based on switch states\n- Return modified graph with current switch positions\n\n5. **NO/NC Contact Logic:**\n- Normally Open (NO): conductance = switchState.isOn\n- Normally Closed (NC): conductance = !switchState.isOn",
            "status": "done",
            "testStrategy": "Unit tests: Test PLC output ON makes switch closed. Test button pressed makes switch closed. Test NO vs NC contact logic inverts correctly. Test manual override takes precedence. Test switch state changes update graph edges correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T13:38:57.192Z"
          },
          {
            "id": 4,
            "title": "Implement Voltage Propagation Algorithm",
            "description": "Create the voltage propagation system that calculates which nodes have voltage by propagating power through closed switches to determine powered components.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create `src/components/OneCanvas/utils/voltagePropagator.ts` with:\n\n1. **SimulationResult Interface:**\n```typescript\ninterface SimulationResult {\n  nodeVoltages: Map<string, number>;  // nodeId -> voltage (0, 12, 24, etc.)\n  currentPaths: CurrentPath[];\n  poweredComponents: Set<string>;     // componentIds receiving power\n  shortCircuits: ShortCircuit[];      // Detected issues\n}\n\ninterface ShortCircuit {\n  path: string[];\n  powerSource: string;\n}\n```\n\n2. **propagateVoltage(graph: CircuitGraph, paths: CurrentPath[]): Map<string, number>**\n- Start from power source nodes with their voltage level\n- BFS propagation through conductive edges\n- Each node inherits voltage from its power source\n- Nodes not in any path have voltage = 0\n\n3. **determinePoweredComponents(nodeVoltages: Map<string, number>, components: Block[]): Set<string>**\n- A component is powered if it has voltage on input AND path to ground\n- Check load components (LED, motor, lamp) for complete circuit\n- Return set of component IDs that should be visually active\n\n4. **detectShortCircuits(paths: CurrentPath[]): ShortCircuit[]**\n- Check for paths with no load between power and ground\n- Warn about potential short circuit conditions\n\n5. **simulateCircuit(components: Block[], wires: Wire[], runtimeState: RuntimeState): SimulationResult**\n- Main simulation function combining all steps:\n  1. Build circuit graph\n  2. Evaluate switch states\n  3. Apply switch states to graph\n  4. Find current paths\n  5. Propagate voltage\n  6. Determine powered components",
            "status": "done",
            "testStrategy": "Unit tests: Test voltage propagates from +24V source correctly. Test open switch blocks voltage propagation. Test load component shows powered only with complete circuit. Test multiple voltage levels don't mix (24V and 12V independent). Test short circuit detection identifies direct power-to-ground paths.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T13:40:15.442Z"
          },
          {
            "id": 5,
            "title": "Create useSimulation Hook with Update Loop",
            "description": "Implement the useSimulation React hook that manages simulation state and runs the circuit simulation at 20Hz using requestAnimationFrame for smooth updates.",
            "dependencies": [
              4
            ],
            "details": "Create `src/components/OneCanvas/hooks/useSimulation.ts` with:\n\n1. **Hook Interface:**\n```typescript\ninterface UseSimulationReturn {\n  running: boolean;\n  result: SimulationResult | null;\n  start: () => void;\n  stop: () => void;\n  reset: () => void;\n  runtimeState: RuntimeState;\n  setPlcOutput: (address: string, value: boolean) => void;\n  setButtonState: (componentId: string, pressed: boolean) => void;\n}\n```\n\n2. **useSimulation Hook Implementation:**\n```typescript\nexport function useSimulation(): UseSimulationReturn {\n  const { components, wires } = useCanvasStore();\n  const [running, setRunning] = useState(false);\n  const [result, setResult] = useState<SimulationResult | null>(null);\n  const [runtimeState, setRuntimeState] = useState<RuntimeState>(initialState);\n  const lastUpdateRef = useRef<number>(0);\n  \n  useEffect(() => {\n    if (!running) return;\n    \n    let frameId: number;\n    const UPDATE_INTERVAL = 50; // 20Hz = 50ms\n    \n    const tick = (timestamp: number) => {\n      if (timestamp - lastUpdateRef.current >= UPDATE_INTERVAL) {\n        setResult(simulateCircuit(components, wires, runtimeState));\n        lastUpdateRef.current = timestamp;\n      }\n      frameId = requestAnimationFrame(tick);\n    };\n    \n    frameId = requestAnimationFrame(tick);\n    return () => cancelAnimationFrame(frameId);\n  }, [running, components, wires, runtimeState]);\n}\n```\n\n3. **State Management:**\n- Track PLC output states via setPlcOutput\n- Track button press states via setButtonState\n- Reset clears all runtime state and result\n\n4. **Performance Considerations:**\n- Use useMemo for stable runtimeState reference\n- Only re-run simulation when inputs change\n- Throttle to 20Hz even with faster frame rates",
            "status": "done",
            "testStrategy": "Unit tests: Test start() sets running=true and begins simulation. Test stop() halts simulation loop. Test reset() clears result and runtime state. Test simulation updates at ~20Hz rate. Test setPlcOutput updates state and triggers re-simulation. Integration test with React Testing Library verifying hook behavior.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T13:41:25.515Z"
          },
          {
            "id": 6,
            "title": "Add Current Flow Animation System",
            "description": "Implement the visual animation system that shows current flow on powered wires with animated dashes indicating direction and flow status.",
            "dependencies": [
              4,
              5
            ],
            "details": "Create `src/components/OneCanvas/components/AnimatedWire.tsx` and update wire rendering:\n\n1. **AnimatedWire Component:**\n```typescript\ninterface AnimatedWireProps {\n  wire: Wire;\n  isPowered: boolean;\n  currentDirection: 'forward' | 'reverse' | null;\n  voltage: number;\n}\n\nfunction AnimatedWire({ wire, isPowered, currentDirection, voltage }: AnimatedWireProps) {\n  // Use CSS animation for flowing dashes\n  const animationClass = isPowered \n    ? `wire-flow-${currentDirection}` \n    : 'wire-idle';\n  \n  const strokeColor = isPowered \n    ? getVoltageColor(voltage)  // Different colors for 24V vs 12V\n    : 'gray';\n}\n```\n\n2. **CSS Animations (add to OneCanvas.css):**\n```css\n.wire-flow-forward {\n  stroke-dasharray: 8 4;\n  animation: dash-flow-forward 0.5s linear infinite;\n}\n\n@keyframes dash-flow-forward {\n  to { stroke-dashoffset: -12; }\n}\n\n.wire-flow-reverse {\n  animation: dash-flow-reverse 0.5s linear infinite;\n}\n```\n\n3. **Current Direction Calculation:**\n- In currentPaths, track direction from power to ground\n- Wire direction = direction in path it belongs to\n- Wires in multiple paths: use dominant direction\n\n4. **Visual States:**\n- Unpowered: solid gray line\n- Powered (24V): animated blue dashes flowing toward ground\n- Powered (12V): animated green dashes flowing toward ground\n- Short circuit: red pulsing line (warning indicator)\n\n5. **Wire Rendering Integration:**\n- Update WireLayer to use simulation result\n- Pass isPowered and direction to each wire\n- Optimize: only animate visible wires in viewport",
            "status": "done",
            "testStrategy": "Visual tests: Verify powered wires show animated dashes. Verify animation direction points toward ground. Verify different voltage levels have distinct colors. Test animation stops when simulation pauses. Performance test: 50+ animated wires maintain 60fps. Test short circuit wires show warning indicator.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T13:42:50.442Z"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down into: 1) Implement circuit graph builder that converts components and wires into traversable graph structure. 2) Implement path finding algorithm (BFS/DFS) to find all paths from power sources to ground. 3) Implement switch state evaluation (open/closed based on PLC output and button states). 4) Implement voltage propagation through closed switches. 5) Create useSimulation hook with 20Hz update loop using requestAnimationFrame. 6) Add current flow animation system for powered wires.",
        "updatedAt": "2026-01-28T13:42:50.442Z"
      },
      {
        "id": "43",
        "title": "Implement Button Block with Interaction States",
        "description": "Create the Button block supporting momentary (press-hold) and stationary (toggle) modes with multiple contact configurations (1a, 1b, 1a1b, etc.) and user interaction handling.",
        "details": "Create Button block in `src/components/OneCanvas/components/ButtonBlock.tsx`:\n\n1. **Contact Configuration Types:**\n```typescript\ntype ContactConfig = '1a' | '1b' | '1a1b' | '2a' | '2b' | '2a2b' | '3a3b';\n\n// 'a' = normally open (NO), 'b' = normally closed (NC)\n// '1a1b' = one NO + one NC contact pair\n// Determine ports based on config\nfunction getPortsForConfig(config: ContactConfig): Port[] {\n  switch (config) {\n    case '1a': return [commonPort, noPort];\n    case '1b': return [commonPort, ncPort];\n    case '1a1b': return [commonPort, noPort, ncPort];\n    // etc.\n  }\n}\n```\n\n2. **ButtonBlock.tsx:**\n```tsx\nfunction ButtonBlock({ block }: { block: ButtonBlock }) {\n  const { momentary, contactConfig } = block.properties;\n  const [pressed, setPressed] = useState(false);\n  \n  const handleMouseDown = () => {\n    setPressed(true);\n    if (!momentary) return; // Toggle handles differently\n  };\n  \n  const handleMouseUp = () => {\n    if (momentary) setPressed(false);\n  };\n  \n  const handleClick = () => {\n    if (!momentary) setPressed(p => !p); // Toggle\n  };\n  \n  // Visual: Button shape, pressed state visual feedback\n  // Contact indicators show open/closed state\n}\n```\n\n3. **Switch State in Simulation:**\n- NO contacts: closed when pressed, open when released\n- NC contacts: open when pressed, closed when released\n- Both change simultaneously\n\n4. **Tauri Commands for External Control:**\n- `canvas_button_press(buttonId)` - Press button\n- `canvas_button_release(buttonId)` - Release button  \n- `canvas_button_toggle(buttonId)` - Toggle stationary button\n\n5. **Visual Design:**\n- Square button shape with beveled edge\n- Pressed state: darker color, inset shadow\n- Contact indicators: small circles showing NO/NC state",
        "testStrategy": "Test momentary button releases on mouseup. Test toggle button maintains state. Test all contact configurations wire correctly. Test keyboard activation (Enter/Space when focused). Test Tauri command integration.",
        "priority": "medium",
        "dependencies": [
          "42"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Contact Configuration Types and Port Generation Function",
            "description": "Create TypeScript types for all contact configurations (1a, 1b, 1a1b, 2a, 2b, 2a2b, 3a3b) and implement a port generation function that returns the appropriate ports based on configuration.",
            "dependencies": [],
            "details": "Create `src/components/OneCanvas/types/buttonTypes.ts` with:\n\n1. **ContactConfig type:**\n```typescript\ntype ContactConfig = '1a' | '1b' | '1a1b' | '2a' | '2b' | '2a2b' | '3a3b';\n```\n\n2. **Port definitions:**\n- Define common port (shared terminal)\n- Define NO (normally open) port structure\n- Define NC (normally closed) port structure\n\n3. **getPortsForConfig function:**\n- '1a': [common, 1xNO] - 2 ports\n- '1b': [common, 1xNC] - 2 ports  \n- '1a1b': [common, 1xNO, 1xNC] - 3 ports\n- '2a': [common, 2xNO] - 3 ports\n- '2b': [common, 2xNC] - 3 ports\n- '2a2b': [common, 2xNO, 2xNC] - 5 ports\n- '3a3b': [common, 3xNO, 3xNC] - 7 ports\n\n4. **Port metadata:**\n- Each port should include type ('common' | 'no' | 'nc'), position, and label for visual rendering",
            "status": "done",
            "testStrategy": "Unit tests for getPortsForConfig verifying correct port count and types for each configuration. Test that common port is always present. Verify NO/NC port counts match the configuration number.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:19:03.739Z"
          },
          {
            "id": 2,
            "title": "Implement ButtonBlock Component with Momentary and Toggle Modes",
            "description": "Create the ButtonBlock React component supporting both momentary (press-hold) and stationary (toggle) interaction modes with proper event handling.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/OneCanvas/components/ButtonBlock.tsx`:\n\n1. **Component structure:**\n```tsx\nfunction ButtonBlock({ block }: { block: ButtonBlockType }) {\n  const { momentary, contactConfig } = block.properties;\n  const [pressed, setPressed] = useState(false);\n  \n  // Event handlers\n  const handleMouseDown = () => setPressed(true);\n  const handleMouseUp = () => { if (momentary) setPressed(false); };\n  const handleClick = () => { if (!momentary) setPressed(p => !p); };\n}\n```\n\n2. **Momentary mode:** Button pressed on mousedown, released on mouseup/mouseleave\n\n3. **Toggle mode:** Button toggles state on click, stays in new state\n\n4. **Keyboard accessibility:**\n- Space/Enter key support for activation\n- Focus states for accessibility\n\n5. **Port rendering:** Use getPortsForConfig to determine which ports to render based on contactConfig property",
            "status": "done",
            "testStrategy": "Test momentary button releases on mouseup and mouseleave. Test toggle button maintains state after click. Test keyboard activation with Enter and Space keys. Verify all 7 contact configurations render correct number of ports.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:19:03.751Z"
          },
          {
            "id": 3,
            "title": "Implement Contact State Logic for NO/NC Contacts",
            "description": "Implement the electrical contact state logic where NO (normally open) contacts close when pressed and NC (normally closed) contacts open when pressed, both changing simultaneously.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add contact state logic to integrate with simulation engine:\n\n1. **Contact state interface:**\n```typescript\ninterface ContactState {\n  portId: string;\n  type: 'no' | 'nc';\n  isClosed: boolean;\n}\n```\n\n2. **State calculation based on pressed state:**\n- NO contacts: `isClosed = pressed` (closed when pressed, open when released)\n- NC contacts: `isClosed = !pressed` (open when pressed, closed when released)\n\n3. **Export contact states for simulation:**\n- Provide method to get current contact states for all ports\n- Emit state change events when button state changes\n- Integration point with circuit simulator (Task 42)\n\n4. **Simultaneous state changes:** All contacts must update atomically when button state changes to prevent simulation glitches",
            "status": "done",
            "testStrategy": "Test NO contact closes when button pressed. Test NC contact opens when button pressed. Test both NO and NC change simultaneously. Test state reversal on release. Integration test with circuit simulator verifying current flow through contacts.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:19:03.762Z"
          },
          {
            "id": 4,
            "title": "Add Tauri Command Integration and Visual Feedback",
            "description": "Implement Tauri commands for external button control (press/release/toggle) and visual feedback showing pressed state and contact indicators.",
            "dependencies": [
              2,
              3
            ],
            "details": "1. **Tauri Commands in src-tauri/src/canvas/commands.rs:**\n```rust\n#[tauri::command]\npub async fn canvas_button_press(button_id: String) -> Result<(), String>\n\n#[tauri::command]\npub async fn canvas_button_release(button_id: String) -> Result<(), String>\n\n#[tauri::command]\npub async fn canvas_button_toggle(button_id: String) -> Result<(), String>\n```\n\n2. **Frontend event listeners:** Subscribe to Tauri events for external button control\n\n3. **Visual design:**\n- Square button shape with beveled edge (3D appearance)\n- Default state: raised, lighter color\n- Pressed state: darker color, inset shadow effect\n- Transition animation for smooth press feedback\n\n4. **Contact indicators:**\n- Small circles near each port\n- NO ports: hollow circle when open, filled when closed\n- NC ports: filled circle when closed, hollow when open\n- Color coding: green when closed (conducting), red when open",
            "status": "done",
            "testStrategy": "Test Tauri canvas_button_press sets button to pressed state. Test canvas_button_release releases momentary button. Test canvas_button_toggle toggles stationary button. Verify visual feedback shows correct pressed/released appearance. Test contact indicators update correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:19:03.772Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Define contact configuration types and port generation function for each config (1a, 1b, 1a1b, 2a, 2b, 2a2b, 3a3b). 2) Implement ButtonBlock component with momentary (mousedown/mouseup) and toggle (click) modes. 3) Implement contact state logic (NO contacts close on press, NC contacts open on press). 4) Add Tauri command integration for external button control and visual feedback for pressed state.",
        "updatedAt": "2026-01-28T17:19:03.772Z"
      },
      {
        "id": "44",
        "title": "Implement Properties Panel for Component Editing",
        "description": "Create the PropertiesPanel component that displays and allows editing of the selected component's properties, including address configuration, visual settings, and simulation parameters.",
        "details": "Enhance `src/components/panels/content/PropertiesPanel.tsx` for OneCanvas:\n\n1. **Property Editor Router:**\n```tsx\nfunction PropertiesPanel() {\n  const { selectedIds, components } = useCanvasStore();\n  \n  if (selectedIds.size === 0) return <NoSelectionView />;\n  if (selectedIds.size > 1) return <MultiSelectionView count={selectedIds.size} />;\n  \n  const component = components.get([...selectedIds][0]);\n  \n  switch (component?.type) {\n    case 'plc_out': return <PlcOutProperties component={component} />;\n    case 'plc_in': return <PlcInProperties component={component} />;\n    case 'led': return <LedProperties component={component} />;\n    case 'button': return <ButtonProperties component={component} />;\n    case 'scope': return <ScopeProperties component={component} />;\n    default: return <BasicProperties component={component} />;\n  }\n}\n```\n\n2. **Common Properties:**\n- ID (read-only)\n- Position X, Y (editable, with snap)\n- Label/Name (optional custom label)\n\n3. **PlcOutProperties:**\n- Address input (M0000-M9999)\n- Normally Open/Closed radio\n- Inverted checkbox\n\n4. **LedProperties:**\n- Color dropdown (red/green/blue/yellow/white)\n- Forward voltage display (read-only, based on color)\n\n5. **ButtonProperties:**\n- Mode: Momentary/Stationary radio\n- Contact configuration dropdown\n- Current state indicator\n\n6. **Form Components:**\n- Use controlled inputs bound to store\n- Debounce updates for text inputs\n- Immediate update for toggles/selects\n- Validation with error messages",
        "testStrategy": "Test property changes reflect in component. Test validation prevents invalid addresses. Test multi-select shows count instead of properties. Test keyboard navigation within properties panel.",
        "priority": "medium",
        "dependencies": [
          "43"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PropertiesPanel Router with Selection State Handling",
            "description": "Implement the main PropertiesPanel component that routes to appropriate editors based on selection state and component type.",
            "dependencies": [],
            "details": "Create the PropertiesPanel router in `src/components/panels/content/PropertiesPanel.tsx`:\n\n1. **Selection State Handling:**\n   - Get `selectedIds` and `components` from useCanvasStore\n   - Render `NoSelectionView` when selectedIds.size === 0 (empty state with instruction text)\n   - Render `MultiSelectionView` when selectedIds.size > 1 (show count of selected items)\n   - For single selection, retrieve component from Map and route to type-specific editor\n\n2. **Component Type Router (switch statement):**\n   - 'plc_out' -> PlcOutProperties\n   - 'plc_in' -> PlcInProperties\n   - 'led' -> LedProperties\n   - 'button' -> ButtonProperties\n   - 'scope' -> ScopeProperties\n   - default -> BasicProperties\n\n3. **Empty State Components:**\n   - NoSelectionView: Display 'Select a component to view its properties'\n   - MultiSelectionView: Display '{count} components selected' with optional bulk actions placeholder\n\n4. **Panel Layout:**\n   - Use consistent panel header with title 'Properties'\n   - Scrollable content area for property editors\n   - Consistent padding and spacing with shadcn/ui components",
            "status": "pending",
            "testStrategy": "Test that NoSelectionView renders when no components selected. Test MultiSelectionView renders with correct count when multiple selected. Test correct property editor renders for each component type. Test panel updates reactively when selection changes in canvasStore.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Common Property Fields Component",
            "description": "Implement shared property fields (ID, position, label) that are reused across all component type editors.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/panels/content/properties/CommonProperties.tsx`:\n\n1. **ID Field (Read-Only):**\n   - Display component ID with copy-to-clipboard button\n   - Monospace font for consistent display\n   - Label: 'Component ID'\n\n2. **Position Fields (Editable):**\n   - X and Y number inputs in a row layout\n   - Step value aligned with canvas grid snap (e.g., 10px)\n   - Min/max bounds based on canvas dimensions\n   - Labels: 'X' and 'Y' with unit indicator 'px'\n   - Use Input component from shadcn/ui\n\n3. **Label/Name Field (Optional):**\n   - Text input for custom component label\n   - Placeholder: 'Custom label (optional)'\n   - Max length constraint (e.g., 50 characters)\n   - This overrides default component display name\n\n4. **Component Structure:**\n```tsx\ninterface CommonPropertiesProps {\n  component: Block;\n  onChange: (updates: Partial<Block>) => void;\n}\n```\n\n5. **UI Layout:**\n   - Group fields in a collapsible section 'General'\n   - Use consistent label-input spacing\n   - Apply shadcn/ui form patterns",
            "status": "pending",
            "testStrategy": "Test ID field displays correctly and is not editable. Test position inputs update component position. Test position respects min/max bounds. Test label field accepts text and clears properly. Test onChange callback fires with correct partial updates.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create Type-Specific Property Editors with Validation",
            "description": "Implement PlcOutProperties, PlcInProperties, LedProperties, ButtonProperties, ScopeProperties, and BasicProperties editors with field validation.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create property editors in `src/components/panels/content/properties/`:\n\n1. **PlcOutProperties.tsx:**\n   - Address input: M0000-M9999 pattern validation with regex\n   - Show validation error for invalid address format\n   - Contact Type: RadioGroup for Normally Open / Normally Closed\n   - Inverted: Checkbox with label 'Invert output'\n   - Include CommonProperties at top\n\n2. **PlcInProperties.tsx:**\n   - Similar structure to PlcOutProperties\n   - Address input with validation\n   - Contact configuration options\n\n3. **LedProperties.tsx:**\n   - Color: Select dropdown (red/green/blue/yellow/white)\n   - Forward Voltage: Read-only field showing voltage based on color\n   - Color-to-voltage mapping: { red: 2.0V, green: 2.2V, blue: 3.2V, yellow: 2.1V, white: 3.3V }\n   - Include CommonProperties at top\n\n4. **ButtonProperties.tsx:**\n   - Mode: RadioGroup for Momentary / Stationary\n   - Contact Config: Select dropdown (NO/NC/SPDT)\n   - Current State: Read-only indicator showing pressed/released\n   - Include CommonProperties at top\n\n5. **ScopeProperties.tsx:**\n   - Time range settings\n   - Channel configuration\n   - Include CommonProperties at top\n\n6. **BasicProperties.tsx:**\n   - Fallback editor showing only CommonProperties\n   - Display component type as info text\n\n7. **Validation Patterns:**\n   - Use Zod schemas for each property type\n   - Display inline error messages below invalid fields\n   - Prevent invalid data from being submitted to store",
            "status": "pending",
            "testStrategy": "Test PlcOut address validation accepts M0000-M9999 and rejects invalid formats. Test LED color change updates forward voltage display. Test Button mode toggle between Momentary/Stationary. Test validation errors display correctly. Test all editors include CommonProperties. Test BasicProperties renders for unknown types.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Form State Binding with Debounced Store Updates",
            "description": "Create form handling infrastructure with controlled inputs, debounced text updates, immediate toggle updates, and error state management.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create `src/components/panels/content/properties/usePropertyForm.ts` hook and utilities:\n\n1. **usePropertyForm Hook:**\n```tsx\nfunction usePropertyForm<T>(component: Block, schema: ZodSchema<T>) {\n  const updateComponent = useCanvasStore(s => s.updateComponent);\n  const [localState, setLocalState] = useState<T>(...);\n  const [errors, setErrors] = useState<Record<string, string>>({});\n  \n  // Return controlled input handlers and error state\n  return { values, errors, handleChange, handleBlur };\n}\n```\n\n2. **Debounced Text Input Updates:**\n   - Use useDebouncedCallback from use-debounce (500ms delay)\n   - Local state updates immediately for responsive typing\n   - Store update fires after debounce delay\n   - Cancel pending debounce on unmount or component change\n\n3. **Immediate Updates for Toggles/Selects:**\n   - Checkboxes, radio buttons, and select dropdowns update store immediately\n   - No debounce needed for discrete value changes\n   - Validate before committing to store\n\n4. **Error State Management:**\n   - Track validation errors per field\n   - Clear error when field becomes valid\n   - Show error message below field using FormMessage pattern\n   - Prevent store update when validation fails\n\n5. **Store Integration:**\n   - Call `updateComponent(id, updates)` to persist changes\n   - Handle optimistic updates with rollback on failure\n   - Sync local state when external store changes (e.g., undo/redo)\n\n6. **Keyboard Navigation:**\n   - Tab through form fields\n   - Enter to confirm text inputs\n   - Escape to revert unsaved changes",
            "status": "pending",
            "testStrategy": "Test text input debounces updates (type quickly, verify single store update). Test checkbox/select updates immediately without debounce. Test validation errors prevent store updates. Test errors clear when field becomes valid. Test external store changes sync to form state. Test keyboard navigation works correctly. Test pending debounce cancels on component unmount.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create PropertiesPanel router that renders appropriate editor based on selected component type. 2) Create common property fields (ID, position, label) shared across all blocks. 3) Create type-specific property editors (PlcOutProperties, LedProperties, ButtonProperties) with validation. 4) Implement form state binding with debounced updates to canvasStore.",
        "updatedAt": "2026-01-28T17:24:18.570Z"
      },
      {
        "id": "45",
        "title": "Implement Circuit YAML Serialization and Tauri Commands",
        "description": "Create serialization utilities to convert circuit state to/from YAML format, and implement Tauri commands for saving, loading, and creating circuit files.",
        "details": "Create serialization and Tauri integration:\n\n1. **serialization.ts:**\n```typescript\nimport * as yaml from 'yaml'; // Add yaml package to dependencies\n\ninterface CircuitYaml {\n  metadata: { name: string; description: string; tags: string[]; };\n  circuit: {\n    components: ComponentYaml[];\n    wires: WireYaml[];\n  };\n}\n\nfunction circuitToYaml(state: CircuitState): string {\n  const yamlData: CircuitYaml = {\n    metadata: state.metadata,\n    circuit: {\n      components: [...state.components.values()].map(componentToYaml),\n      wires: state.wires.map(wireToYaml),\n    },\n  };\n  return yaml.stringify(yamlData);\n}\n\nfunction yamlToCircuit(yamlString: string): CircuitState {\n  const data = yaml.parse(yamlString) as CircuitYaml;\n  // Validate and convert to internal format\n  return { ... };\n}\n```\n\n2. **Rust Tauri Commands in `src-tauri/src/commands/canvas.rs`:**\n```rust\n#[tauri::command]\nasync fn canvas_save_circuit(path: String, content: String) -> Result<(), ModOneError> {\n  std::fs::write(&path, content)?;\n  Ok(())\n}\n\n#[tauri::command]\nasync fn canvas_load_circuit(path: String) -> Result<String, ModOneError> {\n  let content = std::fs::read_to_string(&path)?;\n  Ok(content)\n}\n\n#[tauri::command]\nasync fn canvas_create_circuit(name: String, path: String) -> Result<(), ModOneError> {\n  let default_circuit = create_default_circuit(&name);\n  std::fs::write(&path, default_circuit)?;\n  Ok(())\n}\n```\n\n3. **Frontend Service in `src/services/canvasService.ts`:**\n```typescript\nexport const canvasService = {\n  async saveCircuit(path: string, state: CircuitState): Promise<void>,\n  async loadCircuit(path: string): Promise<CircuitState>,\n  async createCircuit(name: string, path: string): Promise<void>,\n};\n```\n\n4. **Integration with Project System:**\n- Circuit files stored in project's `circuits/` folder\n- Reference in project config's canvas_data field",
        "testStrategy": "Test YAML serialization round-trip preserves all data. Test file save creates valid file. Test load parses all component types. Test error handling for invalid YAML. Test integration with project system.",
        "priority": "medium",
        "dependencies": [
          "42"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add yaml package dependency and create circuitToYaml serialization function",
            "description": "Install the yaml npm package and implement the circuitToYaml function that converts CircuitState (with Map-based components) to a YAML string representation using the CircuitYaml interface.",
            "dependencies": [],
            "details": "1. Add yaml package to project dependencies using pnpm: `pnpm add yaml`\n2. Create `src/components/OneCanvas/utils/serialization.ts` with:\n   - Define CircuitYaml interface with metadata and circuit properties\n   - Define ComponentYaml interface for serializable component representation\n   - Define WireYaml interface for serializable wire representation\n   - Implement componentToYaml() helper to convert Block to ComponentYaml\n   - Implement wireToYaml() helper to convert Wire to WireYaml\n   - Implement circuitToYaml(state: CircuitState): string function that:\n     - Extracts metadata from state\n     - Converts Map<string, Block> to ComponentYaml[] array\n     - Converts Wire[] to WireYaml[] array\n     - Uses yaml.stringify() to produce the final YAML string\n3. Export all interfaces and the circuitToYaml function",
            "status": "pending",
            "testStrategy": "Unit tests: Test circuitToYaml with empty circuit produces valid YAML. Test with single component. Test with multiple components and wires. Test that Map iteration order is handled correctly. Verify metadata fields are preserved. Test special characters in names are properly escaped.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create yamlToCircuit deserialization function with validation",
            "description": "Implement the yamlToCircuit function that parses a YAML string and converts it back to CircuitState with comprehensive validation and error handling for malformed files.",
            "dependencies": [
              1
            ],
            "details": "1. In `src/components/OneCanvas/utils/serialization.ts`, implement:\n   - yamlToComponent(yaml: ComponentYaml): Block - convert YAML component to Block\n   - yamlToWire(yaml: WireYaml): Wire - convert YAML wire to Wire\n   - validateCircuitYaml(data: unknown): CircuitYaml - validate parsed YAML structure\n   - yamlToCircuit(yamlString: string): CircuitState function that:\n     - Parses YAML string using yaml.parse()\n     - Validates the structure using validateCircuitYaml()\n     - Creates new Map<string, Block> from components array\n     - Rebuilds Wire[] array with proper references\n     - Returns complete CircuitState object\n2. Implement validation checks:\n   - Required fields presence (metadata, circuit, components, wires)\n   - Component type validation against known block types\n   - Wire endpoint validation (ensure referenced component IDs exist)\n   - Numeric field range validation (positions, dimensions)\n3. Throw descriptive errors for invalid YAML with line context when possible",
            "status": "pending",
            "testStrategy": "Unit tests: Test yamlToCircuit with valid YAML produces correct CircuitState. Test round-trip: circuitToYaml -> yamlToCircuit preserves all data. Test validation rejects missing required fields. Test validation rejects invalid component types. Test validation rejects wires referencing non-existent components. Test helpful error messages for common malformed inputs.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Rust Tauri commands for circuit file operations",
            "description": "Create the Rust backend commands for saving, loading, and creating circuit files in src-tauri/src/commands/canvas.rs, following existing command patterns.",
            "dependencies": [],
            "details": "1. Create `src-tauri/src/commands/canvas.rs` with:\n   - canvas_save_circuit(path: String, content: String) -> Result<(), ModOneError>\n     - Write content to file at path\n     - Use std::fs::write with proper error handling\n     - Return ModOneError for filesystem errors\n   - canvas_load_circuit(path: String) -> Result<String, ModOneError>\n     - Read file content from path\n     - Use std::fs::read_to_string\n     - Return file not found or read errors as ModOneError\n   - canvas_create_circuit(name: String, path: String) -> Result<(), ModOneError>\n     - Create default circuit YAML content with provided name\n     - Write to specified path\n     - Implement create_default_circuit(name: &str) -> String helper\n2. Add module to src-tauri/src/commands/mod.rs\n3. Register commands in src-tauri/src/main.rs invoke_handler\n4. Follow existing ModOneError patterns for consistent error handling",
            "status": "pending",
            "testStrategy": "Unit tests: Test canvas_save_circuit creates file with correct content. Test canvas_load_circuit reads existing file. Test canvas_load_circuit returns error for non-existent file. Test canvas_create_circuit creates valid default circuit YAML. Integration test: save then load returns same content.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create frontend canvasService wrapping Tauri commands",
            "description": "Implement the canvasService in src/services/canvasService.ts that provides a TypeScript API for circuit file operations, wrapping the Tauri commands with proper type safety.",
            "dependencies": [
              1,
              3
            ],
            "details": "1. Create `src/services/canvasService.ts` with:\n   - Import Tauri invoke function and serialization utilities\n   - saveCircuit(path: string, state: CircuitState): Promise<void>\n     - Convert state to YAML using circuitToYaml()\n     - Call canvas_save_circuit Tauri command\n     - Handle and transform errors appropriately\n   - loadCircuit(path: string): Promise<CircuitState>\n     - Call canvas_load_circuit Tauri command\n     - Parse result using yamlToCircuit()\n     - Handle file not found and parsing errors\n   - createCircuit(name: string, path: string): Promise<void>\n     - Call canvas_create_circuit Tauri command\n     - Handle directory creation errors\n2. Export canvasService object with all methods\n3. Add proper TypeScript types for all parameters and returns\n4. Implement error wrapping to provide user-friendly error messages",
            "status": "pending",
            "testStrategy": "Integration tests: Mock Tauri invoke and test saveCircuit calls correct command with serialized YAML. Test loadCircuit deserializes returned content. Test createCircuit passes correct parameters. Test error handling for Tauri command failures. Test error handling for serialization/deserialization failures.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate circuit files with project system",
            "description": "Integrate the canvasService with the existing project system, ensuring circuit files are stored in the project's circuits/ folder and referenced in the project configuration.",
            "dependencies": [
              2,
              4
            ],
            "details": "1. Update project types to support circuit references:\n   - Add circuits field to project config interface\n   - Define CircuitReference type with path and metadata\n2. Create circuit file management utilities:\n   - getCircuitsDirectory(projectPath: string): string - returns circuits/ subfolder path\n   - ensureCircuitsDirectory(projectPath: string): Promise<void> - creates folder if needed\n   - listProjectCircuits(projectPath: string): Promise<CircuitReference[]>\n3. Extend canvasService with project-aware methods:\n   - saveProjectCircuit(projectPath: string, name: string, state: CircuitState): Promise<string>\n   - loadProjectCircuit(projectPath: string, name: string): Promise<CircuitState>\n   - createProjectCircuit(projectPath: string, name: string): Promise<string>\n4. Update project save/load to handle canvas_data field referencing circuit files\n5. Ensure circuit file paths are relative to project root for portability",
            "status": "pending",
            "testStrategy": "Integration tests: Test circuit saved in correct project subdirectory. Test circuit listed in project's circuit references. Test loading circuit by reference. Test project with multiple circuits. Test circuit file paths are relative and portable. Test project open/close properly handles circuit references.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Add yaml package dependency and create circuitToYaml serialization function. 2) Create yamlToCircuit deserialization function with validation. 3) Implement Rust Tauri commands (canvas_save_circuit, canvas_load_circuit, canvas_create_circuit). 4) Create frontend canvasService wrapping Tauri commands. 5) Integrate with project system for circuit file management.",
        "updatedAt": "2026-01-28T17:28:40.278Z"
      },
      {
        "id": "46",
        "title": "Implement Selection, Copy/Paste, and Keyboard Shortcuts",
        "description": "Add comprehensive selection handling (click, shift-click, ctrl-click, drag-select), clipboard operations (copy/paste/cut/duplicate), and canvas-specific keyboard shortcuts.",
        "details": "Implement selection and clipboard in `src/components/OneCanvas/`:\n\n1. **SelectionBox.tsx:**\n```tsx\nfunction SelectionBox() {\n  const [box, setBox] = useState<{ start: Position; end: Position } | null>(null);\n  \n  // Show during drag-select\n  if (!box) return null;\n  \n  return (\n    <div style={{\n      position: 'absolute',\n      left: Math.min(box.start.x, box.end.x),\n      top: Math.min(box.start.y, box.end.y),\n      width: Math.abs(box.end.x - box.start.x),\n      height: Math.abs(box.end.y - box.start.y),\n      border: '1px dashed blue',\n      background: 'rgba(0,0,255,0.1)',\n    }} />\n  );\n}\n```\n\n2. **Selection Logic:**\n- Click: Select single component (clear others)\n- Shift+Click: Add to selection\n- Ctrl+Click: Toggle selection\n- Drag on empty space: Rectangle selection\n- Ctrl+A: Select all components\n\n3. **useCanvasKeyboardShortcuts.ts:**\n```typescript\nfunction useCanvasKeyboardShortcuts() {\n  useEffect(() => {\n    const handler = (e: KeyboardEvent) => {\n      // Skip if in input element\n      if (isInputElement(e.target)) return;\n      \n      switch (e.key) {\n        case 'Delete':\n        case 'Backspace': deleteSelected(); break;\n        case 'a': if (e.ctrlKey) { selectAll(); e.preventDefault(); } break;\n        case 'c': if (e.ctrlKey) copySelected(); break;\n        case 'v': if (e.ctrlKey) paste(); break;\n        case 'x': if (e.ctrlKey) cutSelected(); break;\n        case 'd': if (e.ctrlKey) duplicateSelected(); break;\n        case 'z': if (e.ctrlKey) { e.shiftKey ? redo() : undo(); } break;\n        case 'y': if (e.ctrlKey) redo(); break;\n        case 'g': toggleGrid(); break;\n        case 's': toggleSnap(); break;\n      }\n    };\n    document.addEventListener('keydown', handler);\n    return () => document.removeEventListener('keydown', handler);\n  }, []);\n}\n```\n\n4. **Clipboard Operations:**\n- Copy: Serialize selected components to clipboard\n- Paste: Deserialize and place with offset\n- Cut: Copy then delete\n- Duplicate: Copy and paste immediately with offset",
        "testStrategy": "Test all selection modes. Test clipboard stores correct data format. Test paste offsets components correctly. Test undo/redo for all operations. Test shortcuts don't fire when typing in inputs.",
        "priority": "medium",
        "dependencies": [
          "44"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create SelectionBox Component for Drag-to-Select",
            "description": "Implement a visual SelectionBox component that renders the selection rectangle during drag-select operations on the canvas.",
            "dependencies": [],
            "details": "Create `src/components/OneCanvas/SelectionBox.tsx` that renders a positioned div with dashed border and semi-transparent blue background. Accept start and end Position props to calculate the rectangle bounds using Math.min/max for handling any drag direction. The component should use absolute positioning within the canvas coordinate system and only render when a selection box is active. Include proper TypeScript types for the box state ({ start: Position; end: Position } | null).",
            "status": "pending",
            "testStrategy": "Test rectangle renders correctly for all drag directions (top-left to bottom-right, bottom-right to top-left, etc.). Verify correct CSS styling (dashed border, semi-transparent background). Test component mounts/unmounts properly when box state changes from null to defined and back.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Selection Modes in Canvas Interaction Handler",
            "description": "Add comprehensive selection handling for click, shift+click, ctrl+click, and drag-select operations in the canvas interaction system.",
            "dependencies": [
              1
            ],
            "details": "Extend canvas mouse event handlers to support multiple selection modes: (1) Click on component: clear existing selection and select single component. (2) Shift+Click: add component to existing selection without clearing. (3) Ctrl+Click: toggle selection state of clicked component. (4) Drag on empty space: initiate rectangle selection using SelectionBox, then select all components whose bounds intersect the selection rectangle on mouse up. Add selectedIds state to canvas store if not present. Implement Ctrl+A to select all components. Use hitbox/bounds checking for intersection detection.",
            "status": "pending",
            "testStrategy": "Test single click selects one component and clears others. Test shift+click adds to selection. Test ctrl+click toggles individual selection. Test drag-select captures all intersecting components. Test clicking empty space clears selection. Test Ctrl+A selects all components on canvas.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create useCanvasKeyboardShortcuts Hook",
            "description": "Implement a custom hook that handles all canvas-specific keyboard shortcuts with proper focus management.",
            "dependencies": [],
            "details": "Create `src/components/OneCanvas/hooks/useCanvasKeyboardShortcuts.ts` that registers a keydown event listener on document. Implement shortcuts: Delete/Backspace (delete selected), Ctrl+A (select all), Ctrl+C (copy), Ctrl+V (paste), Ctrl+X (cut), Ctrl+D (duplicate), Ctrl+Z (undo), Ctrl+Shift+Z or Ctrl+Y (redo), G (toggle grid), S (toggle snap). Include isInputElement() helper to check if event.target is an input, textarea, or contenteditable element and skip handling if so. Use e.preventDefault() for shortcuts that conflict with browser defaults. Return cleanup function to remove event listener.",
            "status": "pending",
            "testStrategy": "Test each shortcut triggers the correct action. Test shortcuts are ignored when focus is on input elements. Test modifier key combinations work correctly. Test event.preventDefault() is called for conflicting shortcuts. Test cleanup removes event listener on unmount.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Clipboard Operations with Component Serialization",
            "description": "Create clipboard functionality (copy, paste, cut, duplicate) with proper component serialization, ID regeneration, and position offset handling.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement clipboard operations in canvas store or utility functions: (1) Copy: serialize selected components (blocks and wires) to JSON, store in module-level clipboard variable or use navigator.clipboard API. (2) Paste: deserialize clipboard data, generate new unique IDs for all components, apply position offset (e.g., +20, +20) to prevent exact overlap, add to canvas. (3) Cut: execute copy then delete selected components. (4) Duplicate: copy selected and immediately paste with offset. Handle wire connections - when duplicating connected components, remap wire endpoint IDs to new component IDs. Store clipboard as { blocks: Block[], wires: Wire[] } format.",
            "status": "pending",
            "testStrategy": "Test copy stores correct component data in clipboard format. Test paste creates new components with unique IDs. Test paste applies position offset correctly. Test cut removes original components after copying. Test duplicate creates offset copy immediately. Test wire connections are remapped when duplicating connected components.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate Undo/Redo with Canvas Store History",
            "description": "Connect undo/redo keyboard shortcuts to the canvas store's history management system for complete operation reversal.",
            "dependencies": [
              3
            ],
            "details": "Integrate the Ctrl+Z (undo) and Ctrl+Shift+Z/Ctrl+Y (redo) shortcuts from useCanvasKeyboardShortcuts with the canvas store's history stack. Ensure the canvas store maintains a history array and currentIndex pointer. Implement undo() to decrement index and restore previous state, redo() to increment index and restore next state. All canvas operations (add, delete, move, paste, cut) should push to history before executing. Consider debouncing rapid operations (like dragging) to create single history entries. Export undo/redo functions from canvas store for use by the keyboard hook.",
            "status": "pending",
            "testStrategy": "Test Ctrl+Z undoes the last operation. Test Ctrl+Shift+Z and Ctrl+Y both redo. Test undo/redo work correctly for add, delete, move, paste, cut operations. Test undo at history start does nothing. Test redo at history end does nothing. Test rapid operations are properly batched in history.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Create SelectionBox component for drag-to-select with rectangle rendering. 2) Implement selection modes (click, shift+click, ctrl+click, drag select) in canvas interaction handler. 3) Create useCanvasKeyboardShortcuts hook with all canvas-specific shortcuts. 4) Implement clipboard operations (copy/paste/cut/duplicate) with component serialization and offset positioning. 5) Implement undo/redo keyboard shortcuts integrated with canvas store history.",
        "updatedAt": "2026-01-28T17:31:33.757Z"
      },
      {
        "id": "47",
        "title": "Implement Simulation Controls and State Management",
        "description": "Create simulation control UI (start/stop/reset), Tauri commands for simulation state, and visual indicators for simulation mode including current flow animations.",
        "details": "Implement simulation controls:\n\n1. **Simulation Toolbar Component:**\n```tsx\nfunction SimulationToolbar() {\n  const { running, start, stop, reset } = useSimulation();\n  \n  return (\n    <div className=\"flex items-center gap-2 p-2 bg-gray-100\">\n      {running ? (\n        <button onClick={stop}><Pause /> Stop</button>\n      ) : (\n        <button onClick={start}><Play /> Start</button>\n      )}\n      <button onClick={reset}><RotateCcw /> Reset</button>\n      {running && <span className=\"text-green-600 animate-pulse\">● Simulating</span>}\n    </div>\n  );\n}\n```\n\n2. **Tauri Commands:**\n```rust\n#[tauri::command]\nasync fn canvas_start_simulation(state: State<CanvasState>) -> Result<(), ModOneError>\n\n#[tauri::command]\nasync fn canvas_stop_simulation(state: State<CanvasState>) -> Result<(), ModOneError>\n\n#[tauri::command]\nasync fn canvas_get_simulation_state(state: State<CanvasState>) -> Result<SimulationStateDto, ModOneError>\n```\n\n3. **Current Flow Animation CSS:**\n```css\n.wire-active {\n  stroke-dasharray: 5 5;\n  animation: flow 0.5s linear infinite;\n}\n\n@keyframes flow {\n  from { stroke-dashoffset: 10; }\n  to { stroke-dashoffset: 0; }\n}\n```\n\n4. **Visual Indicators:**\n- Active wires: Animated dashed lines\n- Powered components: Glow effect\n- Open switches: Red indicator\n- Closed switches: Green indicator\n\n5. **Simulation Events:**\n- Emit Tauri events when component states change\n- Frontend subscribes to update visuals in real-time",
        "testStrategy": "Test start/stop toggles simulation. Test reset clears all runtime state. Test visual indicators appear correctly. Test animations perform well with many wires. Test event emission and subscription.",
        "priority": "medium",
        "dependencies": [
          "42"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create SimulationToolbar Component with Play/Pause/Reset Controls",
            "description": "Build the SimulationToolbar React component with play/pause/stop buttons, reset functionality, and a visual status indicator showing the current simulation state.",
            "dependencies": [],
            "details": "Create `src/components/OneCanvas/SimulationToolbar.tsx` with the following implementation:\n\n1. **Component Structure:**\n   - Play button (shown when simulation is stopped)\n   - Pause/Stop button (shown when simulation is running)\n   - Reset button (always visible)\n   - Status indicator with animated pulse when running\n\n2. **useSimulation Hook:**\n   Create `src/components/OneCanvas/hooks/useSimulation.ts`:\n   ```typescript\n   interface SimulationState {\n     running: boolean;\n     paused: boolean;\n     currentTime: number;\n   }\n   \n   export function useSimulation() {\n     const [state, setState] = useState<SimulationState>({ running: false, paused: false, currentTime: 0 });\n     \n     const start = async () => {\n       await invoke('canvas_start_simulation');\n       setState(s => ({ ...s, running: true }));\n     };\n     \n     const stop = async () => {\n       await invoke('canvas_stop_simulation');\n       setState(s => ({ ...s, running: false }));\n     };\n     \n     const reset = async () => {\n       await invoke('canvas_reset_simulation');\n       setState({ running: false, paused: false, currentTime: 0 });\n     };\n     \n     return { ...state, start, stop, reset };\n   }\n   ```\n\n3. **UI Styling:**\n   - Use Lucide icons (Play, Pause, RotateCcw)\n   - Consistent button styling with hover states\n   - Green pulsing indicator when simulating\n   - Integrate with existing canvas toolbar or create floating panel",
            "status": "pending",
            "testStrategy": "Test that clicking play starts simulation and shows stop button. Test stop button stops simulation and shows play button. Test reset clears simulation state and stops if running. Test status indicator shows animated pulse only when running. Test keyboard shortcuts if implemented (Space for play/pause).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Tauri Commands for Simulation State Control",
            "description": "Create Rust Tauri commands for starting, stopping, and resetting simulation, plus event emission for real-time state updates to the frontend.",
            "dependencies": [
              1
            ],
            "details": "Add simulation control commands to `src-tauri/src/commands/canvas_commands.rs` (or create new simulation module):\n\n1. **Simulation Commands:**\n   ```rust\n   #[tauri::command]\n   pub async fn canvas_start_simulation(\n     state: State<'_, CanvasState>\n   ) -> Result<(), ModOneError> {\n     let mut canvas = state.canvas.lock().await;\n     canvas.start_simulation()?;\n     Ok(())\n   }\n   \n   #[tauri::command]\n   pub async fn canvas_stop_simulation(\n     state: State<'_, CanvasState>\n   ) -> Result<(), ModOneError> {\n     let mut canvas = state.canvas.lock().await;\n     canvas.stop_simulation()?;\n     Ok(())\n   }\n   \n   #[tauri::command]\n   pub async fn canvas_reset_simulation(\n     state: State<'_, CanvasState>\n   ) -> Result<(), ModOneError> {\n     let mut canvas = state.canvas.lock().await;\n     canvas.reset_simulation()?;\n     Ok(())\n   }\n   \n   #[tauri::command]\n   pub async fn canvas_get_simulation_state(\n     state: State<'_, CanvasState>\n   ) -> Result<SimulationStateDto, ModOneError> {\n     let canvas = state.canvas.lock().await;\n     Ok(canvas.get_simulation_state().into())\n   }\n   ```\n\n2. **SimulationStateDto:**\n   ```rust\n   #[derive(Serialize, Clone)]\n   pub struct SimulationStateDto {\n     pub running: bool,\n     pub powered_components: Vec<String>,\n     pub current_paths: Vec<CurrentPathDto>,\n   }\n   ```\n\n3. **Event Emission:**\n   - Emit `simulation-state-changed` event when components receive/lose power\n   - Emit `simulation-tick` event for animation synchronization\n   - Use Tauri's event system: `app_handle.emit_all(\"simulation-state-changed\", &state)`\n\n4. **Register commands in main.rs** and create TypeScript bindings",
            "status": "pending",
            "testStrategy": "Test start command initiates simulation engine. Test stop command halts simulation. Test reset clears all runtime state and powered components. Test get_simulation_state returns correct SimulationStateDto. Test events are emitted on state changes. Test error handling when simulation engine not ready.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create CSS Animations for Current Flow Visualization",
            "description": "Implement CSS keyframe animations for visualizing current flow through wires, showing animated dashed lines that indicate power transmission direction and state.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create animation styles in `src/components/OneCanvas/styles/simulation.css` or add to existing canvas styles:\n\n1. **Base Wire Animation:**\n   ```css\n   .wire-active {\n     stroke-dasharray: 5 5;\n     animation: current-flow 0.5s linear infinite;\n   }\n   \n   @keyframes current-flow {\n     from { stroke-dashoffset: 10; }\n     to { stroke-dashoffset: 0; }\n   }\n   \n   .wire-inactive {\n     stroke-dasharray: none;\n     animation: none;\n   }\n   ```\n\n2. **Flow Direction Variants:**\n   ```css\n   .wire-flow-forward {\n     animation-direction: normal;\n   }\n   \n   .wire-flow-reverse {\n     animation-direction: reverse;\n   }\n   ```\n\n3. **Wire State Colors:**\n   ```css\n   .wire-powered {\n     stroke: #22c55e; /* green-500 */\n     filter: drop-shadow(0 0 2px #22c55e);\n   }\n   \n   .wire-unpowered {\n     stroke: #6b7280; /* gray-500 */\n   }\n   ```\n\n4. **Performance Optimization:**\n   - Use `will-change: stroke-dashoffset` for GPU acceleration\n   - Consider reducing animation complexity when >50 active wires\n   - Use CSS custom properties for animation speed control\n\n5. **Integration with Wire Component:**\n   - Add className conditionally based on simulation state\n   - Subscribe to simulation events to update wire classes\n   - Use React.memo to prevent unnecessary re-renders",
            "status": "pending",
            "testStrategy": "Test animation plays smoothly without jank. Test wire color changes when powered vs unpowered. Test performance with 50+ animated wires simultaneously. Test animation stops when simulation stops. Test that will-change optimizations are applied. Visual regression test for animation appearance.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Visual Indicators for Powered Components and Switch States",
            "description": "Implement visual feedback for component power states including glow effects for powered components and red/green indicators for switch open/closed states.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create component state styles and integrate with simulation events:\n\n1. **Powered Component Glow Effect:**\n   ```css\n   .component-powered {\n     filter: drop-shadow(0 0 4px #22c55e) drop-shadow(0 0 8px rgba(34, 197, 94, 0.5));\n     transition: filter 0.2s ease-in-out;\n   }\n   \n   .component-unpowered {\n     filter: none;\n     opacity: 0.7;\n     transition: filter 0.2s ease-in-out, opacity 0.2s ease-in-out;\n   }\n   ```\n\n2. **Switch State Indicators:**\n   ```css\n   .switch-indicator {\n     position: absolute;\n     width: 8px;\n     height: 8px;\n     border-radius: 50%;\n     top: -4px;\n     right: -4px;\n   }\n   \n   .switch-open {\n     background-color: #ef4444; /* red-500 */\n     box-shadow: 0 0 4px #ef4444;\n   }\n   \n   .switch-closed {\n     background-color: #22c55e; /* green-500 */\n     box-shadow: 0 0 4px #22c55e;\n   }\n   ```\n\n3. **Component Updates:**\n   - Modify Block components to accept `isPowered` prop\n   - Add SwitchIndicator child component to switch blocks\n   - Create `useComponentSimulationState` hook to subscribe to events:\n   ```typescript\n   function useComponentSimulationState(componentId: string) {\n     const [isPowered, setIsPowered] = useState(false);\n     \n     useEffect(() => {\n       const unlisten = listen('simulation-state-changed', (event) => {\n         const state = event.payload as SimulationStateDto;\n         setIsPowered(state.powered_components.includes(componentId));\n       });\n       return () => { unlisten.then(fn => fn()); };\n     }, [componentId]);\n     \n     return { isPowered };\n   }\n   ```\n\n4. **LED/Load Specific Effects:**\n   - LED blocks: Change fill color when powered (off gray -> on bright)\n   - Load blocks: Show activity indicator or intensity based on power",
            "status": "pending",
            "testStrategy": "Test powered components show glow effect. Test unpowered components appear dimmed. Test switch open shows red indicator. Test switch closed shows green indicator. Test state transitions animate smoothly. Test real-time updates when simulation changes component states. Test performance with many components updating simultaneously.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create SimulationToolbar component with play/pause/stop buttons and status indicator. 2) Implement Tauri commands for simulation state control and event emission. 3) Create CSS animations for current flow visualization (animated dashes). 4) Add visual indicators for powered components and switch states.",
        "updatedAt": "2026-01-28T17:33:11.457Z"
      },
      {
        "id": "48",
        "title": "Integrate OneCanvas into Panel System",
        "description": "Complete the OneCanvasPanel integration with the existing panel system, including toolbox placement, canvas area, properties panel communication, and circuit file association with tabs.",
        "details": "Complete OneCanvas integration:\n\n1. **Update OneCanvasPanel.tsx:**\n```tsx\nexport function OneCanvasPanel() {\n  return (\n    <div className=\"h-full flex flex-col\">\n      <SimulationToolbar />\n      <div className=\"flex-1 flex overflow-hidden\">\n        <Toolbox className=\"w-48 border-r\" />\n        <Canvas className=\"flex-1\">\n          <ComponentLayer />\n          <WireLayer />\n          <SelectionBox />\n        </Canvas>\n      </div>\n    </div>\n  );\n}\n```\n\n2. **Tab Integration:**\n- Each circuit file opens in a new tab\n- Tab title shows circuit name\n- Modified indicator when unsaved\n- Tab context menu: Save, Save As, Close\n\n3. **Properties Panel Communication:**\n- When OneCanvas panel is active, Properties panel shows selected component\n- Use existing panel store's activePanel to determine context\n\n4. **Layout Integration:**\n- Default layout preset with Toolbox docked left\n- Properties panel docked right\n- Canvas takes remaining space\n\n5. **File Operations:**\n- Menu: File > New Circuit, Open Circuit, Save Circuit\n- Keyboard shortcuts (Ctrl+N for new, Ctrl+O for open within canvas context)\n- Recent circuits list\n\n6. **Canvas State per Tab:**\n- Each tab maintains its own canvas store instance\n- Switch stores when switching tabs",
        "testStrategy": "Test panel opens correctly from activity bar. Test multiple circuits in tabs. Test properties panel updates on selection. Test file operations create/save/load circuits. Test unsaved indicator shows correctly.",
        "priority": "medium",
        "dependencies": [
          "46",
          "47"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update OneCanvasPanel Component with SimulationToolbar, Toolbox, and Canvas Layout",
            "description": "Replace the placeholder OneCanvasPanel.tsx with a fully functional layout that includes SimulationToolbar at the top, Toolbox docked left, and Canvas taking remaining space with ComponentLayer, WireLayer, and SelectionBox sublayers.",
            "dependencies": [],
            "details": "1. Update `src/components/panels/content/OneCanvasPanel.tsx` to replace the placeholder:\n   - Import or create SimulationToolbar component for simulation controls (run/pause/step/stop)\n   - Import Toolbox component with className='w-48 border-r' for component palette\n   - Import Canvas component with flex-1 styling\n   - Structure: outer div (h-full flex flex-col) containing SimulationToolbar, then inner flex container with Toolbox and Canvas\n2. Create component stubs if they don't exist:\n   - `src/components/onecanvas/SimulationToolbar.tsx` - Play/Pause/Step/Stop buttons, speed control\n   - `src/components/onecanvas/Toolbox.tsx` - Component palette with drag sources\n   - `src/components/onecanvas/Canvas.tsx` - Main canvas area with zoom/pan\n3. Canvas should render:\n   - ComponentLayer for placed components\n   - WireLayer for connections between components\n   - SelectionBox for marquee selection\n4. Accept optional `data?: TabData` prop to receive canvas document data from the tab system\n5. Ensure proper overflow handling (overflow-hidden on flex container, scrollable canvas)",
            "status": "pending",
            "testStrategy": "1. Verify OneCanvasPanel renders without errors when opened from activity bar\n2. Confirm layout shows SimulationToolbar at top, Toolbox on left (48px/w-48 width), Canvas fills remaining space\n3. Test responsive behavior when panel is resized\n4. Verify all child components (SimulationToolbar, Toolbox, Canvas layers) render correctly\n5. Check that the panel respects the h-full constraint from parent Panel component",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Tab Integration for Multiple Circuit Files with Modified Indicator",
            "description": "Enable each circuit file to open in a new tab within the OneCanvas panel, with tab title showing circuit name, modified indicator (blue dot) when unsaved, and context menu actions for Save, Save As, Close operations.",
            "dependencies": [
              1
            ],
            "details": "1. Leverage existing tab system in panelStore:\n   - Use `addTab(panelId, 'one-canvas', circuitName, { filePath, documentId, canvasData })` to open circuits\n   - Use `updateTabTitle(panelId, tabId, newTitle)` when circuit is renamed\n   - Use `updateTabModified(panelId, tabId, isModified)` to show/hide blue dot indicator\n2. Update TabContextMenu.tsx to add circuit-specific actions:\n   - Add 'Save Circuit' action that triggers save for the specific tab's document\n   - Add 'Save Circuit As...' action that opens save dialog\n   - Existing 'Close' action should prompt if isModified is true\n3. Create circuit file handling utilities:\n   - `src/utils/circuitFileUtils.ts` with functions for circuit file naming, path handling\n   - Generate default names like 'Untitled Circuit 1', 'Untitled Circuit 2'\n4. Tab title format: filename without extension (e.g., 'main' for 'main.circuit')\n5. Integrate with existing tab drag-and-drop for reordering and panel splitting\n6. Handle tab close with unsaved changes prompt (use existing UnsavedChangesDialog pattern)",
            "status": "pending",
            "testStrategy": "1. Open multiple circuits and verify each appears as a separate tab\n2. Modify a circuit and confirm blue modified indicator appears on tab\n3. Save circuit and verify modified indicator disappears\n4. Right-click tab and test context menu actions (Save, Save As, Close)\n5. Test closing tab with unsaved changes shows confirmation dialog\n6. Verify tab titles update correctly when circuit is renamed or saved to new path",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Set Up Properties Panel Communication for Selected Component Editing",
            "description": "Implement bidirectional communication between OneCanvas and Properties panel so that when a component is selected on the canvas, its properties appear in the Properties panel for editing, and property changes update the canvas.",
            "dependencies": [
              1
            ],
            "details": "1. Create a selection store for OneCanvas components:\n   - `src/stores/canvasSelectionStore.ts` with Zustand\n   - State: `selectedComponentIds: string[]`, `activeCanvasTabId: string | null`\n   - Actions: `selectComponent(id)`, `addToSelection(id)`, `clearSelection()`, `setActiveCanvas(tabId)`\n2. Update PropertiesPanel (`src/components/panels/content/PropertiesPanel.tsx`):\n   - Subscribe to canvasSelectionStore\n   - Check if active panel is 'one-canvas' using panelStore.activePanel\n   - When OneCanvas is active and component selected, render component property editors\n   - Property editor should be component-type-specific (different properties for different component types)\n3. Define component property interfaces:\n   - `src/types/canvasComponent.ts` with base ComponentProperties interface\n   - Extend for specific types (GateProperties, TimerProperties, CounterProperties, etc.)\n4. Implement property change handlers:\n   - When property is edited in PropertiesPanel, dispatch update to canvas store\n   - Canvas should re-render affected component with new properties\n5. Use panelStore.activePanel to determine context:\n   - If activePanel type is 'one-canvas', show canvas component properties\n   - If activePanel type is 'ladder-editor', show ladder element properties\n   - Fallback to 'No selection' message",
            "status": "pending",
            "testStrategy": "1. Select a component on canvas and verify Properties panel updates to show its properties\n2. Edit a property value and confirm canvas component updates accordingly\n3. Clear selection and verify Properties panel shows 'No selection' message\n4. Switch between canvas tab and other panel types, confirm Properties panel context changes\n5. Multi-select components and verify Properties panel shows appropriate multi-selection UI\n6. Test undo/redo of property changes",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement File Operations (New, Open, Save) with Menu and Keyboard Shortcuts",
            "description": "Add circuit file operations to the application menu and implement keyboard shortcuts for New Circuit (Ctrl+N within canvas context), Open Circuit (Ctrl+O within canvas context), and Save Circuit (Ctrl+S) operations.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Extend File menu with circuit operations:\n   - Add menu items under File: 'New Circuit', 'Open Circuit...', 'Save Circuit', 'Save Circuit As...'\n   - Use Tauri's menu API or existing menu component\n   - Menu items should be enabled/disabled based on active panel context\n2. Create circuit file service:\n   - `src/services/circuitFileService.ts` with Tauri command wrappers\n   - `createCircuit()` - Create new circuit document\n   - `openCircuit(path?)` - Open circuit file (dialog if no path)\n   - `saveCircuit(tabId, path?)` - Save circuit (Save As if no path)\n   - Store circuits inside .mop project archive or as separate .circuit files\n3. Implement keyboard shortcuts using existing useKeyboardShortcuts hook:\n   - Ctrl+N: New Circuit (when OneCanvas panel is active)\n   - Ctrl+O: Open Circuit (when OneCanvas panel is active, distinct from Ctrl+O for project)\n   - Ctrl+S: Save active circuit tab\n   - Ctrl+Shift+S: Save Circuit As\n4. Add 'Recent Circuits' submenu:\n   - Store recent circuit paths per project\n   - Show last 5-10 recently opened circuits\n   - Click to open directly\n5. Wire up Tauri backend commands:\n   - `create_circuit`, `open_circuit`, `save_circuit` commands\n   - Handle circuit data serialization/deserialization",
            "status": "pending",
            "testStrategy": "1. Test File > New Circuit creates new tab with empty circuit\n2. Test File > Open Circuit opens file picker, loads circuit into new tab\n3. Test File > Save Circuit saves current circuit (prompts for path if new)\n4. Test keyboard shortcuts Ctrl+N, Ctrl+O, Ctrl+S work when canvas is active\n5. Test shortcuts are disabled or handled differently when other panel types are active\n6. Verify Recent Circuits list updates when opening circuits\n7. Test Save As creates copy with new filename",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Manage Per-Tab Canvas Store Instances for Multi-Document Support",
            "description": "Implement a system to create, maintain, and switch between separate canvas store instances for each open circuit tab, ensuring each document has isolated state (components, wires, selection, undo history).",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Create per-document canvas store factory:\n   - `src/stores/createCanvasStore.ts` - Factory function returning Zustand store\n   - Each store instance contains: components[], wires[], viewport (zoom/pan), selection, undoStack, redoStack\n   - Store shape: `{ components, wires, viewport, selection, addComponent, removeComponent, connect, disconnect, undo, redo }`\n2. Create canvas store registry:\n   - `src/stores/canvasStoreRegistry.ts` - Map<string, CanvasStore> keyed by tab.data.documentId\n   - `getOrCreateStore(documentId, initialData?)` - Lazy store creation\n   - `disposeStore(documentId)` - Cleanup when tab closes\n   - `getActiveStore()` - Get store for currently active canvas tab\n3. Wire OneCanvasPanel to use store from registry:\n   - Receive documentId from tab.data prop\n   - Get corresponding store from registry\n   - Pass store to Canvas component via context or props\n4. Handle tab switching:\n   - Subscribe to panelStore.activeTabId changes\n   - When active tab changes, update which store is 'active'\n   - Canvas re-renders with new store's state\n5. Handle tab close:\n   - On tab close, check if store has unsaved changes\n   - Prompt to save if needed\n   - Call disposeStore(documentId) to free memory\n6. Persist store state:\n   - When saving circuit, serialize store state\n   - When opening circuit, deserialize into store state\n   - Integrate with project save/load for embedded circuits",
            "status": "pending",
            "testStrategy": "1. Open two circuits in separate tabs and verify each has independent state\n2. Add components to tab A, switch to tab B, verify tab B is unchanged\n3. Switch back to tab A, verify components are preserved\n4. Test undo/redo is per-tab (undoing in tab A doesn't affect tab B)\n5. Close tab A, reopen same circuit, verify state was persisted\n6. Test memory cleanup: close tab and verify store is disposed (check registry size)\n7. Test rapid tab switching doesn't cause race conditions or state corruption",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Update OneCanvasPanel component to include SimulationToolbar, Toolbox, and Canvas in proper layout. 2) Implement tab integration for multiple circuit files with modified indicator. 3) Set up Properties panel communication for selected component editing. 4) Implement file operations (New, Open, Save) with menu/keyboard shortcuts. 5) Manage per-tab canvas store instances for multi-document support.",
        "updatedAt": "2026-01-28T17:46:48.447Z"
      },
      {
        "id": "49",
        "title": "Define Scenario Editor TypeScript Types and Data Models",
        "description": "Create TypeScript type definitions for ScenarioEvent, Scenario, and related interfaces that match the PRD specification.",
        "details": "Create `src/types/scenario.ts` with the following interfaces:\n\n```typescript\n// ScenarioEvent - represents a single timed memory write\nexport interface ScenarioEvent {\n  id: string;                    // UUID\n  time: number;                  // Seconds from simulation start\n  address: string;               // Modbus address (e.g., 'C:0x0001', 'H:0x0100')\n  value: number;                 // 0~65535\n  persist: boolean;              // Value persistence\n  persistDuration?: number;      // Auto-release ms (when persist=false)\n  note: string;                  // Description\n  enabled: boolean;              // Event toggle\n}\n\n// Scenario metadata\nexport interface ScenarioMetadata {\n  name: string;\n  description: string;\n  createdAt: string;             // ISO 8601\n  updatedAt: string;\n  author: string;\n}\n\n// Scenario settings\nexport interface ScenarioSettings {\n  loop: boolean;\n  loopCount: number;             // 0 = infinite\n  loopDelay: number;             // ms\n  autoStart: boolean;\n}\n\n// Execution status\nexport type ScenarioStatus = 'idle' | 'running' | 'paused' | 'stopped';\n\n// Full scenario\nexport interface Scenario {\n  metadata: ScenarioMetadata;\n  settings: ScenarioSettings;\n  events: ScenarioEvent[];\n}\n\n// Execution state for UI\nexport interface ScenarioExecutionState {\n  status: ScenarioStatus;\n  currentTime: number;           // Elapsed time in seconds\n  currentEventIndex: number;\n  completedEvents: string[];     // Event IDs\n  currentLoopIteration: number;\n}\n```\n\nAlso add address format types matching the PRD's address format table (C:, DI:, H:, IR: prefixes).",
        "testStrategy": "Write unit tests verifying type guards and validation functions work correctly. Test serialization/deserialization of Scenario objects to JSON.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define core scenario types and interfaces",
            "description": "Create the fundamental TypeScript type definitions for ScenarioEvent, ScenarioMetadata, ScenarioSettings, ScenarioStatus, and the main Scenario interface in src/types/scenario.ts.",
            "dependencies": [],
            "details": "Create src/types/scenario.ts with the following core types:\n\n1. **ScenarioEvent interface** - Represents a single timed memory write event:\n   - id: string (UUID)\n   - time: number (seconds from simulation start)\n   - address: string (Modbus address format)\n   - value: number (0-65535 range)\n   - persist: boolean (value persistence flag)\n   - persistDuration?: number (optional auto-release duration in ms)\n   - note: string (event description)\n   - enabled: boolean (event toggle)\n\n2. **ScenarioMetadata interface** - Scenario metadata:\n   - name: string\n   - description: string\n   - createdAt: string (ISO 8601 format)\n   - updatedAt: string (ISO 8601 format)\n   - author: string\n\n3. **ScenarioSettings interface** - Scenario configuration:\n   - loop: boolean\n   - loopCount: number (0 = infinite)\n   - loopDelay: number (delay in ms)\n   - autoStart: boolean\n\n4. **ScenarioStatus type** - Union type: 'idle' | 'running' | 'paused' | 'stopped'\n\n5. **Scenario interface** - Complete scenario structure combining metadata, settings, and events array.\n\nExport all types and ensure proper JSDoc comments for documentation.",
            "status": "pending",
            "testStrategy": "Write unit tests to verify: 1) Type definitions compile without errors, 2) Sample Scenario objects can be created with all required fields, 3) JSON serialization/deserialization roundtrip preserves all fields correctly, 4) TypeScript compiler catches missing required fields.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define execution state types and Modbus address format types",
            "description": "Create ScenarioExecutionState interface for runtime state tracking and define Modbus address format types with validation patterns matching the PRD specification.",
            "dependencies": [
              1
            ],
            "details": "Add the following types to src/types/scenario.ts:\n\n1. **ScenarioExecutionState interface** - Runtime execution tracking:\n   - status: ScenarioStatus\n   - currentTime: number (elapsed time in seconds)\n   - currentEventIndex: number\n   - completedEvents: string[] (array of completed event IDs)\n   - currentLoopIteration: number\n\n2. **Modbus Address Format Types** - Based on PRD address format table:\n   - ModbusAddressPrefix type: 'C' | 'DI' | 'H' | 'IR' (Coil, Discrete Input, Holding Register, Input Register)\n   - ModbusAddress type or interface with prefix and address components\n   - Address format pattern: `{prefix}:0x{hex}` (e.g., 'C:0x0001', 'H:0x0100')\n\n3. **Address Validation Utilities**:\n   - MODBUS_ADDRESS_REGEX constant for validation pattern\n   - Type guard function: isValidModbusAddress(address: string): boolean\n   - Helper type: ValidModbusAddressFormat (template literal type if applicable)\n\n4. **Address Range Constants**:\n   - Define valid address ranges per prefix type\n   - COIL_ADDRESS_RANGE, HOLDING_REGISTER_RANGE, etc.\n\nEnsure all types integrate properly with ScenarioEvent.address field.",
            "status": "pending",
            "testStrategy": "Write unit tests to verify: 1) ScenarioExecutionState correctly tracks execution progress, 2) Address validation regex matches valid formats (C:0x0001, H:0x0100, DI:0x0000, IR:0x00FF), 3) Validation rejects invalid formats (missing prefix, invalid hex, wrong delimiter), 4) Type guards return correct boolean values for edge cases.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break down into: 1) Define core types (ScenarioEvent, ScenarioMetadata, ScenarioSettings, ScenarioStatus, Scenario) with all required fields. 2) Define execution state types (ScenarioExecutionState) and address format types with validation patterns.",
        "updatedAt": "2026-01-28T13:16:03.351Z"
      },
      {
        "id": "50",
        "title": "Implement Address Parser Utility",
        "description": "Create utility functions to parse and convert Modbus address formats including PLC alias conversion.",
        "details": "Create `src/components/ScenarioEditor/utils/addressParser.ts`:\n\n```typescript\n// Parse address string to normalized format\nexport interface ParsedAddress {\n  type: 'coil' | 'discrete' | 'holding' | 'input';\n  address: number;\n  rawString: string;\n}\n\n// Address prefix mapping\nconst ADDRESS_PREFIXES = {\n  'C:': 'coil',\n  'DI:': 'discrete',\n  'H:': 'holding',\n  'IR:': 'input',\n} as const;\n\n// PLC alias patterns (e.g., M0001 → C:0x0001)\nconst PLC_ALIAS_PATTERNS = [\n  { pattern: /^M(\\d{4})$/i, type: 'coil', offset: 0 },\n  { pattern: /^D(\\d{1,5})$/i, type: 'holding', offset: 0 },\n  // Add more patterns as needed\n];\n\nexport function parseAddress(input: string): ParsedAddress | null\nexport function formatAddress(parsed: ParsedAddress): string\nexport function isValidAddress(input: string): boolean\nexport function addressToMemoryType(input: string): MemoryType | null\n```\n\nHandle both hex (0x prefix) and decimal address formats. Support case-insensitive parsing.",
        "testStrategy": "Unit tests covering all address formats (C:0x0001, C:100, M0001, H:256, DI:0x0001, IR:0x0100), invalid inputs, and edge cases like maximum addresses.",
        "priority": "high",
        "dependencies": [
          "49"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Address Prefix Parsing for Standard Formats",
            "description": "Create parsing logic for standard Modbus address prefixes (C:, DI:, H:, IR:) with support for both hexadecimal (0x prefix) and decimal address formats.",
            "dependencies": [],
            "details": "Implement the core address prefix parsing functionality in `src/components/ScenarioEditor/utils/addressParser.ts`:\n\n1. Define the ADDRESS_PREFIXES constant mapping prefixes to memory types:\n   - 'C:' → 'coil'\n   - 'DI:' → 'discrete'\n   - 'H:' → 'holding'\n   - 'IR:' → 'input'\n\n2. Create `parsePrefixedAddress(input: string): ParsedAddress | null` function:\n   - Case-insensitive prefix matching (C:, c:, DI:, di:, etc.)\n   - Detect hex format: if address starts with '0x' or '0X', parse as hexadecimal\n   - Parse decimal format: standard number parsing\n   - Validate address is non-negative integer within valid range (0-65535)\n   - Return ParsedAddress object with type, address number, and original input string\n   - Return null for invalid formats\n\n3. Handle edge cases:\n   - Whitespace trimming\n   - Empty strings\n   - Invalid hex characters\n   - Overflow values",
            "status": "done",
            "testStrategy": "Unit tests covering: valid prefix formats (C:0x0001, DI:100, H:0xFFFF, IR:0), case variations (c:100, C:100, di:0x10), invalid inputs (C:, C:abc, C:-1, C:99999), edge cases (C:0, C:65535, whitespace handling).",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:11:28.729Z"
          },
          {
            "id": 2,
            "title": "Implement PLC Alias Pattern Matching",
            "description": "Create pattern matching logic to convert PLC-style alias addresses (M0001, D12345) to standard Modbus address format.",
            "dependencies": [
              1
            ],
            "details": "Add PLC alias parsing to `src/components/ScenarioEditor/utils/addressParser.ts`:\n\n1. Define PLC_ALIAS_PATTERNS array with regex patterns:\n   - M pattern: `/^M(\\d{4})$/i` → type: 'coil', offset: 0 (e.g., M0001 → C:0x0001)\n   - D pattern: `/^D(\\d{1,5})$/i` → type: 'holding', offset: 0 (e.g., D12345 → H:0x3039)\n   - Add extensible pattern structure for future PLC types\n\n2. Create `parseAliasAddress(input: string): ParsedAddress | null` function:\n   - Iterate through PLC_ALIAS_PATTERNS\n   - Match input against each pattern regex\n   - Extract numeric portion from matched groups\n   - Apply offset if defined in pattern\n   - Convert decimal number to appropriate address value\n   - Return ParsedAddress with inferred type and converted address\n\n3. Conversion logic:\n   - Parse captured digits as decimal integer\n   - Apply any offset transformation\n   - Store both the original alias string and converted address\n   - Handle leading zeros correctly (M0001 = address 1, not octal)",
            "status": "done",
            "testStrategy": "Unit tests for: M pattern variations (M0001, M1234, M9999, m0001), D pattern variations (D1, D12345, D65535, d100), invalid aliases (M123, M12345, D123456, X0001), conversion accuracy (M0001=1, D12345=12345), case insensitivity.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:11:28.740Z"
          },
          {
            "id": 3,
            "title": "Create Validation and Conversion Utilities",
            "description": "Implement the main public API functions: parseAddress, formatAddress, isValidAddress, and addressToMemoryType that combine prefix and alias parsing.",
            "dependencies": [
              1,
              2
            ],
            "details": "Complete the public API in `src/components/ScenarioEditor/utils/addressParser.ts`:\n\n1. `parseAddress(input: string): ParsedAddress | null`:\n   - Trim and validate input is non-empty\n   - Try parsePrefixedAddress first (standard format)\n   - If null, try parseAliasAddress (PLC format)\n   - Return result or null if neither matches\n\n2. `formatAddress(parsed: ParsedAddress): string`:\n   - Map type to prefix: coil→'C:', discrete→'DI:', holding→'H:', input→'IR:'\n   - Format address as hex with 0x prefix: `0x${address.toString(16).toUpperCase().padStart(4, '0')}`\n   - Return concatenated prefix + formatted address\n\n3. `isValidAddress(input: string): boolean`:\n   - Simply return `parseAddress(input) !== null`\n   - Provides convenient boolean check for validation\n\n4. `addressToMemoryType(input: string): MemoryType | null`:\n   - Import MemoryType from existing types\n   - Parse address and map parsed.type to MemoryType enum\n   - Return null if parsing fails\n   - Handle mapping: 'coil'→Coil, 'discrete'→DiscreteInput, 'holding'→HoldingRegister, 'input'→InputRegister\n\n5. Export all functions and types from the module",
            "status": "done",
            "testStrategy": "Integration tests for: parseAddress combining both formats, formatAddress roundtrip (parse then format), isValidAddress boolean responses, addressToMemoryType enum mapping, null handling for invalid inputs, full roundtrip tests (parse→format→parse equality).",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:11:28.751Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into: 1) Implement address prefix parsing for standard formats (C:, DI:, H:, IR:) with hex and decimal support. 2) Implement PLC alias pattern matching (M0001 -> C:0x0001, D12345 -> H:0x3039). 3) Create validation and conversion utilities (parseAddress, formatAddress, isValidAddress, addressToMemoryType).",
        "updatedAt": "2026-01-28T17:11:28.751Z"
      },
      {
        "id": "51",
        "title": "Create Scenario Zustand Store",
        "description": "Implement Zustand store for managing scenario data, execution state, and actions.",
        "details": "Create `src/stores/scenarioStore.ts` following the existing pattern from `panelStore.ts`:\n\n```typescript\nimport { create } from 'zustand';\nimport { devtools } from 'zustand/middleware';\n\ninterface ScenarioStoreState {\n  // Current scenario\n  scenario: Scenario | null;\n  isDirty: boolean;\n  filePath: string | null;\n  \n  // Execution state\n  executionState: ScenarioExecutionState;\n  \n  // Selection state\n  selectedEventIds: string[];\n  editingEventId: string | null;\n}\n\ninterface ScenarioStoreActions {\n  // Scenario operations\n  newScenario: () => void;\n  loadScenario: (scenario: Scenario, filePath?: string) => void;\n  updateMetadata: (metadata: Partial<ScenarioMetadata>) => void;\n  updateSettings: (settings: Partial<ScenarioSettings>) => void;\n  \n  // Event CRUD\n  addEvent: (event: Omit<ScenarioEvent, 'id'>) => string;\n  updateEvent: (id: string, updates: Partial<ScenarioEvent>) => void;\n  removeEvent: (id: string) => void;\n  duplicateEvent: (id: string) => string;\n  reorderEvents: (fromIndex: number, toIndex: number) => void;\n  toggleEventEnabled: (id: string) => void;\n  \n  // Bulk operations\n  removeSelectedEvents: () => void;\n  enableSelectedEvents: () => void;\n  disableSelectedEvents: () => void;\n  \n  // Selection\n  selectEvent: (id: string, multi?: boolean) => void;\n  selectRange: (fromId: string, toId: string) => void;\n  clearSelection: () => void;\n  \n  // Execution control (local state)\n  setExecutionState: (state: Partial<ScenarioExecutionState>) => void;\n  resetExecution: () => void;\n}\n```\n\nUse `immer` middleware for immutable updates. Events should auto-sort by time when modified.",
        "testStrategy": "Unit tests for all store actions, testing state transitions, event ordering, and selection logic. Test undo/redo capability if implemented.",
        "priority": "high",
        "dependencies": [
          "49"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define State Interface with Scenario, Execution State, and Selection State",
            "description": "Create the TypeScript interfaces for ScenarioStoreState including scenario data, execution state tracking, and selection management, following the established patterns from modbusStore.ts.",
            "dependencies": [],
            "details": "Create `src/stores/scenarioStore.ts` with type definitions:\n\n1. **Scenario Types** (from PRD):\n   - `ScenarioEvent` interface with id, time, address, value, persist, persistDuration, note, enabled fields\n   - `ScenarioMetadata` interface with name, description, createdAt, updatedAt, author\n   - `ScenarioSettings` interface with loop, loopCount, loopDelay, autoStart\n   - `Scenario` interface combining metadata, settings, and events array\n\n2. **Execution State**:\n   - `ScenarioExecutionState` interface with isRunning, isPaused, currentTime, currentEventIndex, completedEvents (string[]), loopIteration, error\n\n3. **Store State Interface**:\n   ```typescript\n   interface ScenarioStoreState {\n     scenario: Scenario | null;\n     isDirty: boolean;\n     filePath: string | null;\n     executionState: ScenarioExecutionState;\n     selectedEventIds: string[];\n     editingEventId: string | null;\n   }\n   ```\n\n4. Define `initialState` constant with default values (null scenario, empty execution state, empty selection)\n\n5. Set up store skeleton with `create`, `devtools`, and `immer` middleware following modbusStore pattern:\n   ```typescript\n   export const useScenarioStore = create<ScenarioStore>()(\n     devtools(\n       immer((set, get) => ({ ... })),\n       { name: 'scenario-store' }\n     )\n   );\n   ```",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation succeeds with all interfaces. Test that initial state matches expected defaults. Ensure store can be created and accessed without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:12:43.128Z"
          },
          {
            "id": 2,
            "title": "Implement Scenario CRUD Actions (newScenario, loadScenario, updateMetadata, updateSettings)",
            "description": "Implement the core scenario management actions for creating new scenarios, loading existing ones, and updating metadata/settings with proper dirty state tracking.",
            "dependencies": [
              1
            ],
            "details": "Add scenario CRUD actions to the store:\n\n1. **newScenario()**:\n   - Reset scenario to default with empty events array\n   - Set metadata with current timestamp, empty name/description/author\n   - Set default settings (loop: false, loopCount: 0, loopDelay: 1000, autoStart: false)\n   - Clear filePath, set isDirty to false\n   - Reset execution state and selection\n\n2. **loadScenario(scenario: Scenario, filePath?: string)**:\n   - Set scenario data directly\n   - Update filePath if provided\n   - Set isDirty to false\n   - Reset execution state\n   - Clear selection\n   - Sort events by time on load\n\n3. **updateMetadata(metadata: Partial<ScenarioMetadata>)**:\n   - Merge partial metadata with existing\n   - Update `updatedAt` timestamp automatically\n   - Set isDirty to true\n   - Use immer for immutable updates\n\n4. **updateSettings(settings: Partial<ScenarioSettings>)**:\n   - Merge partial settings with existing\n   - Update metadata.updatedAt\n   - Set isDirty to true\n\n5. **Helper: markDirty()**:\n   - Private helper to set isDirty and update timestamp\n\n6. **reset()**:\n   - Reset entire store to initialState (following modbusStore pattern)\n\nDevtools action names: 'newScenario', 'loadScenario', 'updateMetadata', 'updateSettings', 'reset'",
            "status": "done",
            "testStrategy": "Unit tests for: newScenario creates valid empty scenario, loadScenario sets all fields correctly, updateMetadata/updateSettings partially update and mark dirty, reset returns to initial state. Test dirty flag transitions.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:12:43.139Z"
          },
          {
            "id": 3,
            "title": "Implement Event CRUD Actions with Auto-Sorting by Time",
            "description": "Implement event management actions including add, update, remove, duplicate, reorder, and toggle enabled with automatic sorting by time after modifications.",
            "dependencies": [
              1
            ],
            "details": "Add event CRUD actions with auto-sorting:\n\n1. **ID Generator**:\n   - Create `generateEventId()` using nanoid or crypto.randomUUID()\n\n2. **sortEventsByTime()** helper:\n   - Sort events array by time field ascending\n   - Call after any event modification\n\n3. **addEvent(event: Omit<ScenarioEvent, 'id'>): string**:\n   - Generate unique id\n   - Add event with defaults: enabled=true, persist=true\n   - Sort events by time\n   - Mark dirty, return new id\n\n4. **updateEvent(id: string, updates: Partial<ScenarioEvent>)**:\n   - Find event by id and merge updates\n   - If time was updated, re-sort events\n   - Mark dirty\n\n5. **removeEvent(id: string)**:\n   - Filter out event by id\n   - Remove from selectedEventIds if selected\n   - Clear editingEventId if editing this event\n   - Mark dirty\n\n6. **duplicateEvent(id: string): string**:\n   - Clone event with new id\n   - Optionally offset time slightly (e.g., +0.1s)\n   - Insert after original, sort by time\n   - Mark dirty, return new id\n\n7. **reorderEvents(fromIndex: number, toIndex: number)**:\n   - Manual reorder (for drag-drop), updates time values to maintain order\n   - Recalculate times based on position or swap times\n   - Mark dirty\n\n8. **toggleEventEnabled(id: string)**:\n   - Toggle enabled field\n   - Mark dirty\n\nDevtools action names: 'addEvent/{id}', 'updateEvent/{id}', 'removeEvent/{id}', 'duplicateEvent/{id}', 'reorderEvents', 'toggleEventEnabled/{id}'",
            "status": "done",
            "testStrategy": "Unit tests for: addEvent generates unique ID and sorts correctly, updateEvent merges and re-sorts on time change, removeEvent cleans up selection state, duplicateEvent creates valid clone, reorderEvents updates order, toggleEventEnabled toggles. Test auto-sort after all modifications.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:12:43.150Z"
          },
          {
            "id": 4,
            "title": "Implement Selection, Bulk Operations, and Execution State Actions",
            "description": "Implement event selection (single, multi, range), bulk operations on selected events, and execution state management actions for controlling scenario playback.",
            "dependencies": [
              1,
              3
            ],
            "details": "Add selection, bulk operations, and execution state actions:\n\n**Selection Actions:**\n1. **selectEvent(id: string, multi?: boolean)**:\n   - If multi=false (default): replace selection with single id\n   - If multi=true: toggle id in/out of selection array\n   - Clear editingEventId when selection changes\n\n2. **selectRange(fromId: string, toId: string)**:\n   - Find indices of both events in sorted array\n   - Select all events between them (inclusive)\n   - Use for Shift+click selection\n\n3. **clearSelection()**:\n   - Set selectedEventIds to empty array\n   - Clear editingEventId\n\n4. **setEditingEventId(id: string | null)**:\n   - Set the currently editing event for inline editing\n\n**Bulk Operations:**\n5. **removeSelectedEvents()**:\n   - Remove all events in selectedEventIds\n   - Clear selection afterward\n   - Mark dirty\n\n6. **enableSelectedEvents()**:\n   - Set enabled=true for all selected events\n   - Mark dirty\n\n7. **disableSelectedEvents()**:\n   - Set enabled=false for all selected events\n   - Mark dirty\n\n**Execution State Actions:**\n8. **setExecutionState(state: Partial<ScenarioExecutionState>)**:\n   - Merge partial state updates\n   - For event-driven updates from Tauri backend\n\n9. **resetExecution()**:\n   - Reset to initial execution state (isRunning: false, isPaused: false, currentTime: 0, currentEventIndex: 0, completedEvents: [], loopIteration: 0, error: null)\n\n**Selectors:**\n- selectScenario, selectEvents, selectSelectedEvents, selectExecutionState, selectIsDirty, selectEnabledEvents",
            "status": "done",
            "testStrategy": "Unit tests for: selectEvent single/multi modes, selectRange selects correct range, clearSelection resets state, bulk operations affect only selected events, execution state updates merge correctly, resetExecution returns to defaults. Test selection edge cases (empty, already selected, invalid ids).",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:12:43.160Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Define state interface with scenario, execution state, and selection state following modbusStore patterns. 2) Implement scenario CRUD actions (newScenario, loadScenario, updateMetadata, updateSettings). 3) Implement event CRUD actions (addEvent, updateEvent, removeEvent, duplicateEvent) with auto-sorting by time. 4) Implement selection and bulk operations (selectEvent, selectRange, removeSelectedEvents, enable/disable selected).",
        "updatedAt": "2026-01-28T17:12:43.160Z"
      },
      {
        "id": "52",
        "title": "Build ScenarioGrid Spreadsheet Component",
        "description": "Create the main spreadsheet-like grid component for displaying and editing scenario events.",
        "details": "Create `src/components/ScenarioEditor/ScenarioGrid.tsx`:\n\nImplement a virtualized grid using CSS grid layout with columns matching the PRD spec:\n- Checkbox (30px): Event enable/disable toggle\n- Time (80px): Float input with 3 decimal places\n- Address (120px): Text input with validation\n- Value (80px): Number input (0-65535)\n- Persist (70px): Checkbox\n- Duration (80px): Number input (disabled when persist=true)\n- Note (flex): Text input\n\nFeatures:\n- Keyboard navigation (arrow keys, Tab, Enter)\n- Cell focus management\n- Row highlighting based on execution state:\n  - Completed: `bg-green-900/20`\n  - Current: `bg-yellow-900/30 animate-pulse`\n  - Disabled: `text-gray-500`\n  - Error: `ring-1 ring-red-500`\n- Multi-select support (Shift+click, Ctrl+click)\n- Context menu for row operations\n- Add row button at bottom\n\nUse existing Tailwind CSS patterns from the codebase. Reference `lucide-react` for icons.",
        "testStrategy": "Component tests verifying rendering, keyboard navigation, selection behavior, and proper styling based on execution state. E2E tests for user interactions.",
        "priority": "high",
        "dependencies": [
          "49",
          "51"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CSS Grid Layout with Fixed-Width Columns Matching PRD Spec",
            "description": "Implement the base ScenarioGrid component with CSS grid layout defining all column widths according to PRD specifications.",
            "dependencies": [],
            "details": "Create `src/components/ScenarioEditor/ScenarioGrid.tsx` with CSS grid layout. Define columns: Checkbox (30px), Time (80px), Address (120px), Value (80px), Persist (70px), Duration (80px), Note (flex: 1fr). Implement the grid container with `display: grid` and `grid-template-columns`. Create header row with column labels using existing Tailwind patterns. Set up basic cell rendering for each column type - checkbox inputs for enable/persist, number inputs for time/value/duration, text inputs for address/note. Apply consistent cell padding and borders matching the codebase style. Ensure proper scrolling behavior for large datasets.",
            "status": "done",
            "testStrategy": "Unit test verifying grid renders with correct column widths. Snapshot test for header row. Test that all 7 columns are present with correct input types. Verify responsive behavior when container resizes.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:14:52.649Z"
          },
          {
            "id": 2,
            "title": "Implement Keyboard Navigation with Cell Focus Management",
            "description": "Add comprehensive keyboard navigation support including arrow keys, Tab, Enter with proper cell focus tracking and management.",
            "dependencies": [
              1
            ],
            "details": "Implement focus management system using React refs and state to track active cell position (row, column). Handle arrow key navigation - Up/Down moves between rows, Left/Right moves between columns with wrap-around at row boundaries. Tab key advances to next cell, Shift+Tab moves to previous cell. Enter key confirms edit and moves to next row (same column). Escape key cancels edit and restores previous value. Create useFocusManager hook to encapsulate focus logic. Prevent focus from entering disabled cells (duration when persist=true, disabled rows). Implement visual focus indicator ring around active cell using Tailwind classes `ring-2 ring-blue-500`.",
            "status": "done",
            "testStrategy": "Unit tests for keyboard event handlers. Test arrow key navigation in all directions. Test Tab/Shift+Tab cycling. Test Enter commits changes. Test Escape cancels edit. Test focus skips disabled cells. Integration test for complete navigation flow.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:14:52.662Z"
          },
          {
            "id": 3,
            "title": "Implement Row Rendering with Execution State Highlighting",
            "description": "Create row component with dynamic styling based on execution state including completed, current, disabled, and error states.",
            "dependencies": [
              1
            ],
            "details": "Create ScenarioGridRow component that receives event data and execution state. Connect to scenario store to get execution state (executionState.completedEvents, executionState.currentEventIndex). Implement conditional Tailwind classes: completed events get `bg-green-900/20`, current executing event gets `bg-yellow-900/30 animate-pulse`, disabled events (enabled=false) get `text-gray-500` with reduced opacity, events with validation errors get `ring-1 ring-red-500`. Create helper function getRowClassName(event, executionState) for clean logic. Ensure proper z-index layering so highlighting doesn't interfere with focus indicators. Add smooth transitions between states using `transition-colors duration-200`.",
            "status": "done",
            "testStrategy": "Component tests rendering rows in each execution state. Test completed row has green background. Test current row has yellow background with animation. Test disabled row has gray text. Test error row has red ring. Test state transitions happen smoothly. Mock scenario store for testing.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:14:52.672Z"
          },
          {
            "id": 4,
            "title": "Add Multi-Select Support with Shift+Click and Ctrl+Click",
            "description": "Implement row multi-selection functionality supporting Shift+click for range selection and Ctrl+click for toggle selection with visual feedback.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add selectedRows state as Set<number> to track selected row indices. Implement click handler that checks modifier keys: plain click selects single row and clears others, Ctrl+click (Cmd on Mac) toggles individual row selection, Shift+click selects range from last selected row to clicked row. Store lastSelectedRow for range selection anchor. Add visual feedback for selected rows using `bg-blue-900/30` background in addition to execution state styling. Implement Select All (Ctrl+A) keyboard shortcut when grid is focused. Create useRowSelection hook to encapsulate selection logic. Expose selected rows for context menu operations. Add selection count indicator in toolbar area.",
            "status": "done",
            "testStrategy": "Test single click selects one row. Test Ctrl+click toggles selection. Test Shift+click selects range. Test Ctrl+A selects all rows. Test clicking outside clears selection. Test selection state persists during scroll. Test visual feedback matches design spec.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:14:52.684Z"
          },
          {
            "id": 5,
            "title": "Implement Context Menu and Add Row Functionality",
            "description": "Create right-click context menu for row operations and add row button at the bottom of the grid.",
            "dependencies": [
              1,
              4
            ],
            "details": "Create ScenarioGridContextMenu component using a dropdown/popover pattern. Show on right-click with options: Insert Row Above, Insert Row Below, Duplicate Row(s), Delete Row(s), Enable/Disable Row(s), Copy, Paste. Menu items should be contextual based on selection (pluralize when multiple rows selected). Disable irrelevant options (e.g., can't delete if no selection). Use lucide-react icons: Plus, Copy, Trash2, ToggleLeft. Create Add Row button fixed at bottom of grid using existing button styles - `+ Add Event` with Plus icon. Connect menu actions to scenario store mutations. Handle keyboard shortcut for delete (Delete key) and duplicate (Ctrl+D). Close menu on action execution or click outside.",
            "status": "done",
            "testStrategy": "Test context menu appears on right-click at correct position. Test all menu items are present and functional. Test menu items disabled when appropriate. Test Add Row button creates new event at end. Test Delete key removes selected rows. Test Ctrl+D duplicates selection. E2E test for complete row operation workflow.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:14:52.696Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Create grid layout with fixed-width columns matching PRD spec using CSS grid. 2) Implement keyboard navigation (arrow keys, Tab, Enter) with cell focus management. 3) Implement row rendering with execution state highlighting (completed, current, disabled, error). 4) Add multi-select support (Shift+click, Ctrl+click) with visual feedback. 5) Implement context menu and add row functionality.",
        "updatedAt": "2026-01-28T17:14:52.696Z"
      },
      {
        "id": "53",
        "title": "Implement Cell Editor Components",
        "description": "Create specialized cell editor components for each column type in the scenario grid.",
        "details": "Create cell components in `src/components/ScenarioEditor/cells/`:\n\n**TimeCell.tsx**\n- Input type: number with step=0.001\n- Format display: 0.000s\n- Validate: >= 0\n- On blur: auto-sort events by time\n\n**AddressCell.tsx**\n- Input with autocomplete dropdown\n- Real-time validation using addressParser\n- Shows parsed type icon (C/DI/H/IR)\n- Red border for invalid addresses\n\n**ValueCell.tsx**\n- Number input (0-65535)\n- For coil addresses, show 0/1 toggle button\n- For registers, allow full u16 range\n\n**PersistCell.tsx**\n- Checkbox with label\n- When unchecked, auto-focus Duration cell\n\n**DurationCell.tsx**\n- Number input (ms)\n- Disabled when Persist is checked\n- Default: 500ms\n- Show 'ms' suffix\n\n**NoteCell.tsx**\n- Simple text input\n- Truncate with ellipsis in display mode\n- Full width on focus\n\nAll cells should support:\n- onFocus/onBlur for edit mode toggle\n- onKeyDown for navigation (Tab, Enter, Escape)\n- Consistent styling with existing codebase",
        "testStrategy": "Unit tests for each cell component validating input constraints, formatting, and keyboard interactions. Test AddressCell validation with various address formats.",
        "priority": "high",
        "dependencies": [
          "50",
          "52"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TimeCell with Number Input, Formatting, and Auto-Sort Trigger",
            "description": "Implement TimeCell component with precise time input handling, 0.000s display format, non-negative validation, and parent communication for auto-sorting events on blur.",
            "dependencies": [],
            "details": "Create `src/components/ScenarioEditor/cells/TimeCell.tsx`:\n\n1. **Input Configuration:**\n   - Use number input with step=0.001 for millisecond precision\n   - Set min=0 to prevent negative values\n   - Handle both controlled input state and formatting\n\n2. **Display Formatting:**\n   - In display mode: format as `{value.toFixed(3)}s`\n   - In edit mode: show raw number value\n   - Toggle between modes using onFocus/onBlur\n\n3. **Validation Logic:**\n   - Validate value >= 0 on change and blur\n   - Clamp negative values to 0\n   - Handle empty input gracefully (default to 0)\n\n4. **Auto-Sort Integration:**\n   - Accept `onSortRequest` callback prop from parent\n   - Call `onSortRequest()` on blur after value commit\n   - Parent grid will sort events by time column ascending\n\n5. **Keyboard Navigation:**\n   - Tab: move to next cell\n   - Enter: commit value and exit edit mode\n   - Escape: revert to original value and exit edit mode\n\n6. **Styling:**\n   - Use consistent input styling with existing codebase\n   - Right-align numbers for better readability\n   - Subtle focus ring on edit mode",
            "status": "done",
            "testStrategy": "Unit tests: validate input accepts only non-negative numbers, format displays as 0.000s, onBlur triggers sort callback, keyboard shortcuts work correctly. Test edge cases: very large numbers, floating point precision.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:17:17.444Z"
          },
          {
            "id": 2,
            "title": "Create AddressCell with Autocomplete, Validation, and Type Icon Display",
            "description": "Implement AddressCell component with autocomplete dropdown, real-time validation using addressParser, visual type indicators (C/DI/H/IR icons), and invalid state styling.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/ScenarioEditor/cells/AddressCell.tsx`:\n\n1. **Autocomplete Dropdown:**\n   - Show dropdown on focus with common address suggestions\n   - Filter suggestions as user types (e.g., typing 'C' shows coil addresses)\n   - Support keyboard navigation in dropdown (Arrow Up/Down, Enter to select)\n   - Dismiss dropdown on Escape or blur\n\n2. **Real-Time Validation:**\n   - Import and use existing `addressParser` utility\n   - Validate on every keystroke with debounce (100ms)\n   - Parse address to determine type (Coil, Discrete Input, Holding Register, Input Register)\n   - Store parsed result for type icon display\n\n3. **Type Icon Display:**\n   - Show icon/badge indicating parsed address type:\n     - C: Coil icon\n     - DI: Discrete Input icon\n     - H: Holding Register icon\n     - IR: Input Register icon\n   - Position icon at start of cell (left side)\n   - Gray out icon when input is empty\n\n4. **Invalid State Styling:**\n   - Red border (border-red-500) when address is invalid\n   - Optional error tooltip showing validation message\n   - Clear red styling immediately when input becomes valid\n\n5. **Keyboard Navigation:**\n   - Tab: commit and move to next cell\n   - Enter: select dropdown item or commit\n   - Escape: close dropdown or revert value\n   - Arrow keys: navigate dropdown when open",
            "status": "done",
            "testStrategy": "Unit tests: validate various address formats (C0, C100, DI0, H40001, IR30001), test autocomplete filtering, verify type icons appear correctly, test red border appears for invalid addresses. Test keyboard navigation through dropdown.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:17:17.456Z"
          },
          {
            "id": 3,
            "title": "Create ValueCell with Conditional Rendering for Coils and Registers",
            "description": "Implement ValueCell component with conditional UI - toggle button for coil addresses (0/1) and full-range number input (0-65535) for register addresses.",
            "dependencies": [
              2
            ],
            "details": "Create `src/components/ScenarioEditor/cells/ValueCell.tsx`:\n\n1. **Address Type Detection:**\n   - Accept `addressType` prop from parent row context\n   - Determine if address is Coil type or Register type\n   - Re-render when address type changes\n\n2. **Coil Toggle Button (for C addresses):**\n   - Display toggle button with ON/OFF or 1/0 labels\n   - Visual feedback: green when ON (1), gray when OFF (0)\n   - Single click toggles value\n   - Accessible: keyboard Enter/Space to toggle\n\n3. **Register Number Input (for H/IR/DI addresses):**\n   - Number input with min=0, max=65535 (u16 range)\n   - Validate input stays within range\n   - Clamp out-of-range values on blur\n   - Handle empty input (default to 0)\n\n4. **Common Behaviors:**\n   - onFocus/onBlur for edit mode state\n   - Keyboard navigation: Tab, Enter, Escape\n   - Consistent sizing regardless of input type\n\n5. **Styling:**\n   - Toggle button: rounded, colored states\n   - Number input: right-aligned, consistent with TimeCell\n   - Smooth transition between display and edit modes",
            "status": "done",
            "testStrategy": "Unit tests: verify toggle renders for Coil addresses, number input renders for Register addresses. Test toggle switches between 0 and 1. Test number input validates 0-65535 range. Test switching address types updates UI correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:17:17.466Z"
          },
          {
            "id": 4,
            "title": "Create PersistCell, DurationCell, and NoteCell with Keyboard Navigation",
            "description": "Implement remaining cell components: PersistCell (checkbox with auto-focus behavior), DurationCell (conditional number input with ms suffix), and NoteCell (text with truncation), all with consistent keyboard navigation.",
            "dependencies": [
              1
            ],
            "details": "Create three cell components in `src/components/ScenarioEditor/cells/`:\n\n**PersistCell.tsx:**\n- Checkbox input with 'Persist' label\n- When unchecked, programmatically focus DurationCell in same row\n- Accept `onFocusDuration` callback prop for row coordination\n- Accessible: keyboard Space to toggle\n\n**DurationCell.tsx:**\n- Number input for duration in milliseconds\n- Accept `isPersisted` prop from row context\n- When `isPersisted=true`: disable input, show grayed styling\n- When `isPersisted=false`: enable input, default value 500\n- Display 'ms' suffix text after input\n- Validate positive numbers only\n- Accept focus programmatically from PersistCell\n\n**NoteCell.tsx:**\n- Text input for free-form notes\n- Display mode: truncate with ellipsis (CSS text-overflow)\n- Edit mode: expand to full width, show all text\n- No validation required\n- Support multi-byte characters (Korean, etc.)\n\n**Shared Keyboard Navigation:**\n- All cells implement onKeyDown handler\n- Tab: move to next cell in row\n- Shift+Tab: move to previous cell\n- Enter: commit and exit edit mode\n- Escape: revert changes and exit edit mode\n- Create shared hook `useCellNavigation` for consistency\n\n**Shared Styling:**\n- Consistent padding, border-radius, focus states\n- Match existing codebase design tokens\n- Export all cells from `cells/index.ts` barrel file",
            "status": "done",
            "testStrategy": "Unit tests: PersistCell toggle triggers focus on DurationCell, DurationCell disables when persist is true, NoteCell truncates long text with ellipsis. Test keyboard navigation (Tab, Enter, Escape) works consistently across all cells. Integration test: full row keyboard navigation flow.",
            "parentId": "undefined",
            "updatedAt": "2026-01-28T17:17:17.478Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create TimeCell with number input, formatting (0.000s), and auto-sort trigger on blur. 2) Create AddressCell with autocomplete, real-time validation, and type icon display. 3) Create ValueCell with conditional rendering (toggle for coils, number input for registers). 4) Create PersistCell, DurationCell, and NoteCell with their specific behaviors and keyboard navigation support.",
        "updatedAt": "2026-01-28T17:17:17.478Z"
      },
      {
        "id": "54",
        "title": "Create ScenarioToolbar Component",
        "description": "Build the toolbar with execution controls, file operations, and scenario settings.",
        "details": "Create `src/components/ScenarioEditor/ScenarioToolbar.tsx`:\n\nLayout matching PRD mockup:\n```\n[▶ Run] [⏸ Pause] [⏹ Stop] [🔁 Loop: ON]  Time: 00:05.234\n```\n\nComponents:\n- **Execution buttons**: Play/Pause/Stop using lucide-react icons (Play, Pause, Square)\n- **Loop toggle**: Button with state indicator\n- **Time display**: mm:ss.fff format, updated from execution state\n- **File dropdown menu**: New, Open, Save, Save As, Import CSV, Export CSV\n  - Use existing dialog patterns from `@tauri-apps/plugin-dialog`\n\nButton states:\n- Run: enabled when idle/stopped/paused, disabled when running\n- Pause: enabled when running, disabled otherwise\n- Stop: enabled when running/paused, disabled when idle\n\nSettings button opens ScenarioSettingsDialog:\n- Loop enabled/disabled\n- Loop count (0 = infinite)\n- Loop delay (ms)\n- Auto-start with simulation\n\nIntegrate with scenarioStore actions.",
        "testStrategy": "Component tests verifying button enable/disable states based on execution state. Test file operation handlers are called correctly.",
        "priority": "medium",
        "dependencies": [
          "51"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create toolbar layout with execution buttons (Play/Pause/Stop)",
            "description": "Build the core ScenarioToolbar component with execution control buttons (Play, Pause, Stop) using lucide-react icons with proper enable/disable state logic based on scenario execution state.",
            "dependencies": [],
            "details": "Create `src/components/ScenarioEditor/ScenarioToolbar.tsx` with the following implementation:\n\n1. **Component Structure**:\n   - Create reusable `ToolbarButton` component following pattern from `src/components/layout/Toolbar.tsx`\n   - Import icons from lucide-react: `Play`, `Pause`, `Square` (Stop)\n   - Use CSS variables for theming: `--bg-primary`, `--text-primary`, `--border-color`, etc.\n\n2. **Button State Logic**:\n   - Connect to scenarioStore to get `executionState` (idle, running, paused, stopped)\n   - Run button: enabled when `idle`, `stopped`, or `paused`; disabled when `running`\n   - Pause button: enabled when `running`; disabled otherwise\n   - Stop button: enabled when `running` or `paused`; disabled when `idle`\n\n3. **Actions Integration**:\n   - Wire buttons to scenarioStore actions: `runScenario()`, `pauseScenario()`, `stopScenario()`\n   - Use `ToolbarSeparator` pattern for visual grouping\n\n4. **Layout**:\n   - Horizontal flex layout matching PRD mockup: `[▶ Run] [⏸ Pause] [⏹ Stop]`\n   - Include tooltips on buttons with keyboard shortcuts if applicable\n   - Size buttons consistently (e.g., `w-8 h-8`) with hover states",
            "status": "pending",
            "testStrategy": "Test button enable/disable states by mocking scenarioStore with different executionState values (idle, running, paused, stopped). Verify correct store actions are called on button clicks. Test visual disabled styling is applied correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement loop toggle, time display, and file dropdown menu",
            "description": "Add loop toggle button with state indicator, real-time time display in mm:ss.fff format, and file operations dropdown menu (New, Open, Save, Save As, Import CSV, Export CSV) using @tauri-apps/plugin-dialog.",
            "dependencies": [
              1
            ],
            "details": "Extend ScenarioToolbar.tsx with additional controls:\n\n1. **Loop Toggle Button**:\n   - Use `Repeat` icon from lucide-react with visual state indicator\n   - Display \"Loop: ON/OFF\" text or icon color change based on `scenario.settings.loop`\n   - Wire to scenarioStore action `toggleLoop()` or `updateSettings()`\n\n2. **Time Display**:\n   - Format: `Time: mm:ss.fff` (e.g., \"00:05.234\")\n   - Create utility function `formatScenarioTime(ms: number): string` in `utils/timeUtils.ts`\n   - Read from `executionState.currentTime` in scenarioStore\n   - Use monospace font for stable width during updates\n\n3. **File Dropdown Menu**:\n   - Create dropdown component or use existing pattern from codebase\n   - Menu items: New, Open, Save, Save As, ---separator---, Import CSV, Export CSV\n   - Use `ChevronDown` or `MoreVertical` icon for dropdown trigger\n   - Integrate with `@tauri-apps/plugin-dialog` following patterns from `NewProjectDialog.tsx` and `useOpenProjectDialog.ts`:\n     - `open()` with filters `[{ name: 'Scenario Files', extensions: ['json', 'scenario'] }]`\n     - `save()` for Save As with default filename\n     - CSV filters: `[{ name: 'CSV Files', extensions: ['csv'] }]`\n   - Wire to scenarioStore actions: `newScenario()`, `loadScenario(path)`, `saveScenario()`, `saveScenarioAs(path)`, `importCSV(path)`, `exportCSV(path)`",
            "status": "pending",
            "testStrategy": "Test loop toggle updates store state and reflects visual change. Test time formatting utility with edge cases (0ms, large values, boundary seconds). Mock @tauri-apps/plugin-dialog to verify correct dialog options are passed. Test dropdown menu renders all options and calls correct handlers.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create ScenarioSettingsDialog for loop configuration",
            "description": "Build modal dialog for scenario settings including loop enabled/disabled, loop count (0=infinite), loop delay (ms), and auto-start with simulation options.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/ScenarioEditor/ScenarioSettingsDialog.tsx` following the pattern from `SettingsDialog.tsx`:\n\n1. **Dialog Structure**:\n   - Modal with backdrop, header with close button, content area, footer with Cancel/Save buttons\n   - Use CSS variables for theming consistency\n   - Handle ESC key to close dialog\n\n2. **Form Fields**:\n   - **Loop Enabled**: Checkbox or toggle switch for `settings.loop`\n   - **Loop Count**: Number input for `settings.loopCount` (0 = infinite, show hint text)\n   - **Loop Delay**: Number input for `settings.loopDelay` in milliseconds with min=0\n   - **Auto-start**: Checkbox for `settings.autoStart` (start scenario when simulation starts)\n\n3. **State Management**:\n   - Use local form state that syncs with scenarioStore on open\n   - Track dirty state for unsaved changes warning\n   - On Save: call `scenarioStore.updateSettings(newSettings)` and close\n   - On Cancel: discard changes and close\n\n4. **Integration with Toolbar**:\n   - Add Settings button (use `Settings` icon from lucide-react) to ScenarioToolbar\n   - Control dialog open state from toolbar or lift to parent component\n\n5. **Validation**:\n   - Loop count must be >= 0\n   - Loop delay must be >= 0\n   - Show inline validation errors",
            "status": "pending",
            "testStrategy": "Test dialog opens/closes correctly via Settings button. Test form fields update local state. Test validation errors display for invalid inputs (negative numbers). Test Save button updates scenarioStore and closes dialog. Test Cancel discards changes. Test ESC key closes dialog.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into: 1) Create toolbar layout with execution buttons (Play/Pause/Stop) using lucide-react icons with proper enable/disable states. 2) Implement loop toggle, time display (mm:ss.fff format), and file dropdown menu. 3) Create ScenarioSettingsDialog for loop configuration (count, delay, auto-start).",
        "updatedAt": "2026-01-28T17:36:11.476Z"
      },
      {
        "id": "55",
        "title": "Implement CSV Parser and Generator",
        "description": "Create utilities for importing and exporting scenario data in CSV format.",
        "details": "Create `src/components/ScenarioEditor/utils/csvParser.ts`:\n\n**CSV Format** (matching PRD):\n```csv\ntime,address,value,persist,duration,note\n0.000,C:0x0001,1,true,,Motor Start\n1.500,C:0x0002,1,false,500,Sensor Trigger\n```\n\n**Functions**:\n```typescript\nexport interface CsvParseResult {\n  events: ScenarioEvent[];\n  errors: { line: number; message: string }[];\n  warnings: { line: number; message: string }[];\n}\n\nexport function parseScenarioCsv(content: string): CsvParseResult\nexport function generateScenarioCsv(events: ScenarioEvent[]): string\n```\n\n**Parsing rules**:\n- Skip empty lines and comment lines (starting with #)\n- Auto-detect delimiter (comma or semicolon)\n- Handle quoted fields (for notes with commas)\n- Generate unique IDs for imported events\n- Set enabled=true by default\n- Validate addresses and values, collect errors\n\n**Export rules**:\n- Always use comma delimiter\n- Quote notes containing special characters\n- Format time to 3 decimal places\n- Convert boolean to 'true'/'false'\n- Omit duration for persist=true events",
        "testStrategy": "Unit tests for round-trip parsing (export → import → compare). Test error handling for malformed CSV, invalid addresses, out-of-range values.",
        "priority": "medium",
        "dependencies": [
          "49",
          "50"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement parseScenarioCsv with Line Parsing and Delimiter Detection",
            "description": "Implement the core CSV parsing function with support for comma and semicolon delimiters, quoted field handling for notes, and proper line parsing that skips empty lines and comments.",
            "dependencies": [],
            "details": "Create `src/components/ScenarioEditor/utils/csvParser.ts` with:\n\n1. **Delimiter Detection**: Analyze first data line to detect comma vs semicolon delimiter by counting occurrences.\n\n2. **Line Parsing State Machine**:\n   - Track if inside quotes for handling fields containing delimiters\n   - Handle escaped quotes within quoted fields (double-quote escaping)\n   - Skip empty lines and lines starting with #\n\n3. **Field Extraction**:\n   - Parse header row to validate expected columns: time, address, value, persist, duration, note\n   - Extract each field respecting quoted boundaries\n\n4. **Event Conversion**:\n   - Convert parsed row to ScenarioEvent interface\n   - Generate unique ID using crypto.randomUUID() or similar\n   - Parse time as float, address as string, value as number\n   - Parse persist as boolean ('true'/'false'/empty)\n   - Parse duration as optional number (empty string = undefined)\n   - Set enabled=true by default\n\n5. **Return Structure**:\n   - Return CsvParseResult with events array populated\n   - Initialize empty errors and warnings arrays for next subtask",
            "status": "pending",
            "testStrategy": "Unit tests for: 1) Comma delimiter detection with valid CSV, 2) Semicolon delimiter detection, 3) Quoted fields containing commas parse correctly, 4) Comments and empty lines are skipped, 5) Header row validation, 6) Boolean parsing for persist field, 7) Optional duration field handling, 8) Generated events have unique IDs and enabled=true",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Error and Warning Collection for Invalid CSV Data",
            "description": "Add comprehensive validation logic to parseScenarioCsv that collects errors for invalid addresses and out-of-range values, and warnings for recoverable issues, with line number tracking.",
            "dependencies": [
              1
            ],
            "details": "Extend the parseScenarioCsv function with validation:\n\n1. **Address Validation**:\n   - Use existing addressParser utility to validate address format\n   - Collect error with line number for invalid address patterns\n   - Supported formats: C:0x0001, DI:0x0001, H:0x0001, IR:0x0001\n   - Skip event but continue parsing on invalid address\n\n2. **Value Validation**:\n   - Range check: 0-65535 for registers, 0-1 for coils\n   - Error for values outside valid range\n   - Error for non-numeric values\n\n3. **Time Validation**:\n   - Error for negative time values\n   - Error for non-numeric time\n   - Warning for very large time values (> 3600s)\n\n4. **Duration Validation**:\n   - Error for negative duration\n   - Warning if duration specified with persist=true (will be ignored)\n\n5. **Error Object Structure**:\n   ```typescript\n   { line: number; message: string }\n   ```\n   - Line numbers should be 1-indexed for user clarity\n   - Include field name and actual value in error messages\n\n6. **Partial Success Handling**:\n   - Continue parsing after errors, collecting all issues\n   - Return valid events along with error/warning lists",
            "status": "pending",
            "testStrategy": "Unit tests for: 1) Invalid address format generates error with correct line number, 2) Out-of-range value (>65535) generates error, 3) Coil value > 1 generates error, 4) Negative time generates error, 5) Non-numeric value generates error, 6) Duration with persist=true generates warning, 7) Multiple errors collected from single file, 8) Valid events still returned alongside errors",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement generateScenarioCsv with Formatting and Escaping",
            "description": "Implement the CSV generation function that exports ScenarioEvent array to properly formatted CSV string with correct escaping, time formatting, and persist/duration logic.",
            "dependencies": [
              1
            ],
            "details": "Create generateScenarioCsv function in csvParser.ts:\n\n1. **Header Generation**:\n   - Always output header row: time,address,value,persist,duration,note\n   - Use comma as delimiter (per requirement)\n\n2. **Time Formatting**:\n   - Format to exactly 3 decimal places using toFixed(3)\n   - Example: 1.5 becomes '1.500'\n\n3. **Boolean Formatting**:\n   - Convert persist boolean to lowercase string 'true'/'false'\n\n4. **Duration Field Logic**:\n   - If persist=true, omit duration value (empty field)\n   - If persist=false, include duration value or empty if undefined\n\n5. **Note Field Escaping**:\n   - Quote notes containing: comma, newline, or double-quote\n   - Escape internal double-quotes by doubling them (\"\") \n   - Example: Note with \"quotes\" becomes \"Note with \"\"quotes\"\"\"\n\n6. **Row Generation**:\n   - Join fields with comma delimiter\n   - Each event becomes one line\n   - Use \\n line endings for cross-platform compatibility\n\n7. **Empty/Null Handling**:\n   - Empty note becomes empty field (not quoted)\n   - Undefined duration becomes empty field\n\n8. **Filter Disabled Events**:\n   - Only export events where enabled=true",
            "status": "pending",
            "testStrategy": "Unit tests for: 1) Round-trip test: parse(generate(events)) equals original events, 2) Time formatted to 3 decimal places, 3) Notes with commas are properly quoted, 4) Notes with quotes are escaped with double-quotes, 5) persist=true events have empty duration field, 6) Boolean values are lowercase strings, 7) Header row is always present, 8) Disabled events are excluded from export",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into: 1) Implement parseScenarioCsv with line parsing, delimiter detection, and quoted field handling. 2) Implement error/warning collection for invalid data (bad addresses, out-of-range values). 3) Implement generateScenarioCsv with proper formatting, escaping, and persist logic for duration field.",
        "updatedAt": "2026-01-28T17:48:07.063Z"
      },
      {
        "id": "56",
        "title": "Implement Tauri Backend Scenario Commands",
        "description": "Create Rust Tauri commands for scenario file operations and execution control.",
        "details": "Create `src-tauri/src/scenario/mod.rs` module:\n\n**Types** (matching frontend):\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ScenarioEvent {\n    pub id: String,\n    pub time: f64,\n    pub address: String,\n    pub value: u16,\n    pub persist: bool,\n    pub persist_duration: Option<u64>,\n    pub note: String,\n    pub enabled: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Scenario {\n    pub metadata: ScenarioMetadata,\n    pub settings: ScenarioSettings,\n    pub events: Vec<ScenarioEvent>,\n}\n```\n\n**Commands** (in `src-tauri/src/commands/scenario.rs`):\n```rust\n#[tauri::command]\nasync fn scenario_load(path: String) -> Result<Scenario, String>\n\n#[tauri::command]\nasync fn scenario_save(path: String, scenario: Scenario) -> Result<(), String>\n\n#[tauri::command]\nasync fn scenario_import_csv(path: String) -> Result<Vec<ScenarioEvent>, String>\n\n#[tauri::command]\nasync fn scenario_export_csv(path: String, events: Vec<ScenarioEvent>) -> Result<(), String>\n```\n\nRegister commands in `src-tauri/src/lib.rs` following existing pattern from modbus commands.",
        "testStrategy": "Rust unit tests for file I/O operations. Integration tests saving and loading scenario files, CSV round-trip.",
        "priority": "medium",
        "dependencies": [
          "49"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Rust types for scenario data structures",
            "description": "Create the Rust data structures (ScenarioEvent, ScenarioMetadata, ScenarioSettings, Scenario) with proper serde derives for JSON serialization/deserialization.",
            "dependencies": [],
            "details": "Create `src-tauri/src/scenario/mod.rs` module with the following types:\n\n1. **ScenarioEvent** - Event data with id, time, address, value, persist, persist_duration, note, enabled fields\n2. **ScenarioMetadata** - Metadata fields (name, description, created_at, modified_at, version)\n3. **ScenarioSettings** - Settings like loop_enabled, loop_count, playback_speed\n4. **Scenario** - Container struct with metadata, settings, and events vector\n\nAll types must derive: Debug, Clone, Serialize, Deserialize. Use #[serde(rename_all = \"camelCase\")] to match frontend TypeScript naming conventions. Add re-exports in mod.rs.",
            "status": "pending",
            "testStrategy": "Unit tests verifying serialization round-trip: create instance -> serialize to JSON -> deserialize back -> verify equality. Test optional fields like persist_duration handle None correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement JSON file I/O commands (load/save)",
            "description": "Create Tauri commands for loading and saving scenario files in JSON format with proper error handling.",
            "dependencies": [
              1
            ],
            "details": "Create `src-tauri/src/commands/scenario.rs` with:\n\n1. **scenario_load(path: String) -> Result<Scenario, String>**\n   - Read file using std::fs::read_to_string\n   - Deserialize JSON using serde_json::from_str\n   - Map errors to descriptive strings\n\n2. **scenario_save(path: String, scenario: Scenario) -> Result<(), String>**\n   - Serialize using serde_json::to_string_pretty for readability\n   - Write file using std::fs::write\n   - Handle file permission and path errors\n\nRegister commands in `src-tauri/src/lib.rs` following the existing pattern from modbus/project commands. Add scenario module declaration.",
            "status": "pending",
            "testStrategy": "Integration tests: create temp file, save scenario, load it back, verify data matches. Test error cases: non-existent file, invalid JSON, permission denied scenarios.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement CSV import/export commands",
            "description": "Create Tauri commands for importing and exporting scenario events in CSV format for interoperability with spreadsheet tools.",
            "dependencies": [
              1
            ],
            "details": "Add to `src-tauri/src/commands/scenario.rs`:\n\n1. **scenario_import_csv(path: String) -> Result<Vec<ScenarioEvent>, String>**\n   - Use csv crate for parsing\n   - Handle header row (time,address,value,persist,persist_duration,note,enabled)\n   - Generate UUIDs for imported events\n   - Validate data types and ranges (value 0-65535, time >= 0)\n   - Return descriptive errors for malformed rows\n\n2. **scenario_export_csv(path: String, events: Vec<ScenarioEvent>) -> Result<(), String>**\n   - Write CSV with header row\n   - Format time with 3 decimal precision\n   - Handle optional persist_duration field\n\nAdd csv = \"1.3\" to Cargo.toml dependencies if not present.",
            "status": "pending",
            "testStrategy": "Unit tests for CSV parsing edge cases: empty file, missing columns, invalid values. Integration tests: export events -> import back -> verify data integrity. Test Unicode characters in note field.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into: 1) Define Rust types (ScenarioEvent, Scenario, ScenarioMetadata, ScenarioSettings) with Serialize/Deserialize. 2) Implement file I/O commands (scenario_load, scenario_save) with JSON serialization. 3) Implement CSV import/export commands with error handling.",
        "updatedAt": "2026-01-28T17:41:09.223Z"
      },
      {
        "id": "57",
        "title": "Implement Scenario Execution Engine",
        "description": "Build the execution engine that schedules and executes scenario events based on elapsed time.",
        "details": "Create `src/components/ScenarioEditor/hooks/useScenarioExecution.ts`:\n\n**Execution Logic**:\n```typescript\nexport function useScenarioExecution() {\n  const { scenario, executionState, setExecutionState } = useScenarioStore();\n  \n  // Use requestAnimationFrame for precise timing\n  const animationFrameRef = useRef<number>();\n  const startTimeRef = useRef<number>();\n  \n  const run = () => {\n    startTimeRef.current = performance.now();\n    setExecutionState({ status: 'running' });\n    tick();\n  };\n  \n  const tick = () => {\n    const elapsed = (performance.now() - startTimeRef.current) / 1000;\n    // Find events to execute\n    // Call modbus write commands via invoke()\n    // Update execution state\n    animationFrameRef.current = requestAnimationFrame(tick);\n  };\n  \n  // Handle persist=false auto-release with setTimeout\n  const scheduledReleases = useRef<Map<string, NodeJS.Timeout>>();\n}\n```\n\n**Event Execution**:\n- Use existing Tauri commands: `modbus_write_coil`, `modbus_write_holding_register`\n- Parse address using addressParser to determine memory type\n- For persist=false: schedule value reset after persistDuration\n\n**Loop Handling**:\n- After last event, check loop settings\n- If looping, wait loopDelay then reset time to 0\n- Track iteration count, stop when reaching loopCount (unless 0)\n\n**Events emitted**:\n- `scenario:event-executed` - { eventId, address, value, time }\n- `scenario:status-changed` - { status, currentTime }",
        "testStrategy": "Integration tests simulating time progression, verifying events execute at correct times. Test loop behavior, pause/resume, and persist duration auto-release.",
        "priority": "high",
        "dependencies": [
          "50",
          "51",
          "56"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create useScenarioExecution hook with requestAnimationFrame timing loop",
            "description": "Build the core execution hook with precise requestAnimationFrame-based timing, providing run/pause/stop/reset controls and tracking elapsed time.",
            "dependencies": [],
            "details": "Create `src/components/ScenarioEditor/hooks/useScenarioExecution.ts` with:\n\n1. **Core refs and state**:\n   - `animationFrameRef` for storing rAF handle\n   - `startTimeRef` for tracking when execution began\n   - `pausedTimeRef` for tracking accumulated time when paused\n   - `lastTickTimeRef` for delta time calculations\n\n2. **Control functions**:\n   - `run()`: Start execution, set startTimeRef to performance.now(), set status to 'running', call tick()\n   - `pause()`: Cancel rAF, save elapsed time to pausedTimeRef, set status to 'paused'\n   - `resume()`: Adjust startTimeRef for paused duration, restart tick loop\n   - `stop()`: Cancel rAF, reset all refs, set status to 'stopped'\n   - `reset()`: Stop and clear execution state, reset currentTime to 0\n\n3. **Tick function**:\n   - Calculate elapsed = (performance.now() - startTimeRef.current) / 1000 + pausedTime\n   - Update executionState.currentTime\n   - Schedule next tick with requestAnimationFrame(tick)\n\n4. **Cleanup on unmount**:\n   - Cancel any pending animation frames in useEffect cleanup",
            "status": "pending",
            "testStrategy": "Unit tests: Verify run() starts timing loop and updates currentTime. Test pause() freezes elapsed time accurately. Test resume() continues from paused position. Test stop()/reset() properly clean up. Use jest.useFakeTimers() and mock performance.now() to control time progression.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement event scheduling logic based on elapsed time",
            "description": "Create the event scheduling system that determines which scenario events should execute based on the current elapsed time, handling edge cases like simultaneous events and missed events.",
            "dependencies": [
              1
            ],
            "details": "Add to useScenarioExecution hook:\n\n1. **Track executed events**:\n   - `executedEventsRef = useRef<Set<string>>()` to track which event IDs have fired\n   - Reset this set on stop/reset\n\n2. **Event finding logic in tick()**:\n   ```typescript\n   const pendingEvents = scenario.events.filter(event => \n     event.time <= currentTime && \n     !executedEventsRef.current.has(event.id)\n   );\n   // Sort by time to execute in order\n   pendingEvents.sort((a, b) => a.time - b.time);\n   ```\n\n3. **Handle edge cases**:\n   - Events at exactly the same time: execute in array order (stable sort)\n   - Events missed during pause: execute all pending when resumed\n   - Large time jumps (e.g., tab unfocused): batch execute all events up to current time\n\n4. **Track last executed event**:\n   - Store lastExecutedEventIndex to know when scenario is complete\n   - Compare against total event count for loop logic",
            "status": "pending",
            "testStrategy": "Test events fire at correct times (event at 1.5s fires after 1.5s elapsed). Test multiple events at same timestamp execute in order. Test pausing at 1.0s and resuming doesn't re-fire events before 1.0s. Test rapid time jumps execute all pending events.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Modbus write integration using modbusService",
            "description": "Integrate with the existing modbusService to execute actual Modbus writes (coils and holding registers) when events are triggered.",
            "dependencies": [
              2
            ],
            "details": "Add Modbus execution logic:\n\n1. **Import required services**:\n   - Import modbusService from existing `@/services/modbusService`\n   - Import addressParser from `@/utils/addressParser`\n\n2. **Execute event function**:\n   ```typescript\n   async function executeEvent(event: ScenarioEvent) {\n     const parsed = addressParser.parse(event.address);\n     if (!parsed) {\n       console.error(`Invalid address: ${event.address}`);\n       return;\n     }\n     \n     if (parsed.type === 'coil') {\n       await invoke('modbus_write_coil', {\n         address: parsed.address,\n         value: event.value !== 0\n       });\n     } else if (parsed.type === 'holding') {\n       await invoke('modbus_write_holding_register', {\n         address: parsed.address,\n         value: event.value\n       });\n     }\n   }\n   ```\n\n3. **Error handling**:\n   - Wrap in try/catch\n   - Log errors but don't stop execution\n   - Optionally emit error event for UI\n\n4. **Process pending events**:\n   - Loop through pendingEvents from subtask 2\n   - Call executeEvent for each\n   - Mark as executed in executedEventsRef",
            "status": "pending",
            "testStrategy": "Integration test with mocked invoke(). Verify coil addresses call modbus_write_coil with boolean value. Verify holding register addresses call modbus_write_holding_register with u16 value. Test error handling doesn't crash execution loop. Test invalid addresses are logged but skipped.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement persist=false auto-release logic with setTimeout",
            "description": "Add automatic value reset functionality for events with persist=false, scheduling timeouts to write the release value after persistDuration.",
            "dependencies": [
              3
            ],
            "details": "Add auto-release scheduling:\n\n1. **Track scheduled releases**:\n   ```typescript\n   const scheduledReleasesRef = useRef<Map<string, NodeJS.Timeout>>(new Map());\n   ```\n\n2. **Schedule release after event execution**:\n   ```typescript\n   if (!event.persist && event.persistDuration > 0) {\n     const releaseTimeout = setTimeout(async () => {\n       const releaseValue = event.releaseValue ?? 0;\n       // Use same Modbus write logic with releaseValue\n       await executeModbusWrite(event.address, releaseValue);\n       scheduledReleasesRef.current.delete(event.id);\n     }, event.persistDuration * 1000);\n     \n     scheduledReleasesRef.current.set(event.id, releaseTimeout);\n   }\n   ```\n\n3. **Handle pause/stop cleanup**:\n   - On pause: Store remaining time for each scheduled release\n   - On stop/reset: Clear all scheduled timeouts\n   - On resume: Reschedule releases with remaining time\n\n4. **Cleanup on unmount**:\n   - Clear all scheduled timeouts in useEffect cleanup\n\n5. **Handle re-trigger before release**:\n   - If same address triggered again, cancel previous release timeout",
            "status": "pending",
            "testStrategy": "Test event with persist=false schedules release after persistDuration. Test release writes correct releaseValue. Test stop/reset clears all pending releases. Test pause preserves and resume restores release timers. Test re-triggering same address cancels previous release.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement loop handling with iteration counting and delay",
            "description": "Add loop functionality that repeats the scenario after completion, respecting loopCount limits, loopDelay between iterations, and proper iteration tracking.",
            "dependencies": [
              2
            ],
            "details": "Add loop logic to execution:\n\n1. **Track iteration state**:\n   ```typescript\n   const iterationRef = useRef(0);\n   // Reset to 0 on stop/reset\n   ```\n\n2. **Detect scenario completion**:\n   ```typescript\n   const allEventsExecuted = executedEventsRef.current.size === scenario.events.length;\n   const lastEventTime = Math.max(...scenario.events.map(e => e.time));\n   const scenarioComplete = currentTime > lastEventTime && allEventsExecuted;\n   ```\n\n3. **Handle loop on completion**:\n   ```typescript\n   if (scenarioComplete && scenario.settings.loop) {\n     const { loopCount, loopDelay } = scenario.settings;\n     \n     if (loopCount === 0 || iterationRef.current < loopCount - 1) {\n       // Schedule next iteration after loopDelay\n       setTimeout(() => {\n         iterationRef.current++;\n         executedEventsRef.current.clear();\n         startTimeRef.current = performance.now();\n         pausedTimeRef.current = 0;\n         setExecutionState(prev => ({ ...prev, iteration: iterationRef.current }));\n       }, loopDelay * 1000);\n     } else {\n       // Reached loop count limit, stop execution\n       stop();\n     }\n   }\n   ```\n\n4. **Update execution state with iteration**:\n   - Include current iteration in executionState for UI display",
            "status": "pending",
            "testStrategy": "Test loopCount=0 loops infinitely. Test loopCount=3 runs exactly 3 times then stops. Test loopDelay waits correct time between iterations. Test iteration counter increments correctly. Test executedEvents reset between loops. Test stop during delay cancels next iteration.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Add event emission for UI updates",
            "description": "Implement custom event emission system to notify the UI about execution progress, including event executions and status changes.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add event emission system:\n\n1. **Define event types**:\n   ```typescript\n   type ScenarioEventEmitted = {\n     type: 'scenario:event-executed';\n     payload: { eventId: string; address: string; value: number; time: number };\n   } | {\n     type: 'scenario:status-changed';\n     payload: { status: ExecutionStatus; currentTime: number; iteration?: number };\n   };\n   ```\n\n2. **Create event emitter**:\n   - Use custom EventTarget or existing event system\n   - Or use Zustand subscription for reactive updates\n\n3. **Emit on event execution**:\n   ```typescript\n   // After successful Modbus write\n   emitEvent('scenario:event-executed', {\n     eventId: event.id,\n     address: event.address,\n     value: event.value,\n     time: currentTime\n   });\n   ```\n\n4. **Emit on status change**:\n   - On run/pause/stop/reset\n   - On iteration change\n   - On currentTime updates (throttled to ~10fps for UI)\n\n5. **Return subscription method**:\n   ```typescript\n   return {\n     run, pause, stop, reset,\n     subscribe: (callback: (event: ScenarioEventEmitted) => void) => void,\n     executionState\n   };\n   ```",
            "status": "pending",
            "testStrategy": "Test scenario:event-executed emits with correct payload on each event. Test scenario:status-changed emits on run/pause/stop/reset. Test currentTime updates are throttled to prevent excessive emissions. Test subscription cleanup on unmount. Test multiple subscribers receive events.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down into: 1) Create useScenarioExecution hook with requestAnimationFrame-based timing loop. 2) Implement event scheduling logic that finds events to execute based on elapsed time. 3) Implement Modbus write integration using existing modbusService for coils and registers. 4) Implement persist=false auto-release logic with setTimeout scheduling. 5) Implement loop handling with iteration counting, delay, and reset. 6) Add event emission for UI updates (scenario:event-executed, scenario:status-changed).",
        "updatedAt": "2026-01-28T17:43:07.884Z"
      },
      {
        "id": "58",
        "title": "Create ExecutionProgress Component",
        "description": "Build the progress bar component showing scenario execution progress.",
        "details": "Create `src/components/ScenarioEditor/ExecutionProgress.tsx`:\n\n**Layout** (matching PRD):\n```\nProgress: ████████░░░░░░░░░░░░  25% (2/8 events)\n```\n\n**Implementation**:\n```typescript\nexport function ExecutionProgress() {\n  const { scenario, executionState } = useScenarioStore();\n  \n  const enabledEvents = scenario?.events.filter(e => e.enabled) || [];\n  const completedCount = executionState.completedEvents.length;\n  const totalCount = enabledEvents.length;\n  const percentage = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;\n  \n  return (\n    <div className=\"flex items-center gap-2 px-2 py-1 border-t border-gray-700\">\n      <span className=\"text-xs text-gray-400\">Progress:</span>\n      <div className=\"flex-1 h-2 bg-gray-700 rounded overflow-hidden\">\n        <div \n          className=\"h-full bg-blue-500 transition-all duration-200\"\n          style={{ width: `${percentage}%` }}\n        />\n      </div>\n      <span className=\"text-xs text-gray-400 w-24 text-right\">\n        {percentage.toFixed(0)}% ({completedCount}/{totalCount})\n      </span>\n    </div>\n  );\n}\n```\n\n**Additional features**:\n- Show loop iteration when looping: `Loop 2/5`\n- Color changes: green when complete, yellow during execution\n- Optional: show estimated time remaining",
        "testStrategy": "Component tests verifying progress calculation, percentage formatting, and visual updates during execution state changes.",
        "priority": "medium",
        "dependencies": [
          "51",
          "57"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ExecutionProgress component with store integration",
            "description": "Set up the ExecutionProgress.tsx file with proper imports and Zustand store connection to access scenario and executionState data.",
            "dependencies": [],
            "details": "Create `src/components/ScenarioEditor/ExecutionProgress.tsx`. Import useScenarioStore hook to access scenario and executionState. Define the component signature and extract required state: scenario (for events list), executionState (for completedEvents array and current execution status). Set up the basic component structure with TypeScript types.",
            "status": "pending",
            "testStrategy": "Verify component renders without errors and correctly subscribes to the scenarioStore.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement progress calculation logic",
            "description": "Calculate enabled events count, completed events count, total count, and percentage values for the progress display.",
            "dependencies": [
              1
            ],
            "details": "Filter scenario.events to get only enabled events (events.filter(e => e.enabled)). Get completedCount from executionState.completedEvents.length. Calculate totalCount from enabledEvents.length. Compute percentage with zero-division protection: totalCount > 0 ? (completedCount / totalCount) * 100 : 0. Handle edge cases when scenario is null.",
            "status": "pending",
            "testStrategy": "Unit test progress calculation with various scenarios: empty events, all enabled, some disabled, 0% complete, 50% complete, 100% complete.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build progress bar UI with Tailwind styling",
            "description": "Create the visual progress bar component with proper layout matching the PRD mockup: label, bar container, filled portion, and percentage text.",
            "dependencies": [
              1
            ],
            "details": "Implement the layout structure: flex container with items-center and gap-2. Add 'Progress:' label with text-xs text-gray-400. Create bar container with flex-1 h-2 bg-gray-700 rounded overflow-hidden. Add inner div for filled portion with h-full and transition-all duration-200 for smooth animation. Use inline style width: `${percentage}%`. Add right-aligned text showing percentage and counts: `{percentage.toFixed(0)}% ({completedCount}/{totalCount})`.",
            "status": "pending",
            "testStrategy": "Visual test that progress bar width matches percentage value. Test transition animation works smoothly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add execution state color changes",
            "description": "Implement dynamic color changes for the progress bar based on execution state: blue during execution, green when complete, yellow for pause/warning states.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add conditional class names based on executionState.status: 'bg-blue-500' for 'running' (default), 'bg-green-500' when percentage === 100 and status is 'completed', 'bg-yellow-500' for 'paused' state. Use template literals or cn() utility for combining classes. Consider adding subtle animation (pulse) for running state to indicate activity.",
            "status": "pending",
            "testStrategy": "Test color changes correctly when switching between running, paused, and completed states. Visual regression test for all color variants.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement loop iteration display",
            "description": "Add optional loop iteration indicator showing current loop number when scenario is configured for looping execution.",
            "dependencies": [
              2,
              4
            ],
            "details": "Check if scenario.settings.loop is true. If looping, display loop progress: 'Loop {currentLoop}/{totalLoops}' or 'Loop {currentLoop}/∞' for infinite loops. Get currentLoop from executionState.currentIteration and totalLoops from scenario.settings.loopCount (0 = infinite). Position the loop indicator after the percentage text with appropriate spacing. Only render loop indicator when loop mode is active.",
            "status": "pending",
            "testStrategy": "Test loop indicator appears only when loop is enabled. Test correct display for finite loops (e.g., 'Loop 2/5') and infinite loops (e.g., 'Loop 3/∞').",
            "parentId": "undefined"
          }
        ],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": "This task is simple enough to implement without subtasks. Create a progress bar component that reads from scenarioStore to display percentage completion, event counts, and optional loop iteration indicator with appropriate color changes based on execution state.",
        "updatedAt": "2026-01-28T17:51:14.194Z"
      },
      {
        "id": "59",
        "title": "Assemble ScenarioEditor Main Component",
        "description": "Create the main ScenarioEditor component that combines all sub-components and integrates with the panel system.",
        "details": "Update `src/components/panels/content/ScenarioEditorPanel.tsx`:\n\n```typescript\nimport { ScenarioToolbar } from '../../ScenarioEditor/ScenarioToolbar';\nimport { ScenarioGrid } from '../../ScenarioEditor/ScenarioGrid';\nimport { ExecutionProgress } from '../../ScenarioEditor/ExecutionProgress';\nimport { useScenarioExecution } from '../../ScenarioEditor/hooks/useScenarioExecution';\n\nexport function ScenarioEditorPanel() {\n  const execution = useScenarioExecution();\n  \n  return (\n    <div className=\"h-full flex flex-col bg-gray-900\">\n      <ScenarioToolbar \n        onRun={execution.run}\n        onPause={execution.pause}\n        onStop={execution.stop}\n      />\n      <div className=\"flex-1 overflow-auto\">\n        <ScenarioGrid />\n      </div>\n      <ExecutionProgress />\n    </div>\n  );\n}\n```\n\n**Create directory structure**:\n```\nsrc/components/ScenarioEditor/\n├── ScenarioEditor.tsx\n├── ScenarioToolbar.tsx\n├── ScenarioGrid.tsx\n├── ScenarioRow.tsx\n├── ExecutionProgress.tsx\n├── SettingsDialog.tsx\n├── cells/\n│   ├── TimeCell.tsx\n│   ├── AddressCell.tsx\n│   ├── ValueCell.tsx\n│   ├── PersistCell.tsx\n│   ├── DurationCell.tsx\n│   └── NoteCell.tsx\n├── hooks/\n│   ├── useScenarioExecution.ts\n│   └── useScenarioEvents.ts\n├── utils/\n│   ├── csvParser.ts\n│   ├── addressParser.ts\n│   └── timeUtils.ts\n├── types.ts\n└── index.ts\n```\n\nExport from index.ts for clean imports.",
        "testStrategy": "Integration tests verifying the complete editor renders, toolbar actions work, and execution updates the grid. E2E tests for full user workflows.",
        "priority": "high",
        "dependencies": [
          "52",
          "53",
          "54",
          "57",
          "58"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ScenarioEditor directory structure and barrel exports",
            "description": "Set up the complete directory structure for ScenarioEditor components and create index.ts with proper exports for clean imports throughout the application.",
            "dependencies": [],
            "details": "Create the directory structure:\n```\nsrc/components/ScenarioEditor/\n├── index.ts\n├── types.ts (re-export from existing if present)\n├── cells/\n│   └── index.ts\n├── hooks/\n│   └── index.ts\n└── utils/\n    └── index.ts\n```\n\nImplement `src/components/ScenarioEditor/index.ts`:\n```typescript\n// Main components\nexport { ScenarioToolbar } from './ScenarioToolbar';\nexport { ScenarioGrid } from './ScenarioGrid';\nexport { ScenarioRow } from './ScenarioRow';\nexport { ExecutionProgress } from './ExecutionProgress';\nexport { SettingsDialog } from './SettingsDialog';\n\n// Cells\nexport * from './cells';\n\n// Hooks\nexport { useScenarioExecution } from './hooks/useScenarioExecution';\nexport { useScenarioEvents } from './hooks/useScenarioEvents';\n\n// Utils\nexport * from './utils';\n\n// Types\nexport * from './types';\n```\n\nCreate barrel exports for subdirectories (cells/index.ts, hooks/index.ts, utils/index.ts) that export all their respective modules. Ensure all existing components from dependent tasks (52, 53, 54, 57, 58) are properly re-exported.",
            "status": "pending",
            "testStrategy": "Verify all exports are accessible via import from '@/components/ScenarioEditor'. Test that TypeScript compilation succeeds with no circular dependency warnings. Validate tree-shaking works correctly by checking bundle size.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Assemble ScenarioEditorPanel layout with toolbar, grid, and progress",
            "description": "Create the main ScenarioEditorPanel component that arranges ScenarioToolbar at top, ScenarioGrid in scrollable center area, and ExecutionProgress at bottom.",
            "dependencies": [
              1
            ],
            "details": "Update `src/components/panels/content/ScenarioEditorPanel.tsx`:\n```typescript\nimport { ScenarioToolbar, ScenarioGrid, ExecutionProgress } from '../../ScenarioEditor';\n\nexport function ScenarioEditorPanel() {\n  return (\n    <div className=\"h-full flex flex-col bg-gray-900\">\n      {/* Fixed toolbar at top */}\n      <ScenarioToolbar />\n      \n      {/* Scrollable grid area taking remaining space */}\n      <div className=\"flex-1 overflow-auto min-h-0\">\n        <ScenarioGrid />\n      </div>\n      \n      {/* Fixed progress bar at bottom */}\n      <ExecutionProgress />\n    </div>\n  );\n}\n```\n\nEnsure the layout:\n- Uses flexbox for proper height distribution\n- Toolbar stays fixed at top regardless of scroll\n- Grid area scrolls independently with min-h-0 for flex overflow\n- Progress bar stays fixed at bottom\n- Applies consistent dark theme (bg-gray-900)",
            "status": "pending",
            "testStrategy": "Visual testing: Verify toolbar remains visible when scrolling grid. Test that grid scrolls when content exceeds viewport. Confirm progress bar stays at bottom. Test responsive behavior at various panel sizes.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Wire useScenarioExecution hook to toolbar control handlers",
            "description": "Integrate the useScenarioExecution hook into ScenarioEditorPanel and connect its run/pause/stop/step methods to ScenarioToolbar action handlers.",
            "dependencies": [
              2
            ],
            "details": "Update ScenarioEditorPanel to use execution hook:\n```typescript\nimport { useScenarioExecution } from '../../ScenarioEditor';\n\nexport function ScenarioEditorPanel() {\n  const execution = useScenarioExecution();\n  \n  return (\n    <div className=\"h-full flex flex-col bg-gray-900\">\n      <ScenarioToolbar\n        onRun={execution.run}\n        onPause={execution.pause}\n        onStop={execution.stop}\n        onStep={execution.step}\n        isRunning={execution.isRunning}\n        isPaused={execution.isPaused}\n        canRun={execution.canRun}\n      />\n      <div className=\"flex-1 overflow-auto min-h-0\">\n        <ScenarioGrid \n          currentEventIndex={execution.currentEventIndex}\n          highlightActive={execution.isRunning}\n        />\n      </div>\n      <ExecutionProgress\n        progress={execution.progress}\n        currentTime={execution.currentTime}\n        totalTime={execution.totalTime}\n        status={execution.status}\n      />\n    </div>\n  );\n}\n```\n\nEnsure ScenarioToolbar receives all necessary state for button enable/disable logic. Pass execution state to ExecutionProgress for progress visualization. Optionally pass currentEventIndex to ScenarioGrid for row highlighting during execution.",
            "status": "pending",
            "testStrategy": "Unit test: Mock useScenarioExecution and verify toolbar receives correct handlers. Integration test: Click Run button and verify execution.run() is called. Test pause/stop handlers similarly. Verify button states update based on isRunning/isPaused.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement component coordination and data flow verification",
            "description": "Ensure proper data flow between ScenarioGrid, scenarioStore, and execution engine with event synchronization and state consistency.",
            "dependencies": [
              3
            ],
            "details": "Verify and implement complete data flow coordination:\n\n1. **Grid-to-Store sync**: ScenarioGrid cell edits should update scenarioStore via actions\n2. **Store-to-Execution sync**: useScenarioExecution reads events from scenarioStore\n3. **Execution-to-Grid feedback**: Current executing row highlighted in grid\n4. **Progress updates**: ExecutionProgress receives real-time updates during execution\n\nAdd coordination in ScenarioEditorPanel:\n```typescript\nimport { useScenarioStore } from '@/stores/scenarioStore';\n\nexport function ScenarioEditorPanel() {\n  const events = useScenarioStore(state => state.events);\n  const execution = useScenarioExecution();\n  \n  // Validate events before allowing run\n  const hasValidEvents = events.length > 0 && events.every(e => e.isValid);\n  \n  return (\n    // ... pass hasValidEvents to toolbar for Run button state\n  );\n}\n```\n\nImplement useScenarioEvents hook integration if needed for real-time event updates during execution. Add error boundary around ScenarioGrid for graceful error handling. Ensure keyboard shortcuts (Ctrl+R for run, Escape for stop) work at panel level.",
            "status": "pending",
            "testStrategy": "Integration test: Edit a cell in grid, verify store updates, run scenario, verify execution uses updated value. E2E test: Complete workflow - add events, run scenario, verify progress updates and row highlighting. Test error states: invalid events prevent run, execution errors show gracefully.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create directory structure and index.ts exports for all ScenarioEditor components. 2) Assemble ScenarioEditorPanel component with toolbar, grid, and progress bar layout. 3) Wire up useScenarioExecution hook and connect run/pause/stop handlers to toolbar. 4) Implement component coordination ensuring proper data flow between grid, store, and execution engine.",
        "updatedAt": "2026-01-28T17:52:55.242Z"
      },
      {
        "id": "60",
        "title": "Implement File Operations and Dialog Integration",
        "description": "Connect file operations (New, Open, Save, Import/Export CSV) with Tauri dialogs and backend commands.",
        "details": "Create `src/components/ScenarioEditor/hooks/useScenarioFileOps.ts`:\n\n```typescript\nimport { open, save } from '@tauri-apps/plugin-dialog';\nimport { invoke } from '@tauri-apps/api/core';\n\nexport function useScenarioFileOps() {\n  const { scenario, loadScenario, newScenario } = useScenarioStore();\n  \n  const openScenario = async () => {\n    const path = await open({\n      filters: [{ name: 'Scenario', extensions: ['json'] }],\n    });\n    if (path) {\n      const data = await invoke<Scenario>('scenario_load', { path });\n      loadScenario(data, path);\n    }\n  };\n  \n  const saveScenario = async () => { /* ... */ };\n  const saveScenarioAs = async () => { /* ... */ };\n  \n  const importCsv = async () => {\n    const path = await open({\n      filters: [{ name: 'CSV', extensions: ['csv'] }],\n    });\n    if (path) {\n      const events = await invoke<ScenarioEvent[]>('scenario_import_csv', { path });\n      // Merge or replace events based on user choice\n    }\n  };\n  \n  const exportCsv = async () => { /* ... */ };\n  \n  return { openScenario, saveScenario, saveScenarioAs, importCsv, exportCsv };\n}\n```\n\n**Handle unsaved changes**:\n- Track `isDirty` state in store\n- Prompt before discarding (New, Open when dirty)\n- Use existing UnsavedChangesDialog pattern from project components",
        "testStrategy": "Integration tests mocking Tauri dialog and invoke functions. Test dirty state tracking and unsaved changes prompt.",
        "priority": "medium",
        "dependencies": [
          "51",
          "55",
          "56",
          "59"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create useScenarioFileOps hook with Open, Save, and SaveAs functions",
            "description": "Implement the core file operations hook using @tauri-apps/plugin-dialog for native file dialogs and Tauri invoke for backend commands.",
            "dependencies": [],
            "details": "Create `src/components/ScenarioEditor/hooks/useScenarioFileOps.ts` following the existing pattern from `useOpenProjectDialog.ts` and `useProject.ts`. Implement:\n\n1. **openScenario()**: Use `open()` from @tauri-apps/plugin-dialog with filters for `.json` files, then invoke `scenario_load` Tauri command to load the data. Update the scenario store with loaded data and file path.\n\n2. **saveScenario()**: Check if current file path exists. If yes, invoke `scenario_save` command with current path. If no path, delegate to saveScenarioAs(). Update store's modified state to false on success.\n\n3. **saveScenarioAs()**: Use `save()` dialog from @tauri-apps/plugin-dialog with `.json` filter. Invoke `scenario_save` command with selected path. Update store with new path and reset modified state.\n\n4. **newScenario()**: Reset scenario store to default empty state, clear current file path.\n\nExport hook returning `{ openScenario, saveScenario, saveScenarioAs, newScenario, isLoading, error }`. Handle loading states and errors similar to useProject hook pattern.",
            "status": "pending",
            "testStrategy": "Unit tests mocking @tauri-apps/plugin-dialog open/save functions and Tauri invoke commands. Test: open returns null (cancelled), open returns path (loads data), save with existing path (saves directly), save without path (calls saveAs), saveAs user cancels, error handling for failed loads/saves.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement CSV Import/Export functions with merge/replace option",
            "description": "Add CSV import and export functionality to the useScenarioFileOps hook with a user choice dialog for import mode (merge or replace existing events).",
            "dependencies": [
              1
            ],
            "details": "Extend `useScenarioFileOps.ts` with CSV import/export functions:\n\n1. **importCsv()**: \n   - Use `open()` dialog with CSV file filter\n   - Invoke `scenario_import_csv` Tauri command to parse CSV\n   - Show a simple choice dialog (can use browser confirm or create CsvImportModeDialog component) asking user to 'Merge with existing events' or 'Replace all events'\n   - If merge: append imported events to existing, re-sort by time\n   - If replace: replace all events with imported ones\n   - Mark scenario as dirty\n\n2. **exportCsv()**: \n   - Use `save()` dialog with `.csv` filter\n   - Invoke `scenario_export_csv` Tauri command with current events and selected path\n   - Handle success/error feedback\n\n3. **CsvImportModeDialog (optional)**: Create a simple modal component similar to UnsavedChangesDialog with two buttons: 'Merge' and 'Replace'. Can be a simple useState-controlled dialog within the hook or a separate component.",
            "status": "pending",
            "testStrategy": "Unit tests for importCsv with mocked dialogs testing both merge and replace modes. Verify events are correctly merged (sorted by time) or replaced. Test exportCsv with various event data. Test dialog cancellation handling.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement dirty state tracking and unsaved changes prompt",
            "description": "Add isDirty state tracking to scenario store and integrate UnsavedChangesDialog for prompting before discarding changes on New or Open operations.",
            "dependencies": [
              1
            ],
            "details": "Implement dirty state tracking following the project's existing pattern:\n\n1. **Scenario Store Updates** (if not already present):\n   - Add `isDirty: boolean` state to scenario store\n   - Add `setDirty(dirty: boolean)` action\n   - Ensure all event mutations (add, edit, delete, import) call `setDirty(true)`\n   - Reset `isDirty` to false on successful save\n\n2. **Unsaved Changes Handling in useScenarioFileOps**:\n   - Add `showUnsavedDialog` and `pendingAction` state to track deferred operations\n   - Modify `newScenario()` and `openScenario()` to check `isDirty` before proceeding\n   - If dirty, show UnsavedChangesDialog (reuse from `src/components/project/UnsavedChangesDialog.tsx`)\n   - Dialog callbacks: onSave → save then proceed, onDontSave → proceed without saving, onCancel → abort operation\n   - Export `{ showUnsavedDialog, unsavedDialogProps }` for parent component to render dialog\n\n3. **Integration Pattern**: Return `{ ...fileOps, isDirty, unsavedDialog: { isOpen, onSave, onDontSave, onCancel } }` so parent can render `<UnsavedChangesDialog {...unsavedDialog} />`",
            "status": "pending",
            "testStrategy": "Test dirty state: initial false, becomes true on event mutation, becomes false on save. Test unsaved prompt: appears when dirty and calling new/open, Save option saves then proceeds, Don't Save discards and proceeds, Cancel aborts. Test clean state allows new/open without prompt.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate file operations with toolbar dropdown menu handlers",
            "description": "Connect the useScenarioFileOps hook functions to the ScenarioEditor toolbar's File dropdown menu items (New, Open, Save, Save As, Import CSV, Export CSV).",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Integrate file operations with the toolbar UI:\n\n1. **Toolbar Integration**:\n   - In ScenarioEditor main component (or toolbar component), call `useScenarioFileOps()` hook\n   - Map dropdown menu items to hook functions:\n     - 'New' → `newScenario()`\n     - 'Open...' → `openScenario()`\n     - 'Save' → `saveScenario()`\n     - 'Save As...' → `saveScenarioAs()`\n     - 'Import CSV...' → `importCsv()`\n     - 'Export CSV...' → `exportCsv()`\n\n2. **UnsavedChangesDialog Rendering**:\n   - Render `<UnsavedChangesDialog {...unsavedDialog} />` in the component tree\n   - Render any CSV import mode dialog if implemented as component\n\n3. **UI Feedback**:\n   - Disable menu items during loading operations\n   - Show loading indicator when `isLoading` is true\n   - Display error toast/notification on operation failure\n   - Update window title or header to show dirty indicator (*) when `isDirty`\n\n4. **Keyboard Shortcuts** (bonus): Consider adding Ctrl+S for save, Ctrl+O for open, Ctrl+N for new using existing useKeyboardShortcuts pattern.",
            "status": "pending",
            "testStrategy": "Integration tests: click each menu item and verify corresponding function is called. Test loading states disable menu items. Test dirty indicator appears in UI. Test UnsavedChangesDialog renders when triggered. Test keyboard shortcuts if implemented.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Create useScenarioFileOps hook with open, save, saveAs functions using @tauri-apps/plugin-dialog. 2) Implement CSV import/export functions with merge/replace option for import. 3) Implement dirty state tracking and unsaved changes prompt using existing UnsavedChangesDialog pattern. 4) Integrate file operations with toolbar dropdown menu handlers.",
        "updatedAt": "2026-01-28T17:54:48.346Z"
      },
      {
        "id": "61",
        "title": "Define OneParser TypeScript and Rust Type Definitions",
        "description": "Create comprehensive type definitions for the OneParser module including device types, instruction types, AST structures, and Modbus address mapping interfaces.",
        "details": "Create TypeScript types in `src/components/OneParser/types.ts`:\n\n```typescript\n// ============================================================================\n// Device Types\n// ============================================================================\n\n/** LS PLC Bit Device Types */\nexport type BitDeviceType = 'P' | 'M' | 'K' | 'F' | 'T' | 'C';\n\n/** LS PLC Word Device Types */\nexport type WordDeviceType = 'D' | 'R' | 'Z' | 'N';\n\n/** All device types */\nexport type DeviceType = BitDeviceType | WordDeviceType;\n\n/** Device address with optional bit index */\nexport interface DeviceAddress {\n  device: DeviceType;\n  address: number;\n  bitIndex?: number;  // For bit access on word devices (e.g., D0000.0)\n  indexRegister?: number;  // For indexed addressing (e.g., D[Z0])\n}\n\n// ============================================================================\n// Instruction Types\n// ============================================================================\n\n/** Contact instruction types */\nexport type ContactInstructionType = \n  | 'LOAD' | 'LOADN' | 'LOADP' | 'LOADF'\n  | 'AND' | 'ANDN' | 'ANDP' | 'ANDF'\n  | 'OR' | 'ORN' | 'ORP' | 'ORF';\n\n/** Block instruction types */\nexport type BlockInstructionType = 'ANDB' | 'ORB';\n\n/** Output instruction types */\nexport type OutputInstructionType = 'OUT' | 'OUTN' | 'SET' | 'RST';\n\n/** Timer instruction types */\nexport type TimerInstructionType = 'TON' | 'TOF' | 'TMR';\n\n/** Counter instruction types */\nexport type CounterInstructionType = 'CTU' | 'CTD' | 'CTUD';\n\n/** Comparison instruction types */\nexport type ComparisonInstructionType = 'LD=' | 'LD>' | 'LD<' | 'LD>=' | 'LD<=' | 'LD<>';\n\n/** Math instruction types */\nexport type MathInstructionType = 'ADD' | 'SUB' | 'MUL' | 'DIV' | 'MOV';\n\n/** All instruction types */\nexport type InstructionType = \n  | ContactInstructionType | BlockInstructionType | OutputInstructionType\n  | TimerInstructionType | CounterInstructionType\n  | ComparisonInstructionType | MathInstructionType;\n\n// ============================================================================\n// CSV Row Types\n// ============================================================================\n\n/** Raw CSV row from XG5000 export */\nexport interface CsvRow {\n  no: number;\n  step: number;  // Network/Rung number\n  instruction: string;\n  operand1?: string;\n  operand2?: string;\n  operand3?: string;\n  comment?: string;\n}\n\n// ============================================================================\n// AST Node Types\n// ============================================================================\n\n/** Ladder node types */\nexport type LadderNodeType =\n  | 'contact_no' | 'contact_nc' | 'contact_p' | 'contact_n'\n  | 'coil_out' | 'coil_set' | 'coil_rst'\n  | 'timer_ton' | 'timer_tof' | 'timer_tmr'\n  | 'counter_ctu' | 'counter_ctd' | 'counter_ctud'\n  | 'comparison' | 'math' | 'move'\n  | 'block_series' | 'block_parallel';\n\n/** Grid position for visualization */\nexport interface GridPosition {\n  row: number;\n  col: number;\n}\n\n/** Base ladder node */\nexport interface BaseLadderNode {\n  id: string;\n  type: LadderNodeType;\n  address?: DeviceAddress;\n  comment?: string;\n  gridPosition: GridPosition;\n}\n\n/** Contact node */\nexport interface ContactNode extends BaseLadderNode {\n  type: 'contact_no' | 'contact_nc' | 'contact_p' | 'contact_n';\n  address: DeviceAddress;\n}\n\n/** Coil node */\nexport interface CoilNode extends BaseLadderNode {\n  type: 'coil_out' | 'coil_set' | 'coil_rst';\n  address: DeviceAddress;\n}\n\n/** Timer node */\nexport interface TimerNode extends BaseLadderNode {\n  type: 'timer_ton' | 'timer_tof' | 'timer_tmr';\n  address: DeviceAddress;\n  preset: number;  // Timer preset value\n  timeBase: 'ms' | 's';  // Time base (milliseconds or seconds)\n}\n\n/** Counter node */\nexport interface CounterNode extends BaseLadderNode {\n  type: 'counter_ctu' | 'counter_ctd' | 'counter_ctud';\n  address: DeviceAddress;\n  preset: number;  // Counter preset value\n}\n\n/** Comparison node */\nexport interface ComparisonNode extends BaseLadderNode {\n  type: 'comparison';\n  operator: '=' | '>' | '<' | '>=' | '<=' | '<>';\n  operand1: DeviceAddress | number;\n  operand2: DeviceAddress | number;\n}\n\n/** Math node */\nexport interface MathNode extends BaseLadderNode {\n  type: 'math' | 'move';\n  operator: 'ADD' | 'SUB' | 'MUL' | 'DIV' | 'MOV';\n  operand1: DeviceAddress | number;\n  operand2?: DeviceAddress | number;\n  destination: DeviceAddress;\n}\n\n/** Block node (series/parallel connection) */\nexport interface BlockNode extends BaseLadderNode {\n  type: 'block_series' | 'block_parallel';\n  children: LadderNode[];\n}\n\n/** Union type for all ladder nodes */\nexport type LadderNode =\n  | ContactNode | CoilNode | TimerNode | CounterNode\n  | ComparisonNode | MathNode | BlockNode;\n\n// ============================================================================\n// Program Structure\n// ============================================================================\n\n/** Ladder network (single rung) */\nexport interface LadderNetwork {\n  id: string;\n  step: number;  // Rung number\n  nodes: LadderNode[];\n  comment?: string;\n}\n\n/** Symbol table entry */\nexport interface SymbolEntry {\n  address: DeviceAddress;\n  symbol?: string;\n  comment?: string;\n  dataType?: 'BOOL' | 'INT' | 'WORD' | 'DWORD' | 'REAL';\n}\n\n/** Symbol table */\nexport interface SymbolTable {\n  entries: Map<string, SymbolEntry>;  // Key: stringified address\n}\n\n/** Program metadata */\nexport interface ProgramMetadata {\n  name: string;\n  description?: string;\n  author?: string;\n  createdAt?: string;\n  modifiedAt?: string;\n  version?: string;\n  plcModel?: string;\n}\n\n/** Complete ladder program */\nexport interface LadderProgram {\n  metadata: ProgramMetadata;\n  networks: LadderNetwork[];\n  symbolTable: SymbolTable;\n}\n\n// ============================================================================\n// Modbus Mapping Types\n// ============================================================================\n\n/** Modbus address type */\nexport type ModbusAddressType = 'coil' | 'discrete' | 'holding' | 'input';\n\n/** Modbus address */\nexport interface ModbusAddress {\n  type: ModbusAddressType;\n  address: number;\n}\n\n/** Device to Modbus mapping rule */\nexport interface MappingRule {\n  device: DeviceType;\n  modbusType: ModbusAddressType;\n  offset: number;\n}\n```\n\nCreate corresponding Rust types in `src-tauri/src/parser/types.rs` with serde serialization.",
        "testStrategy": "1. Verify all TypeScript types compile without errors using `tsc --noEmit`\n2. Create unit tests for type guards (e.g., isContactNode, isCoilNode)\n3. Test JSON serialization/deserialization of LadderProgram\n4. Verify Rust types match TypeScript types for Tauri command interop",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TypeScript Device and Instruction Type Definitions",
            "description": "Create the device types (BitDeviceType, WordDeviceType), device address interfaces, and all instruction type definitions (Contact, Block, Output, Timer, Counter, Comparison, Math) in src/components/OneParser/types.ts.",
            "dependencies": [],
            "details": "Create src/components/OneParser/types.ts with:\n\n1. **Device Types:**\n- BitDeviceType: 'P' | 'M' | 'K' | 'F' | 'T' | 'C'\n- WordDeviceType: 'D' | 'R' | 'Z' | 'N'\n- DeviceType: BitDeviceType | WordDeviceType\n- DeviceAddress interface with device, address, bitIndex (optional), indexRegister (optional)\n\n2. **Instruction Types:**\n- ContactInstructionType: LOAD variants (LOAD, LOADN, LOADP, LOADF), AND variants, OR variants\n- BlockInstructionType: ANDB, ORB\n- OutputInstructionType: OUT, OUTN, SET, RST\n- TimerInstructionType: TON, TOF, TMR\n- CounterInstructionType: CTU, CTD, CTUD\n- ComparisonInstructionType: LD=, LD>, LD<, LD>=, LD<=, LD<>\n- MathInstructionType: ADD, SUB, MUL, DIV, MOV\n- InstructionType union of all above\n\nFollow existing patterns from src/types/scenario.ts and src/components/OneCanvas/types.ts for consistent documentation and organization.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation with `pnpm tsc --noEmit`. Create type tests ensuring type assignments work correctly and invalid assignments fail.",
            "parentId": "undefined",
            "updatedAt": "2026-01-29T01:04:24.860Z"
          },
          {
            "id": 2,
            "title": "Create TypeScript AST Node and Program Structure Types",
            "description": "Define the AST node types (LadderNodeType, contact/coil/timer/counter/comparison/math/block nodes), CSV row types, and program structure types (LadderNetwork, SymbolTable, ProgramMetadata, LadderProgram).",
            "dependencies": [
              1
            ],
            "details": "Add to src/components/OneParser/types.ts:\n\n1. **CSV Row Types:**\n- CsvRow interface: no, step, instruction, operand1-3, comment\n\n2. **AST Node Types:**\n- LadderNodeType: contact_no, contact_nc, contact_p, contact_n, coil_out, coil_set, coil_rst, timer_*, counter_*, comparison, math, move, block_series, block_parallel\n- GridPosition interface: row, col\n- BaseLadderNode with id, type, address, comment, gridPosition\n- ContactNode, CoilNode, TimerNode (with preset/timeBase), CounterNode (with preset)\n- ComparisonNode (with operator, operand1, operand2), MathNode (with operator, operand1, operand2, destination)\n- BlockNode with children: LadderNode[]\n- LadderNode discriminated union\n\n3. **Program Structure:**\n- LadderNetwork: id, step, nodes, comment\n- SymbolEntry: address, symbol, comment, dataType\n- SymbolTable: Map<string, SymbolEntry>\n- ProgramMetadata: name, description, author, createdAt, modifiedAt, version, plcModel\n- LadderProgram: metadata, networks, symbolTable",
            "status": "done",
            "testStrategy": "Create type guard functions (isContactNode, isCoilNode, isTimerNode, etc.) and test they correctly identify node types. Test LadderProgram can be serialized/deserialized to JSON.",
            "parentId": "undefined",
            "updatedAt": "2026-01-29T01:04:24.880Z"
          },
          {
            "id": 3,
            "title": "Create TypeScript Modbus Mapping and Utility Types",
            "description": "Define Modbus address mapping types (ModbusAddressType, ModbusAddress, MappingRule) and add type guards, validation functions, and default value factories for the OneParser types.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add to src/components/OneParser/types.ts:\n\n1. **Modbus Mapping Types:**\n- ModbusAddressType: 'coil' | 'discrete' | 'holding' | 'input' (leverage existing MemoryType from src/types/modbus.ts)\n- ModbusAddress interface: type, address (number)\n- MappingRule interface: device (DeviceType), modbusType (ModbusAddressType), offset (number)\n\n2. **Type Guards:**\n- isBitDevice(device: DeviceType): device is BitDeviceType\n- isWordDevice(device: DeviceType): device is WordDeviceType\n- isContactNode(node: LadderNode): node is ContactNode\n- isCoilNode(node: LadderNode): node is CoilNode\n- isTimerNode(node: LadderNode): node is TimerNode\n- isCounterNode(node: LadderNode): node is CounterNode\n- isBlockNode(node: LadderNode): node is BlockNode\n\n3. **Utility Functions:**\n- parseDeviceAddress(str: string): DeviceAddress | null\n- formatDeviceAddress(addr: DeviceAddress): string\n- getDefaultMappingRules(): MappingRule[]\n\n4. **Default Values:**\n- DEFAULT_PROGRAM_METADATA\n- createEmptyLadderProgram()",
            "status": "done",
            "testStrategy": "Unit test type guards return correct boolean values. Test parseDeviceAddress with valid/invalid inputs. Test formatDeviceAddress produces correct strings. Verify MappingRule defaults cover all device types.",
            "parentId": "undefined",
            "updatedAt": "2026-01-29T01:04:24.898Z"
          },
          {
            "id": 4,
            "title": "Create Rust Parser Types Module with Device and Instruction Types",
            "description": "Create src-tauri/src/parser/types.rs with Rust equivalents of the TypeScript device types, instruction types, and CSV row structures with serde serialization.",
            "dependencies": [
              1
            ],
            "details": "Create src-tauri/src/parser/mod.rs and src-tauri/src/parser/types.rs:\n\n1. **Module Setup:**\n- Create src-tauri/src/parser/mod.rs: `pub mod types; pub use types::*;`\n- Update src-tauri/src/lib.rs to include `pub mod parser;`\n\n2. **Device Types (types.rs):**\n```rust\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum BitDeviceType { P, M, K, F, T, C }\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum WordDeviceType { D, R, Z, N }\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\n#[serde(untagged)]\npub enum DeviceType { Bit(BitDeviceType), Word(WordDeviceType) }\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct DeviceAddress { device: DeviceType, address: u32, bit_index: Option<u8>, index_register: Option<u8> }\n```\n\n3. **Instruction Types:** Define enums for ContactInstructionType, BlockInstructionType, OutputInstructionType, TimerInstructionType, CounterInstructionType, ComparisonInstructionType, MathInstructionType\n\n4. **CSV Row:**\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CsvRow { no: u32, step: u32, instruction: String, operand1-3: Option<String>, comment: Option<String> }\n```",
            "status": "done",
            "testStrategy": "Write Rust unit tests for serde serialization/deserialization roundtrips. Test JSON output matches TypeScript interface structure. Verify enum variants serialize with expected casing.",
            "parentId": "undefined",
            "updatedAt": "2026-01-29T01:07:08.016Z"
          },
          {
            "id": 5,
            "title": "Create Rust AST Node and Program Structure Types",
            "description": "Define Rust equivalents of AST node types (LadderNode variants), program structure types (LadderNetwork, SymbolTable, LadderProgram), and Modbus mapping types with matching serde configuration.",
            "dependencies": [
              4
            ],
            "details": "Add to src-tauri/src/parser/types.rs:\n\n1. **Grid Position and Base Types:**\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GridPosition { row: i32, col: i32 }\n```\n\n2. **Ladder Node Types (using enum with variants):**\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\", rename_all = \"snake_case\")]\npub enum LadderNode {\n    ContactNo { id: String, address: DeviceAddress, ... },\n    ContactNc { ... },\n    CoilOut { ... },\n    TimerTon { id: String, address: DeviceAddress, preset: u32, time_base: TimeBase, ... },\n    BlockSeries { id: String, children: Vec<LadderNode>, ... },\n    ...\n}\n```\n\n3. **Program Structure:**\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct LadderNetwork { id: String, step: u32, nodes: Vec<LadderNode>, comment: Option<String> }\n\npub struct SymbolEntry { address: DeviceAddress, symbol: Option<String>, comment: Option<String>, data_type: Option<DataType> }\n\npub struct ProgramMetadata { name: String, description: Option<String>, ... }\n\npub struct LadderProgram { metadata: ProgramMetadata, networks: Vec<LadderNetwork>, symbol_table: HashMap<String, SymbolEntry> }\n```\n\n4. **Modbus Mapping:**\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ModbusAddressType { Coil, Discrete, Holding, Input }\n\npub struct ModbusAddress { address_type: ModbusAddressType, address: u16 }\n\npub struct MappingRule { device: DeviceType, modbus_type: ModbusAddressType, offset: u16 }\n```\n\n5. **Implement Default traits** for LadderProgram and ProgramMetadata similar to scenario/types.rs patterns.",
            "status": "done",
            "testStrategy": "Test JSON serialization produces structure matching TypeScript types. Write tests verifying LadderNode discriminated union serializes with correct 'type' field. Test LadderProgram roundtrip through serde_json. Cross-validate with TypeScript types via Tauri command interop test.",
            "parentId": "undefined",
            "updatedAt": "2026-01-29T01:07:08.034Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Define TypeScript types for OneParser including PLC device types, parsed structures, and AST nodes following patterns in src/components/OneCanvas/types.ts",
        "updatedAt": "2026-01-29T01:07:08.034Z"
      },
      {
        "id": "62",
        "title": "Implement CSV Reader and Row Parser",
        "description": "Create the CSV parsing functionality to read XG5000 exported CSV files and parse individual rows into structured CsvRow objects.",
        "details": "Create `src/components/OneParser/CsvReader.ts`:\n\n```typescript\nimport type { CsvRow } from './types';\n\n/**\n * CSV Reader for XG5000 ladder logic exports\n */\nexport class CsvReader {\n  private lines: string[];\n  private currentIndex: number = 0;\n  \n  constructor(csvContent: string) {\n    this.lines = csvContent.split(/\\r?\\n/).filter(line => line.trim());\n    // Skip header row\n    if (this.lines.length > 0 && this.lines[0].toLowerCase().includes('no,step')) {\n      this.currentIndex = 1;\n    }\n  }\n  \n  /**\n   * Parse a single CSV line into fields, handling quoted values\n   */\n  private parseLine(line: string): string[] {\n    const fields: string[] = [];\n    let current = '';\n    let inQuotes = false;\n    \n    for (let i = 0; i < line.length; i++) {\n      const char = line[i];\n      if (char === '\"') {\n        inQuotes = !inQuotes;\n      } else if (char === ',' && !inQuotes) {\n        fields.push(current.trim());\n        current = '';\n      } else {\n        current += char;\n      }\n    }\n    fields.push(current.trim());\n    return fields;\n  }\n  \n  /**\n   * Read the next row from CSV\n   */\n  readRow(): CsvRow | null {\n    if (this.currentIndex >= this.lines.length) {\n      return null;\n    }\n    \n    const fields = this.parseLine(this.lines[this.currentIndex++]);\n    if (fields.length < 3) {\n      return null;\n    }\n    \n    return {\n      no: parseInt(fields[0], 10) || 0,\n      step: parseInt(fields[1], 10) || 0,\n      instruction: fields[2]?.toUpperCase() || '',\n      operand1: fields[3] || undefined,\n      operand2: fields[4] || undefined,\n      operand3: fields[5] || undefined,\n      comment: fields[6] || undefined,\n    };\n  }\n  \n  /**\n   * Read all rows from CSV\n   */\n  readAllRows(): CsvRow[] {\n    const rows: CsvRow[] = [];\n    let row: CsvRow | null;\n    while ((row = this.readRow()) !== null) {\n      rows.push(row);\n    }\n    return rows;\n  }\n  \n  /**\n   * Group rows by step (network/rung)\n   */\n  groupByStep(rows: CsvRow[]): Map<number, CsvRow[]> {\n    const groups = new Map<number, CsvRow[]>();\n    for (const row of rows) {\n      const step = row.step;\n      if (!groups.has(step)) {\n        groups.set(step, []);\n      }\n      groups.get(step)!.push(row);\n    }\n    return groups;\n  }\n  \n  /**\n   * Reset reader to beginning\n   */\n  reset(): void {\n    this.currentIndex = this.lines[0]?.toLowerCase().includes('no,step') ? 1 : 0;\n  }\n}\n```\n\nCreate Rust implementation in `src-tauri/src/parser/csv_parser.rs`:\n\n```rust\nuse serde::{Deserialize, Serialize};\nuse std::io::BufRead;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CsvRow {\n    pub no: u32,\n    pub step: u32,\n    pub instruction: String,\n    pub operand1: Option<String>,\n    pub operand2: Option<String>,\n    pub operand3: Option<String>,\n    pub comment: Option<String>,\n}\n\npub struct CsvReader<R: BufRead> {\n    reader: R,\n    skip_header: bool,\n}\n\nimpl<R: BufRead> CsvReader<R> {\n    pub fn new(reader: R) -> Self {\n        Self { reader, skip_header: true }\n    }\n    \n    pub fn read_all(&mut self) -> Result<Vec<CsvRow>, CsvParseError> {\n        let mut rows = Vec::new();\n        let mut line = String::new();\n        let mut line_num = 0;\n        \n        while self.reader.read_line(&mut line)? > 0 {\n            line_num += 1;\n            if line_num == 1 && self.skip_header {\n                line.clear();\n                continue;\n            }\n            \n            if let Some(row) = self.parse_line(&line, line_num)? {\n                rows.push(row);\n            }\n            line.clear();\n        }\n        \n        Ok(rows)\n    }\n    \n    fn parse_line(&self, line: &str, line_num: usize) -> Result<Option<CsvRow>, CsvParseError> {\n        let fields = self.split_csv_line(line);\n        if fields.len() < 3 {\n            return Ok(None);\n        }\n        \n        Ok(Some(CsvRow {\n            no: fields[0].parse().unwrap_or(0),\n            step: fields[1].parse().unwrap_or(0),\n            instruction: fields[2].to_uppercase(),\n            operand1: fields.get(3).filter(|s| !s.is_empty()).map(|s| s.to_string()),\n            operand2: fields.get(4).filter(|s| !s.is_empty()).map(|s| s.to_string()),\n            operand3: fields.get(5).filter(|s| !s.is_empty()).map(|s| s.to_string()),\n            comment: fields.get(6).filter(|s| !s.is_empty()).map(|s| s.to_string()),\n        }))\n    }\n    \n    fn split_csv_line(&self, line: &str) -> Vec<String> {\n        // Handle quoted fields\n        let mut fields = Vec::new();\n        let mut current = String::new();\n        let mut in_quotes = false;\n        \n        for ch in line.trim().chars() {\n            match ch {\n                '\"' => in_quotes = !in_quotes,\n                ',' if !in_quotes => {\n                    fields.push(current.trim().to_string());\n                    current.clear();\n                }\n                _ => current.push(ch),\n            }\n        }\n        fields.push(current.trim().to_string());\n        fields\n    }\n}\n```",
        "testStrategy": "1. Unit test CSV parsing with sample XG5000 export data\n2. Test handling of quoted fields with commas\n3. Test grouping by step number\n4. Test empty/malformed rows are handled gracefully\n5. Test Korean/Unicode comments are preserved",
        "priority": "high",
        "dependencies": [
          "61"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CsvRow Type Definition in OneParser types.ts",
            "description": "Define the CsvRow interface in the OneParser types file to represent a single parsed row from XG5000 CSV export containing instruction data.",
            "dependencies": [],
            "details": "Create src/components/OneParser/types.ts (if not existing from task 61) and add the CsvRow interface with fields: no (number for row number), step (number for network/rung), instruction (string for instruction mnemonic), operand1 (optional string), operand2 (optional string), operand3 (optional string), comment (optional string). This type will be used by both the TypeScript CsvReader class and as the return type from Rust Tauri commands. Ensure the interface matches the CSV column structure from XG5000 exports: NO, STEP, INSTRUCTION, OPERAND1, OPERAND2, OPERAND3, COMMENT.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation with `pnpm tsc --noEmit`. Test that CsvRow interface can be instantiated with both minimal (no, step, instruction) and full field sets.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement TypeScript CsvReader Class with Line Parsing",
            "description": "Create the CsvReader.ts file with the CsvReader class implementing CSV line splitting with quoted field handling and row parsing.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/OneParser/CsvReader.ts implementing: constructor accepting csvContent string that splits by newlines and filters empty lines, skips header row if detected (contains 'no,step'), private parseLine method handling quoted fields with commas inside quotes (iterate character-by-character, toggle inQuotes flag on double-quotes, split on comma only when not inQuotes), readRow method returning CsvRow or null when exhausted, readAllRows method that iterates readRow until null. Follow the existing csvParser.ts pattern from ScenarioEditor for quoted field handling. Convert instruction to uppercase, parse no/step as integers with fallback to 0.",
            "status": "pending",
            "testStrategy": "Unit test with sample XG5000 CSV content including quoted fields with embedded commas. Test header detection and skipping. Test readRow returns null at end of file. Test Korean comments in quoted fields are preserved.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement CsvReader Utility Methods (groupByStep, reset)",
            "description": "Add the groupByStep method to organize rows by network/step number and reset method to allow re-reading from the beginning.",
            "dependencies": [
              2
            ],
            "details": "In src/components/OneParser/CsvReader.ts, add: groupByStep method taking CsvRow[] and returning Map<number, CsvRow[]> where each step number maps to all rows in that network (allows processing ladder logic network by network), reset method that sets currentIndex back to 1 (or 0 if no header) to allow re-reading the CSV content without re-parsing. The groupByStep is essential for the LadderBuilder (task 65) which processes one network at a time. Export CsvReader class as default export.",
            "status": "pending",
            "testStrategy": "Test groupByStep correctly groups rows: rows with step=0 together, step=1 together, etc. Test reset allows reading all rows again. Test groupByStep with empty array returns empty Map.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create Rust CsvRow Struct and CsvReader Implementation",
            "description": "Implement the Rust-side CSV parsing in src-tauri/src/parser/csv_parser.rs with CsvRow struct and CsvReader for high-performance parsing.",
            "dependencies": [
              1
            ],
            "details": "Create src-tauri/src/parser/mod.rs and csv_parser.rs. Define CsvRow struct with serde derives (Serialize, Deserialize) matching TypeScript interface: no (u32), step (u32), instruction (String), operand1/2/3 (Option<String>), comment (Option<String>). Implement CsvReader<R: BufRead> with: new() constructor, read_all() returning Result<Vec<CsvRow>, CsvParseError>, parse_line() handling quoted fields, split_csv_line() utility. Add CsvParseError enum using thiserror with variants for IoError, InvalidFormat. Register parser module in lib.rs. Use existing csv crate (already in Cargo.toml) or implement manual parsing for full control over XG5000 format quirks.",
            "status": "pending",
            "testStrategy": "Unit test Rust CSV parsing with embedded test data. Test quoted field handling. Test Unicode/Korean character preservation. Test malformed rows return appropriate errors. Test empty optional fields become None.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Tauri Commands for CSV Parsing Operations",
            "description": "Implement Tauri commands to expose CSV parsing functionality to the frontend, including file reading and parsing.",
            "dependencies": [
              4
            ],
            "details": "Create src-tauri/src/commands/parser.rs with Tauri commands: parse_csv_file(path: String) -> Result<Vec<CsvRow>, ModOneError> that reads file content and parses using CsvReader, parse_csv_content(content: String) -> Result<Vec<CsvRow>, ModOneError> for parsing raw string content (useful for drag-drop or clipboard paste). Register commands in lib.rs invoke_handler. Add parser commands to commands/mod.rs exports. Use std::fs::read_to_string with proper error handling for file reading. Return structured errors for file not found, permission denied, parse failures.",
            "status": "pending",
            "testStrategy": "Integration test Tauri commands with test CSV files. Test error handling for non-existent files. Test parse_csv_content with string input. Test commands return properly serialized CsvRow arrays that TypeScript can consume.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement CSV parsing for PLC memory export files with column detection, type inference, and error handling"
      },
      {
        "id": "63",
        "title": "Implement Device Address Parser",
        "description": "Create a parser for LS PLC device addresses including standard addresses (P0001, M0001), bit access (D0000.0), and indexed addressing (D[Z0]).",
        "details": "Create `src/components/OneParser/AddressParser.ts`:\n\n```typescript\nimport type { DeviceAddress, DeviceType, BitDeviceType, WordDeviceType } from './types';\n\nconst BIT_DEVICES: BitDeviceType[] = ['P', 'M', 'K', 'F', 'T', 'C'];\nconst WORD_DEVICES: WordDeviceType[] = ['D', 'R', 'Z', 'N'];\n\n/**\n * Device address ranges for LS PLC\n */\nexport const DEVICE_RANGES: Record<DeviceType, { start: number; end: number }> = {\n  P: { start: 0, end: 2047 },\n  M: { start: 0, end: 8191 },\n  K: { start: 0, end: 2047 },\n  F: { start: 0, end: 2047 },\n  T: { start: 0, end: 2047 },\n  C: { start: 0, end: 2047 },\n  D: { start: 0, end: 9999 },\n  R: { start: 0, end: 9999 },\n  Z: { start: 0, end: 15 },\n  N: { start: 0, end: 8191 },\n};\n\n/**\n * Parse device address string into structured DeviceAddress\n * \n * Supported formats:\n * - P0001, M0001, D0000 (standard)\n * - D0000.0, D0000.15 (bit access on word device)\n * - D[Z0], D[Z0+10] (indexed addressing)\n */\nexport function parseDeviceAddress(addressStr: string): DeviceAddress | null {\n  if (!addressStr || addressStr.trim() === '') {\n    return null;\n  }\n  \n  const str = addressStr.trim().toUpperCase();\n  \n  // Try indexed addressing: D[Z0], D[Z0+10]\n  const indexedMatch = str.match(/^([A-Z])\\[Z(\\d+)(?:\\+?(\\d+))?\\]$/i);\n  if (indexedMatch) {\n    const device = indexedMatch[1] as DeviceType;\n    const indexReg = parseInt(indexedMatch[2], 10);\n    const offset = indexedMatch[3] ? parseInt(indexedMatch[3], 10) : 0;\n    \n    if (!isValidDevice(device)) return null;\n    \n    return {\n      device,\n      address: offset,\n      indexRegister: indexReg,\n    };\n  }\n  \n  // Try bit access on word device: D0000.0\n  const bitAccessMatch = str.match(/^([A-Z])(\\d+)\\.(\\d+)$/i);\n  if (bitAccessMatch) {\n    const device = bitAccessMatch[1] as DeviceType;\n    const address = parseInt(bitAccessMatch[2], 10);\n    const bitIndex = parseInt(bitAccessMatch[3], 10);\n    \n    if (!isValidDevice(device)) return null;\n    if (!isWordDevice(device)) return null;  // Bit access only on word devices\n    if (bitIndex < 0 || bitIndex > 15) return null;\n    \n    return {\n      device,\n      address,\n      bitIndex,\n    };\n  }\n  \n  // Try standard address: P0001, M0001, D0000\n  const standardMatch = str.match(/^([A-Z])(\\d+)$/i);\n  if (standardMatch) {\n    const device = standardMatch[1] as DeviceType;\n    const address = parseInt(standardMatch[2], 10);\n    \n    if (!isValidDevice(device)) return null;\n    if (!isAddressInRange(device, address)) return null;\n    \n    return {\n      device,\n      address,\n    };\n  }\n  \n  return null;\n}\n\n/**\n * Stringify a DeviceAddress back to string format\n */\nexport function stringifyDeviceAddress(addr: DeviceAddress): string {\n  if (addr.indexRegister !== undefined) {\n    const offset = addr.address > 0 ? `+${addr.address}` : '';\n    return `${addr.device}[Z${addr.indexRegister}${offset}]`;\n  }\n  \n  if (addr.bitIndex !== undefined) {\n    return `${addr.device}${addr.address.toString().padStart(4, '0')}.${addr.bitIndex}`;\n  }\n  \n  const padLength = WORD_DEVICES.includes(addr.device as WordDeviceType) ? 4 : 4;\n  return `${addr.device}${addr.address.toString().padStart(padLength, '0')}`;\n}\n\nexport function isValidDevice(device: string): device is DeviceType {\n  return BIT_DEVICES.includes(device as BitDeviceType) || \n         WORD_DEVICES.includes(device as WordDeviceType);\n}\n\nexport function isBitDevice(device: DeviceType): device is BitDeviceType {\n  return BIT_DEVICES.includes(device as BitDeviceType);\n}\n\nexport function isWordDevice(device: DeviceType): device is WordDeviceType {\n  return WORD_DEVICES.includes(device as WordDeviceType);\n}\n\nexport function isAddressInRange(device: DeviceType, address: number): boolean {\n  const range = DEVICE_RANGES[device];\n  return address >= range.start && address <= range.end;\n}\n```",
        "testStrategy": "1. Test standard address parsing: P0001, M0001, D0000\n2. Test bit access parsing: D0000.0, D0000.15\n3. Test indexed addressing: D[Z0], D[Z0+10]\n4. Test invalid addresses return null\n5. Test address range validation\n6. Test stringifyDeviceAddress round-trips correctly",
        "priority": "high",
        "dependencies": [
          "61"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create OneParser directory structure and define TypeScript types",
            "description": "Create the src/components/OneParser/ directory and define the DeviceAddress, DeviceType, BitDeviceType, and WordDeviceType TypeScript types in a types.ts file.",
            "dependencies": [],
            "details": "Create src/components/OneParser/ directory structure. Create src/components/OneParser/types.ts with the following type definitions: 1) BitDeviceType as a union type of 'P' | 'M' | 'K' | 'F' | 'T' | 'C' representing bit-addressable devices. 2) WordDeviceType as union 'D' | 'R' | 'Z' | 'N' for word devices. 3) DeviceType as BitDeviceType | WordDeviceType. 4) DeviceAddress interface with: device (DeviceType), address (number), optional bitIndex (number, 0-15 for bit access on word devices), optional indexRegister (number, for indexed addressing like D[Z0]). Add JSDoc comments explaining each type and their use cases in LS PLC programming. Export all types for use by AddressParser.ts.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation passes with no errors. Import types in a test file to confirm exports work correctly. Validate type narrowing works for BitDeviceType and WordDeviceType guards.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement device constants and address range validation",
            "description": "Create the BIT_DEVICES and WORD_DEVICES arrays, DEVICE_RANGES constant object, and validation helper functions (isValidDevice, isBitDevice, isWordDevice, isAddressInRange).",
            "dependencies": [
              1
            ],
            "details": "In src/components/OneParser/AddressParser.ts, implement: 1) BIT_DEVICES constant array: ['P', 'M', 'K', 'F', 'T', 'C']. 2) WORD_DEVICES constant array: ['D', 'R', 'Z', 'N']. 3) DEVICE_RANGES constant with address limits for each device type matching LS PLC specifications (P: 0-2047, M: 0-8191, K: 0-2047, F: 0-2047, T: 0-2047, C: 0-2047, D: 0-9999, R: 0-9999, Z: 0-15, N: 0-8191). 4) isValidDevice(device: string): device is DeviceType - type guard checking if string is valid device. 5) isBitDevice(device: DeviceType): device is BitDeviceType - checks if device is bit-addressable. 6) isWordDevice(device: DeviceType): device is WordDeviceType - checks if device is word-addressable. 7) isAddressInRange(device: DeviceType, address: number): boolean - validates address within device range.",
            "status": "pending",
            "testStrategy": "Test isValidDevice returns true for all valid devices (P, M, K, F, T, C, D, R, Z, N) and false for invalid inputs (X, Y, A). Test isBitDevice/isWordDevice correctly categorize devices. Test isAddressInRange returns true for boundary values (0, max) and false for out-of-range values.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement parseDeviceAddress function for all address formats",
            "description": "Implement the main parseDeviceAddress function that parses standard addresses (P0001), bit access (D0000.0), and indexed addressing (D[Z0], D[Z0+10]) formats.",
            "dependencies": [
              2
            ],
            "details": "Implement parseDeviceAddress(addressStr: string): DeviceAddress | null with three parsing stages: 1) Input validation - return null for empty/whitespace-only strings, normalize to uppercase. 2) Indexed addressing regex: /^([A-Z])\\[Z(\\d+)(?:\\+?(\\d+))?\\]$/i - extract device letter, index register number, and optional offset. Validate device type and return DeviceAddress with indexRegister property. 3) Bit access regex: /^([A-Z])(\\d+)\\.(\\d+)$/i - extract device, address, and bit index. Validate device is word type, bit index is 0-15, and return DeviceAddress with bitIndex property. 4) Standard format regex: /^([A-Z])(\\d+)$/i - extract device and address, validate device type and address range, return basic DeviceAddress. Return null for any invalid format or out-of-range values. Add comprehensive JSDoc with examples for each format.",
            "status": "pending",
            "testStrategy": "Test standard parsing: P0001 -> {device:'P',address:1}, M0000 -> {device:'M',address:0}, D9999 -> {device:'D',address:9999}. Test bit access: D0000.0 -> {device:'D',address:0,bitIndex:0}, D0000.15 -> valid, D0000.16 -> null. Test indexed: D[Z0] -> {device:'D',address:0,indexRegister:0}, D[Z0+10] -> {device:'D',address:10,indexRegister:0}. Test invalid inputs return null.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement stringifyDeviceAddress function for address serialization",
            "description": "Implement the stringifyDeviceAddress function that converts a DeviceAddress object back to its canonical string representation.",
            "dependencies": [
              2
            ],
            "details": "Implement stringifyDeviceAddress(addr: DeviceAddress): string that converts DeviceAddress to string format: 1) If indexRegister is defined: format as 'D[Z{indexRegister}]' or 'D[Z{indexRegister}+{offset}]' if address > 0. 2) If bitIndex is defined: format as 'D{address padded to 4 digits}.{bitIndex}' (e.g., D0000.5). 3) Standard format: pad address to 4 digits for all device types (e.g., P0001, M0123, D0456). Use the device letter from addr.device. Ensure consistent formatting that can be round-tripped through parseDeviceAddress. Handle edge cases like address 0 (should stringify to D0000 not D0).",
            "status": "pending",
            "testStrategy": "Test round-trip: parseDeviceAddress(stringifyDeviceAddress(addr)) equals original for all formats. Test standard: {device:'P',address:1} -> 'P0001'. Test bit access: {device:'D',address:0,bitIndex:5} -> 'D0000.5'. Test indexed: {device:'D',address:10,indexRegister:0} -> 'D[Z0+10]', {device:'D',address:0,indexRegister:2} -> 'D[Z2]'. Verify padding is consistent.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create module exports and add comprehensive unit tests",
            "description": "Create the index.ts barrel export file and implement unit tests covering all address parsing scenarios, edge cases, and error conditions.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create src/components/OneParser/index.ts that exports all public APIs: parseDeviceAddress, stringifyDeviceAddress, isValidDevice, isBitDevice, isWordDevice, isAddressInRange, DEVICE_RANGES, and all types from types.ts. Create test file (following project's test pattern) with comprehensive test suites: 1) Standard address parsing tests for all device types with boundary values. 2) Bit access parsing tests including valid (0-15) and invalid (16+, negative) bit indices. 3) Indexed addressing tests with various Z register numbers and offsets. 4) Invalid input tests: empty string, whitespace, malformed formats, unknown device letters. 5) Range validation tests for each device type. 6) Round-trip tests ensuring parse->stringify->parse produces identical results. 7) Case insensitivity tests (p0001 should equal P0001).",
            "status": "pending",
            "testStrategy": "Run full test suite ensuring 100% coverage of public API. Test boundary conditions: D0000, D9999, Z15, bit index 0 and 15. Test error cases: empty string returns null, 'P-1' returns null, 'D10000' returns null (out of range), 'X0001' returns null (invalid device). Verify exports work correctly from index.ts barrel file.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement address parsing for multiple PLC formats (Mitsubishi M8000, X/Y/D/M) following patterns in src/types/scenario.ts parseModbusAddress"
      },
      {
        "id": "64",
        "title": "Implement Instruction Parser with Stack-Based Processing",
        "description": "Create the instruction parser that processes ladder logic instructions using a stack-based algorithm for handling LOAD, AND, OR, ANDB, and ORB instructions.",
        "details": "Create `src/components/OneParser/InstructionParser.ts`:\n\n```typescript\nimport type { \n  CsvRow, LadderNode, ContactNode, CoilNode, TimerNode, CounterNode,\n  ComparisonNode, MathNode, BlockNode, DeviceAddress, LadderNodeType\n} from './types';\nimport { parseDeviceAddress } from './AddressParser';\nimport { generateId } from './utils';\n\n/**\n * Stack-based instruction parser for LS PLC ladder logic\n * \n * Processing algorithm:\n * 1. LOAD/LOADN/LOADP/LOADF - Push new contact onto stack\n * 2. AND/ANDN/ANDP/ANDF - Series connection with top of stack\n * 3. OR/ORN/ORP/ORF - Create parallel branch, push to pending\n * 4. ANDB - Pop two items, create series block\n * 5. ORB - Pop two items, create parallel block\n * 6. OUT/SET/RST - Output coil, connects to current path\n */\nexport class InstructionParser {\n  private stack: LadderNode[] = [];\n  private pendingOr: LadderNode[] = [];\n  private nodeCount: number = 0;\n  \n  /**\n   * Parse a single instruction row\n   */\n  parseInstruction(row: CsvRow): LadderNode | null {\n    const instruction = row.instruction.toUpperCase();\n    \n    // Contact instructions\n    if (instruction.startsWith('LOAD') || instruction.match(/^(AND|OR)[NPF]?$/)) {\n      return this.parseContactInstruction(row);\n    }\n    \n    // Block instructions\n    if (instruction === 'ANDB' || instruction === 'ORB') {\n      return this.parseBlockInstruction(row);\n    }\n    \n    // Output instructions\n    if (['OUT', 'OUTN', 'SET', 'RST'].includes(instruction)) {\n      return this.parseOutputInstruction(row);\n    }\n    \n    // Timer instructions\n    if (['TON', 'TOF', 'TMR'].includes(instruction)) {\n      return this.parseTimerInstruction(row);\n    }\n    \n    // Counter instructions\n    if (['CTU', 'CTD', 'CTUD'].includes(instruction)) {\n      return this.parseCounterInstruction(row);\n    }\n    \n    // Comparison instructions\n    if (instruction.startsWith('LD') && ['=', '>', '<'].some(op => instruction.includes(op))) {\n      return this.parseComparisonInstruction(row);\n    }\n    \n    // Math instructions\n    if (['ADD', 'SUB', 'MUL', 'DIV', 'MOV'].includes(instruction)) {\n      return this.parseMathInstruction(row);\n    }\n    \n    return null;\n  }\n  \n  private parseContactInstruction(row: CsvRow): ContactNode | null {\n    const instruction = row.instruction.toUpperCase();\n    const address = parseDeviceAddress(row.operand1 || '');\n    \n    if (!address) return null;\n    \n    let nodeType: LadderNodeType;\n    if (instruction.endsWith('N')) {\n      nodeType = 'contact_nc';  // Normally Closed\n    } else if (instruction.endsWith('P')) {\n      nodeType = 'contact_p';   // Positive edge\n    } else if (instruction.endsWith('F')) {\n      nodeType = 'contact_n';   // Negative edge\n    } else {\n      nodeType = 'contact_no';  // Normally Open\n    }\n    \n    const node: ContactNode = {\n      id: this.generateNodeId(),\n      type: nodeType,\n      address,\n      comment: row.comment,\n      gridPosition: { row: 0, col: 0 },  // Will be calculated later\n    };\n    \n    // Stack operations based on instruction prefix\n    if (instruction.startsWith('LOAD')) {\n      this.stack.push(node);\n    } else if (instruction.startsWith('AND')) {\n      // Series connection - combine with top of stack\n      const top = this.stack.pop();\n      if (top) {\n        const seriesBlock: BlockNode = {\n          id: this.generateNodeId(),\n          type: 'block_series',\n          children: [top, node],\n          gridPosition: { row: 0, col: 0 },\n        };\n        this.stack.push(seriesBlock);\n      } else {\n        this.stack.push(node);\n      }\n    } else if (instruction.startsWith('OR')) {\n      // Parallel connection - push to pending OR\n      this.pendingOr.push(node);\n    }\n    \n    return node;\n  }\n  \n  private parseBlockInstruction(row: CsvRow): BlockNode | null {\n    const instruction = row.instruction.toUpperCase();\n    \n    if (instruction === 'ANDB') {\n      // AND Block: pop two items, create series connection\n      const item2 = this.stack.pop();\n      const item1 = this.stack.pop();\n      \n      if (item1 && item2) {\n        const block: BlockNode = {\n          id: this.generateNodeId(),\n          type: 'block_series',\n          children: [item1, item2],\n          gridPosition: { row: 0, col: 0 },\n        };\n        this.stack.push(block);\n        return block;\n      }\n    } else if (instruction === 'ORB') {\n      // OR Block: pop two items, create parallel connection\n      const item2 = this.stack.pop();\n      const item1 = this.stack.pop();\n      \n      if (item1 && item2) {\n        const block: BlockNode = {\n          id: this.generateNodeId(),\n          type: 'block_parallel',\n          children: [item1, item2],\n          gridPosition: { row: 0, col: 0 },\n        };\n        this.stack.push(block);\n        return block;\n      }\n    }\n    \n    return null;\n  }\n  \n  private parseOutputInstruction(row: CsvRow): CoilNode | null {\n    const instruction = row.instruction.toUpperCase();\n    const address = parseDeviceAddress(row.operand1 || '');\n    \n    if (!address) return null;\n    \n    let nodeType: LadderNodeType;\n    switch (instruction) {\n      case 'SET': nodeType = 'coil_set'; break;\n      case 'RST': nodeType = 'coil_rst'; break;\n      default: nodeType = 'coil_out'; break;\n    }\n    \n    return {\n      id: this.generateNodeId(),\n      type: nodeType,\n      address,\n      comment: row.comment,\n      gridPosition: { row: 0, col: 0 },\n    };\n  }\n  \n  private parseTimerInstruction(row: CsvRow): TimerNode | null {\n    const instruction = row.instruction.toUpperCase();\n    const address = parseDeviceAddress(row.operand1 || '');\n    const preset = parseInt(row.operand2 || '0', 10);\n    \n    if (!address) return null;\n    \n    let nodeType: LadderNodeType;\n    switch (instruction) {\n      case 'TON': nodeType = 'timer_ton'; break;\n      case 'TOF': nodeType = 'timer_tof'; break;\n      case 'TMR': nodeType = 'timer_tmr'; break;\n      default: return null;\n    }\n    \n    return {\n      id: this.generateNodeId(),\n      type: nodeType,\n      address,\n      preset,\n      timeBase: 'ms',\n      comment: row.comment,\n      gridPosition: { row: 0, col: 0 },\n    };\n  }\n  \n  private parseCounterInstruction(row: CsvRow): CounterNode | null {\n    const instruction = row.instruction.toUpperCase();\n    const address = parseDeviceAddress(row.operand1 || '');\n    const preset = parseInt(row.operand2 || '0', 10);\n    \n    if (!address) return null;\n    \n    let nodeType: LadderNodeType;\n    switch (instruction) {\n      case 'CTU': nodeType = 'counter_ctu'; break;\n      case 'CTD': nodeType = 'counter_ctd'; break;\n      case 'CTUD': nodeType = 'counter_ctud'; break;\n      default: return null;\n    }\n    \n    return {\n      id: this.generateNodeId(),\n      type: nodeType,\n      address,\n      preset,\n      comment: row.comment,\n      gridPosition: { row: 0, col: 0 },\n    };\n  }\n  \n  private parseComparisonInstruction(row: CsvRow): ComparisonNode | null {\n    const instruction = row.instruction.toUpperCase();\n    const operand1 = this.parseOperand(row.operand1);\n    const operand2 = this.parseOperand(row.operand2);\n    \n    if (operand1 === null || operand2 === null) return null;\n    \n    let operator: ComparisonNode['operator'];\n    if (instruction.includes('>=')) operator = '>=';\n    else if (instruction.includes('<=')) operator = '<=';\n    else if (instruction.includes('<>')) operator = '<>';\n    else if (instruction.includes('>')) operator = '>';\n    else if (instruction.includes('<')) operator = '<';\n    else operator = '=';\n    \n    return {\n      id: this.generateNodeId(),\n      type: 'comparison',\n      operator,\n      operand1,\n      operand2,\n      comment: row.comment,\n      gridPosition: { row: 0, col: 0 },\n    };\n  }\n  \n  private parseMathInstruction(row: CsvRow): MathNode | null {\n    const instruction = row.instruction.toUpperCase() as MathNode['operator'];\n    const operand1 = this.parseOperand(row.operand1);\n    const operand2 = instruction !== 'MOV' ? this.parseOperand(row.operand2) : undefined;\n    const destination = parseDeviceAddress(instruction === 'MOV' ? row.operand2 || '' : row.operand3 || '');\n    \n    if (operand1 === null || !destination) return null;\n    \n    return {\n      id: this.generateNodeId(),\n      type: instruction === 'MOV' ? 'move' : 'math',\n      operator: instruction,\n      operand1,\n      operand2: operand2 ?? undefined,\n      destination,\n      comment: row.comment,\n      gridPosition: { row: 0, col: 0 },\n    };\n  }\n  \n  private parseOperand(operand: string | undefined): DeviceAddress | number | null {\n    if (!operand) return null;\n    \n    // Try as number first\n    const num = parseInt(operand, 10);\n    if (!isNaN(num) && operand.match(/^-?\\d+$/)) {\n      return num;\n    }\n    \n    // Try as device address\n    return parseDeviceAddress(operand);\n  }\n  \n  private generateNodeId(): string {\n    return `node_${++this.nodeCount}`;\n  }\n  \n  /**\n   * Get the final result from the stack\n   */\n  getResult(): LadderNode | null {\n    // Combine any pending OR operations\n    while (this.pendingOr.length > 0) {\n      const orItem = this.pendingOr.pop()!;\n      const stackItem = this.stack.pop();\n      if (stackItem) {\n        const orBlock: BlockNode = {\n          id: this.generateNodeId(),\n          type: 'block_parallel',\n          children: [stackItem, orItem],\n          gridPosition: { row: 0, col: 0 },\n        };\n        this.stack.push(orBlock);\n      }\n    }\n    \n    return this.stack.pop() || null;\n  }\n  \n  /**\n   * Reset parser state for new network\n   */\n  reset(): void {\n    this.stack = [];\n    this.pendingOr = [];\n  }\n}\n```",
        "testStrategy": "1. Test LOAD instruction creates contact_no node\n2. Test LOADN creates contact_nc node\n3. Test AND instruction creates series connection\n4. Test OR instruction handles parallel branches\n5. Test ANDB/ORB block operations\n6. Test timer/counter instruction parsing\n7. Test comparison and math instruction parsing\n8. Test complex nested structures (multiple ANDB/ORB)",
        "priority": "high",
        "dependencies": [
          "62",
          "63"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Ladder Node Types and Interfaces in OneParser types.ts",
            "description": "Create comprehensive TypeScript type definitions for all ladder logic node types including contacts, coils, timers, counters, comparisons, math operations, and block structures.",
            "dependencies": [],
            "details": "Create `src/components/OneParser/types.ts` with the following type definitions:\n\n1. Define LadderNodeType union type covering all node variants:\n   - Contact types: 'contact_no' | 'contact_nc' | 'contact_p' | 'contact_n'\n   - Coil types: 'coil_out' | 'coil_set' | 'coil_rst'\n   - Timer types: 'timer_ton' | 'timer_tof' | 'timer_tmr'\n   - Counter types: 'counter_ctu' | 'counter_ctd' | 'counter_ctud'\n   - Function block types: 'comparison' | 'math' | 'move'\n   - Block types: 'block_series' | 'block_parallel'\n\n2. Define GridPosition interface: { row: number; col: number; }\n\n3. Define base LadderNodeBase interface with common fields:\n   - id: string\n   - type: LadderNodeType\n   - comment?: string\n   - gridPosition: GridPosition\n\n4. Define specific node interfaces extending/using the base:\n   - ContactNode: type, address (DeviceAddress), comment, gridPosition\n   - CoilNode: type, address (DeviceAddress), comment, gridPosition\n   - TimerNode: type, address, preset (number), timeBase ('ms'|'s'), comment, gridPosition\n   - CounterNode: type, address, preset (number), comment, gridPosition\n   - ComparisonNode: type, operator ('='|'<>'|'>'|'>='|'<'|'<='), operand1, operand2, comment, gridPosition\n   - MathNode: type, operator ('ADD'|'SUB'|'MUL'|'DIV'|'MOV'), operand1, operand2?, destination, comment, gridPosition\n   - BlockNode: type ('block_series'|'block_parallel'), children (LadderNode[]), gridPosition\n\n5. Define LadderNode discriminated union type of all node types\n\n6. Import and re-export CsvRow from future CsvReader module and DeviceAddress from future AddressParser module (use placeholder imports that will be resolved when dependencies are complete)",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation with `pnpm tsc --noEmit`. Create test instances of each node type to confirm type narrowing works correctly. Test that discriminated union properly narrows based on 'type' field. Verify all required fields are enforced and optional fields are properly typed.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Utility Functions and ID Generator Module",
            "description": "Create the utility module with node ID generation function and helper functions needed by the instruction parser.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/OneParser/utils.ts` with the following utilities:\n\n1. Implement generateId function for creating unique node IDs:\n   ```typescript\n   export function generateId(prefix: string = 'node'): string {\n     return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n   }\n   ```\n   This follows the existing pattern from canvasStore.ts (line 214-216).\n\n2. Create type guard functions for node type checking:\n   - isContactNode(node: LadderNode): node is ContactNode\n   - isCoilNode(node: LadderNode): node is CoilNode\n   - isTimerNode(node: LadderNode): node is TimerNode\n   - isCounterNode(node: LadderNode): node is CounterNode\n   - isComparisonNode(node: LadderNode): node is ComparisonNode\n   - isMathNode(node: LadderNode): node is MathNode\n   - isBlockNode(node: LadderNode): node is BlockNode\n\n3. Create instruction category helper functions:\n   - isLoadInstruction(instruction: string): boolean - matches LOAD/LOADN/LOADP/LOADF\n   - isAndInstruction(instruction: string): boolean - matches AND/ANDN/ANDP/ANDF\n   - isOrInstruction(instruction: string): boolean - matches OR/ORN/ORP/ORF\n   - isBlockInstruction(instruction: string): boolean - matches ANDB/ORB\n   - isOutputInstruction(instruction: string): boolean - matches OUT/OUTN/SET/RST\n   - isTimerInstruction(instruction: string): boolean - matches TON/TOF/TMR\n   - isCounterInstruction(instruction: string): boolean - matches CTU/CTD/CTUD\n\n4. Export all utilities from the module",
            "status": "pending",
            "testStrategy": "Unit test generateId produces unique strings across 1000 iterations. Test type guards correctly identify each node type. Test instruction category functions with uppercase and lowercase inputs. Test edge cases like empty strings and partial matches.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement InstructionParser Class with Stack Management",
            "description": "Create the core InstructionParser class with stack-based state management and the main parseInstruction method that dispatches to specific instruction handlers.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/components/OneParser/InstructionParser.ts` with the InstructionParser class:\n\n1. Class structure with private state:\n   ```typescript\n   export class InstructionParser {\n     private stack: LadderNode[] = [];\n     private pendingOr: LadderNode[] = [];\n     private nodeCount: number = 0;\n   }\n   ```\n\n2. Implement private generateNodeId method:\n   ```typescript\n   private generateNodeId(): string {\n     return `node_${++this.nodeCount}`;\n   }\n   ```\n\n3. Implement main parseInstruction method that:\n   - Takes CsvRow as input parameter\n   - Converts instruction to uppercase for case-insensitive matching\n   - Dispatches to appropriate handler based on instruction type:\n     - LOAD/LOADN/LOADP/LOADF, AND/ANDN/ANDP/ANDF, OR/ORN/ORP/ORF -> parseContactInstruction\n     - ANDB, ORB -> parseBlockInstruction\n     - OUT, OUTN, SET, RST -> parseOutputInstruction\n     - TON, TOF, TMR -> parseTimerInstruction\n     - CTU, CTD, CTUD -> parseCounterInstruction\n     - LD=, LD<>, LD>, LD>=, LD<, LD<= -> parseComparisonInstruction\n     - ADD, SUB, MUL, DIV, MOV -> parseMathInstruction\n   - Returns LadderNode | null\n\n4. Implement reset method to clear parser state for new network:\n   ```typescript\n   reset(): void {\n     this.stack = [];\n     this.pendingOr = [];\n   }\n   ```\n\n5. Implement getResult method that:\n   - Combines any pending OR operations with stack items\n   - Returns final combined LadderNode or null if stack is empty\n\n6. Add placeholder stubs for instruction parsing methods to be implemented in next subtasks",
            "status": "pending",
            "testStrategy": "Test parseInstruction dispatches to correct handler for each instruction category. Test reset clears all state. Test getResult returns null for empty stack. Test nodeCount increments correctly across multiple parseInstruction calls. Test instruction matching is case-insensitive.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Contact and Output Instruction Parsers",
            "description": "Implement the parseContactInstruction method for LOAD/AND/OR contact instructions with stack operations, and parseOutputInstruction for OUT/SET/RST coil instructions.",
            "dependencies": [
              3
            ],
            "details": "Add contact and output parsing methods to InstructionParser class:\n\n1. Implement parseContactInstruction(row: CsvRow): ContactNode | null\n   - Parse device address from row.operand1 using parseDeviceAddress\n   - Return null if address is invalid\n   - Determine node type based on instruction suffix:\n     - No suffix or 'A' (LOADA) -> 'contact_no' (Normally Open)\n     - 'N' suffix (LOADN, ANDN, ORN) -> 'contact_nc' (Normally Closed)\n     - 'P' suffix (LOADP, ANDP, ORP) -> 'contact_p' (Positive edge)\n     - 'F' suffix (LOADF, ANDF, ORF) -> 'contact_n' (Negative/Falling edge)\n   - Create ContactNode with id, type, address, comment, gridPosition\n   - Handle stack operations based on instruction prefix:\n     - LOAD* prefix: Push node directly onto stack\n     - AND* prefix: Pop top of stack, create series BlockNode with [top, node], push block\n     - OR* prefix: Push node to pendingOr array\n   - Return the created ContactNode\n\n2. Implement parseOutputInstruction(row: CsvRow): CoilNode | null\n   - Parse device address from row.operand1\n   - Return null if address is invalid\n   - Determine node type based on instruction:\n     - 'OUT' or 'OUTN' -> 'coil_out'\n     - 'SET' -> 'coil_set' (Latch Set)\n     - 'RST' -> 'coil_rst' (Latch Reset)\n   - Create and return CoilNode\n   - Note: Output instructions don't modify the stack - they represent the end of a rung\n\n3. Implement parseOperand helper method for parsing numeric or address operands:\n   ```typescript\n   private parseOperand(operand: string | undefined): DeviceAddress | number | null\n   ```\n   - If operand is numeric (matches /^-?\\d+$/), return as number\n   - Otherwise, try parseDeviceAddress and return result",
            "status": "pending",
            "testStrategy": "Test LOAD creates contact_no and pushes to stack. Test LOADN creates contact_nc. Test LOADP/LOADF create edge-detecting contacts. Test AND instruction creates series BlockNode combining top of stack with new contact. Test OR instruction adds to pendingOr. Test OUT/SET/RST create correct coil types. Test invalid operands return null. Test parseOperand handles both numeric and address operands.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Block, Timer, Counter, Comparison, and Math Instruction Parsers",
            "description": "Complete the InstructionParser by implementing parseBlockInstruction for ANDB/ORB, and specialized instruction parsers for timers, counters, comparisons, and math operations.",
            "dependencies": [
              4
            ],
            "details": "Add remaining parsing methods to InstructionParser class:\n\n1. Implement parseBlockInstruction(row: CsvRow): BlockNode | null\n   - ANDB (AND Block): Pop two items from stack, create 'block_series' with [item1, item2], push result\n   - ORB (OR Block): Pop two items from stack, create 'block_parallel' with [item1, item2], push result\n   - Return the created BlockNode or null if insufficient stack items\n\n2. Implement parseTimerInstruction(row: CsvRow): TimerNode | null\n   - Parse address from operand1, preset value from operand2\n   - Determine type: 'timer_ton' (TON), 'timer_tof' (TOF), 'timer_tmr' (TMR)\n   - Default timeBase to 'ms'\n   - Create and return TimerNode\n\n3. Implement parseCounterInstruction(row: CsvRow): CounterNode | null\n   - Parse address from operand1, preset value from operand2\n   - Determine type: 'counter_ctu' (CTU), 'counter_ctd' (CTD), 'counter_ctud' (CTUD)\n   - Create and return CounterNode\n\n4. Implement parseComparisonInstruction(row: CsvRow): ComparisonNode | null\n   - Parse operand1 and operand2 using parseOperand helper\n   - Extract operator from instruction: '=', '<>', '>', '>=', '<', '<='\n   - Note: LS PLC comparison instructions like LD= have the operator embedded in the instruction name\n   - Create and return ComparisonNode\n\n5. Implement parseMathInstruction(row: CsvRow): MathNode | null\n   - Parse operand1 and optionally operand2 (MOV only has one source)\n   - Parse destination from operand2 (for MOV) or operand3 (for ADD/SUB/MUL/DIV)\n   - Set type: 'move' for MOV, 'math' for ADD/SUB/MUL/DIV\n   - Create and return MathNode\n\n6. Update getResult method to properly combine pendingOr items:\n   - While pendingOr has items, pop each and create 'block_parallel' with stack top\n   - Return final stack item or null\n\n7. Create index.ts barrel export file in src/components/OneParser/ exporting:\n   - InstructionParser class\n   - All types from types.ts\n   - All utilities from utils.ts",
            "status": "pending",
            "testStrategy": "Test ANDB pops two items and creates series block in correct order. Test ORB pops two items and creates parallel block. Test timer instructions create correct TimerNode with preset value. Test counter instructions create correct CounterNode types. Test comparison instructions extract operator correctly (LD= -> '=', LD<> -> '<>'). Test math instructions handle 3-operand format (ADD/SUB) and 2-operand format (MOV). Test getResult combines pendingOr items with stack. Test complex nested structure: LOAD-LOAD-ANDB-LOAD-ORB produces correct tree. Integration test parsing sequence of instructions to verify full parser workflow.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Subtasks: 1) Define AST node types for ladder elements 2) Implement stack-based series/parallel detection 3) Build tree structure from flat element list 4) Add validation and error reporting"
      },
      {
        "id": "65",
        "title": "Implement AST Builder and Grid Position Calculator",
        "description": "Create the AST builder that constructs LadderNetwork structures from parsed instructions and calculates grid positions for visualization.",
        "details": "Create `src/components/OneParser/AstBuilder.ts`:\n\n```typescript\nimport type { \n  CsvRow, LadderNetwork, LadderNode, LadderProgram, \n  ProgramMetadata, SymbolTable, GridPosition, BlockNode\n} from './types';\nimport { CsvReader } from './CsvReader';\nimport { InstructionParser } from './InstructionParser';\n\n/**\n * AST Builder for ladder logic programs\n */\nexport class AstBuilder {\n  private instructionParser: InstructionParser;\n  \n  constructor() {\n    this.instructionParser = new InstructionParser();\n  }\n  \n  /**\n   * Build complete ladder program from CSV content\n   */\n  buildProgram(csvContent: string, metadata?: Partial<ProgramMetadata>): LadderProgram {\n    const reader = new CsvReader(csvContent);\n    const rows = reader.readAllRows();\n    const groupedRows = reader.groupByStep(rows);\n    \n    const networks: LadderNetwork[] = [];\n    const symbolTable = this.buildSymbolTable(rows);\n    \n    // Process each network (step)\n    for (const [step, stepRows] of groupedRows) {\n      const network = this.buildNetwork(step, stepRows);\n      if (network) {\n        networks.push(network);\n      }\n    }\n    \n    return {\n      metadata: {\n        name: metadata?.name || 'Untitled Program',\n        description: metadata?.description,\n        author: metadata?.author,\n        createdAt: metadata?.createdAt || new Date().toISOString(),\n        modifiedAt: new Date().toISOString(),\n        version: '1.0',\n        ...metadata,\n      },\n      networks,\n      symbolTable,\n    };\n  }\n  \n  /**\n   * Build a single network from rows\n   */\n  private buildNetwork(step: number, rows: CsvRow[]): LadderNetwork | null {\n    this.instructionParser.reset();\n    \n    const nodes: LadderNode[] = [];\n    let networkComment: string | undefined;\n    \n    for (const row of rows) {\n      const node = this.instructionParser.parseInstruction(row);\n      if (node) {\n        nodes.push(node);\n      }\n      // Capture first comment as network comment\n      if (!networkComment && row.comment) {\n        networkComment = row.comment;\n      }\n    }\n    \n    // Get the final AST structure from the stack\n    const rootNode = this.instructionParser.getResult();\n    \n    // Calculate grid positions\n    if (rootNode) {\n      this.calculateGridPositions(rootNode, 0, 0);\n    }\n    \n    return {\n      id: `network_${step}`,\n      step,\n      nodes: rootNode ? this.flattenNodes(rootNode) : [],\n      comment: networkComment,\n    };\n  }\n  \n  /**\n   * Calculate grid positions for visualization\n   * \n   * Grid layout rules:\n   * - Series connections: nodes flow left to right (col++)\n   * - Parallel connections: branches stack vertically (row++)\n   * - Blocks take up space based on their children\n   */\n  private calculateGridPositions(node: LadderNode, startRow: number, startCol: number): { maxRow: number; maxCol: number } {\n    node.gridPosition = { row: startRow, col: startCol };\n    \n    if (node.type === 'block_series') {\n      const blockNode = node as BlockNode;\n      let currentCol = startCol;\n      let maxRow = startRow;\n      \n      for (const child of blockNode.children) {\n        const result = this.calculateGridPositions(child, startRow, currentCol);\n        currentCol = result.maxCol + 1;\n        maxRow = Math.max(maxRow, result.maxRow);\n      }\n      \n      return { maxRow, maxCol: currentCol - 1 };\n    }\n    \n    if (node.type === 'block_parallel') {\n      const blockNode = node as BlockNode;\n      let currentRow = startRow;\n      let maxCol = startCol;\n      \n      for (const child of blockNode.children) {\n        const result = this.calculateGridPositions(child, currentRow, startCol);\n        currentRow = result.maxRow + 1;\n        maxCol = Math.max(maxCol, result.maxCol);\n      }\n      \n      return { maxRow: currentRow - 1, maxCol };\n    }\n    \n    // Leaf node\n    return { maxRow: startRow, maxCol: startCol };\n  }\n  \n  /**\n   * Flatten nested block structure into array of nodes\n   */\n  private flattenNodes(node: LadderNode): LadderNode[] {\n    const nodes: LadderNode[] = [node];\n    \n    if (node.type === 'block_series' || node.type === 'block_parallel') {\n      const blockNode = node as BlockNode;\n      for (const child of blockNode.children) {\n        nodes.push(...this.flattenNodes(child));\n      }\n    }\n    \n    return nodes;\n  }\n  \n  /**\n   * Build symbol table from CSV rows\n   */\n  private buildSymbolTable(rows: CsvRow[]): SymbolTable {\n    const entries = new Map();\n    \n    for (const row of rows) {\n      // Extract addresses from operands\n      const operands = [row.operand1, row.operand2, row.operand3].filter(Boolean);\n      \n      for (const operand of operands) {\n        if (operand && operand.match(/^[A-Z]/i)) {\n          const { parseDeviceAddress, stringifyDeviceAddress } = require('./AddressParser');\n          const address = parseDeviceAddress(operand);\n          if (address) {\n            const key = stringifyDeviceAddress(address);\n            if (!entries.has(key)) {\n              entries.set(key, {\n                address,\n                comment: row.comment,\n              });\n            }\n          }\n        }\n      }\n    }\n    \n    return { entries };\n  }\n}\n```\n\nCreate `src/components/OneParser/GridCalculator.ts`:\n\n```typescript\nimport type { LadderNetwork, LadderNode, BlockNode, GridPosition } from './types';\n\n/**\n * Grid calculator for ladder visualization\n */\nexport class GridCalculator {\n  private gridWidth: number = 0;\n  private gridHeight: number = 0;\n  \n  /**\n   * Recalculate grid positions for a network\n   */\n  recalculate(network: LadderNetwork): { width: number; height: number } {\n    this.gridWidth = 0;\n    this.gridHeight = 0;\n    \n    for (const node of network.nodes) {\n      if (node.type !== 'block_series' && node.type !== 'block_parallel') {\n        this.gridWidth = Math.max(this.gridWidth, node.gridPosition.col + 1);\n        this.gridHeight = Math.max(this.gridHeight, node.gridPosition.row + 1);\n      }\n    }\n    \n    return { width: this.gridWidth, height: this.gridHeight };\n  }\n  \n  /**\n   * Get all nodes at a specific grid position\n   */\n  getNodesAt(network: LadderNetwork, row: number, col: number): LadderNode[] {\n    return network.nodes.filter(node => \n      node.gridPosition.row === row && \n      node.gridPosition.col === col &&\n      node.type !== 'block_series' && \n      node.type !== 'block_parallel'\n    );\n  }\n  \n  /**\n   * Check if a grid cell is occupied\n   */\n  isOccupied(network: LadderNetwork, row: number, col: number): boolean {\n    return this.getNodesAt(network, row, col).length > 0;\n  }\n}\n```",
        "testStrategy": "1. Test buildProgram creates valid LadderProgram structure\n2. Test network grouping by step number\n3. Test grid position calculation for series connections\n4. Test grid position calculation for parallel connections\n5. Test nested block grid calculations\n6. Test symbol table extraction from addresses\n7. Test flattenNodes returns all nodes",
        "priority": "high",
        "dependencies": [
          "64"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define LadderProgram, LadderNetwork, and Related Type Interfaces",
            "description": "Extend the OneParser types.ts file with LadderProgram, LadderNetwork, ProgramMetadata, and SymbolTable interfaces required by the AST builder.",
            "dependencies": [],
            "details": "Add to `src/components/OneParser/types.ts` the following type definitions:\n\n1. **ProgramMetadata interface:**\n   - name: string (program name)\n   - description?: string (optional description)\n   - author?: string (optional author)\n   - createdAt: string (ISO date string)\n   - modifiedAt: string (ISO date string)\n   - version: string (schema version, e.g., '1.0')\n\n2. **SymbolTableEntry interface:**\n   - address: DeviceAddress (device address)\n   - comment?: string (associated comment from CSV)\n   - symbolName?: string (optional custom symbol name)\n\n3. **SymbolTable interface:**\n   - entries: Map<string, SymbolTableEntry> (keyed by stringified address)\n\n4. **LadderNetwork interface:**\n   - id: string (e.g., 'network_0')\n   - step: number (step/rung number from CSV)\n   - nodes: LadderNode[] (all nodes including block structures)\n   - comment?: string (network-level comment)\n   - rootNode?: LadderNode (optional root of AST tree)\n\n5. **LadderProgram interface:**\n   - metadata: ProgramMetadata\n   - networks: LadderNetwork[]\n   - symbolTable: SymbolTable\n\nThese types follow the pattern established in `src/components/OneCanvas/types.ts` (lines 205-231) for similar metadata structures. Export all new types from the module.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation with `pnpm tsc --noEmit`. Create test instances of LadderProgram with nested LadderNetwork containing various node types. Test that SymbolTable Map operations work correctly. Verify type narrowing works for discriminated union types within nodes array.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement AstBuilder Class with Program Building Logic",
            "description": "Create the AstBuilder class that coordinates CSV parsing, network building, and program assembly using the InstructionParser from Task 64.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/OneParser/AstBuilder.ts` with the AstBuilder class:\n\n1. **Constructor:**\n   - Initialize private InstructionParser instance\n   - Store reference to be reused across networks\n\n2. **buildProgram(csvContent: string, metadata?: Partial<ProgramMetadata>): LadderProgram**\n   - Instantiate CsvReader with csvContent\n   - Call reader.readAllRows() to get all CsvRow[]\n   - Call reader.groupByStep(rows) to get Map<number, CsvRow[]>\n   - Build symbol table from all rows using buildSymbolTable()\n   - Iterate over grouped rows and call buildNetwork() for each step\n   - Assemble and return complete LadderProgram with:\n     - Merged metadata (defaults + provided values)\n     - All built networks\n     - Symbol table\n\n3. **private buildNetwork(step: number, rows: CsvRow[]): LadderNetwork | null**\n   - Reset instruction parser for fresh state\n   - Parse each row using instructionParser.parseInstruction()\n   - Collect parsed nodes into array\n   - Capture first non-empty comment as network comment\n   - Call instructionParser.getResult() for root AST node\n   - Return LadderNetwork structure with id, step, nodes, comment\n\n4. **private buildSymbolTable(rows: CsvRow[]): SymbolTable**\n   - Create empty Map for entries\n   - For each row, extract operand1, operand2, operand3\n   - Filter for device address strings (match /^[A-Z]/i)\n   - Parse each with parseDeviceAddress\n   - Add to Map with stringified address as key, capturing comment\n   - Return SymbolTable with entries Map\n\nFollow coding patterns from existing parsers in `src/components/ScenarioEditor/utils/csvParser.ts` and `src/components/ScenarioEditor/utils/addressParser.ts`.",
            "status": "pending",
            "testStrategy": "Test buildProgram with minimal CSV content creates valid LadderProgram. Test network grouping correctly separates by step number. Test symbol table extracts unique addresses from operands. Test metadata defaults are applied when partial metadata provided. Test empty CSV produces empty networks array.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Grid Position Calculation Algorithm",
            "description": "Add the recursive calculateGridPositions method to AstBuilder that assigns row/column coordinates to each node based on series/parallel connection structure.",
            "dependencies": [
              2
            ],
            "details": "Add grid position calculation methods to AstBuilder class:\n\n1. **private calculateGridPositions(node: LadderNode, startRow: number, startCol: number): { maxRow: number; maxCol: number }**\n   - Assign gridPosition = { row: startRow, col: startCol } to the node\n   - Handle 'block_series' type:\n     - Iterate children left-to-right\n     - Start first child at startCol\n     - For each subsequent child, start at previous maxCol + 1\n     - Track maximum row across all children\n     - Return { maxRow: max of all children maxRow, maxCol: final child maxCol }\n   - Handle 'block_parallel' type:\n     - Iterate children top-to-bottom\n     - Start first child at startRow\n     - For each subsequent child, start at previous maxRow + 1\n     - Track maximum column across all children\n     - Return { maxRow: final child maxRow, maxCol: max of all children maxCol }\n   - For leaf nodes (contacts, coils, timers, etc.):\n     - Simply return { maxRow: startRow, maxCol: startCol }\n\n2. **Grid Layout Rules:**\n   - Series (block_series): nodes flow left-to-right, col increases\n   - Parallel (block_parallel): branches stack vertically, row increases\n   - Nested blocks recursively calculate their own grid bounds\n   - Grid coordinates are 0-indexed\n\n3. **Update buildNetwork method:**\n   - After getting rootNode from instructionParser.getResult()\n   - If rootNode exists, call calculateGridPositions(rootNode, 0, 0)\n   - This populates gridPosition for all nodes in the tree\n\nThis follows similar recursive tree traversal patterns used in `src/components/OneCanvas/utils/circuitGraph.ts` for graph building.",
            "status": "pending",
            "testStrategy": "Test single contact node gets position (0,0). Test series of 3 contacts produces positions (0,0), (0,1), (0,2). Test parallel of 2 contacts produces positions (0,0), (1,0). Test nested series-in-parallel: outer parallel has 2 branches, each with 2 series contacts. Verify complex nested structures produce correct bounds. Test empty rootNode is handled gracefully.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement GridCalculator Utility Class",
            "description": "Create the GridCalculator class that provides utilities for working with network grid layouts including dimension calculation and node lookup by position.",
            "dependencies": [
              3
            ],
            "details": "Create `src/components/OneParser/GridCalculator.ts` with GridCalculator class:\n\n1. **Class Properties:**\n   - private gridWidth: number = 0\n   - private gridHeight: number = 0\n\n2. **recalculate(network: LadderNetwork): { width: number; height: number }**\n   - Reset gridWidth and gridHeight to 0\n   - Iterate through network.nodes\n   - For each non-block node (type !== 'block_series' && !== 'block_parallel'):\n     - Update gridWidth = max(gridWidth, node.gridPosition.col + 1)\n     - Update gridHeight = max(gridHeight, node.gridPosition.row + 1)\n   - Return { width: gridWidth, height: gridHeight }\n\n3. **getNodesAt(network: LadderNetwork, row: number, col: number): LadderNode[]**\n   - Filter network.nodes for nodes where:\n     - gridPosition.row === row\n     - gridPosition.col === col\n     - type is not 'block_series' or 'block_parallel' (skip container blocks)\n   - Return array of matching nodes (can be empty)\n\n4. **isOccupied(network: LadderNetwork, row: number, col: number): boolean**\n   - Return getNodesAt(network, row, col).length > 0\n\n5. **getAllPositions(network: LadderNetwork): GridPosition[]**\n   - Return array of unique gridPositions for all non-block nodes\n   - Useful for iteration over populated cells\n\n6. **getNodeAt(network: LadderNetwork, row: number, col: number): LadderNode | undefined**\n   - Return first node at position, or undefined\n   - Convenience wrapper around getNodesAt\n\nFollow utility patterns from `src/components/OneCanvas/utils/wirePathCalculator.ts` and `src/utils/gridUtils.ts`.",
            "status": "pending",
            "testStrategy": "Test recalculate returns correct dimensions for networks with various grid layouts. Test getNodesAt returns correct nodes at specified positions. Test getNodesAt returns empty array for unoccupied positions. Test isOccupied returns true/false correctly. Test getAllPositions returns all unique positions. Test that block nodes are excluded from position queries.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Node Flattening and Module Exports",
            "description": "Add the flattenNodes utility method to AstBuilder and create the module barrel export file for OneParser components.",
            "dependencies": [
              2,
              4
            ],
            "details": "Complete the AstBuilder implementation and create module exports:\n\n1. **Add flattenNodes method to AstBuilder class:**\n   ```typescript\n   private flattenNodes(node: LadderNode): LadderNode[]\n   ```\n   - Create nodes array starting with [node]\n   - If node.type is 'block_series' or 'block_parallel':\n     - Cast node to BlockNode\n     - For each child in blockNode.children:\n       - Recursively call flattenNodes(child)\n       - Spread results into nodes array\n   - Return flattened nodes array\n   - This produces a flat list including block containers and all descendants\n\n2. **Update buildNetwork to use flattenNodes:**\n   - After calculating grid positions:\n   - Set network.nodes = rootNode ? this.flattenNodes(rootNode) : []\n   - Store rootNode optionally in network.rootNode for tree traversal if needed\n\n3. **Create `src/components/OneParser/index.ts` barrel export:**\n   ```typescript\n   export { AstBuilder } from './AstBuilder';\n   export { GridCalculator } from './GridCalculator';\n   export { CsvReader } from './CsvReader';\n   export { InstructionParser } from './InstructionParser';\n   export * from './types';\n   export * from './utils';\n   // Export AddressParser functions\n   export { parseDeviceAddress, stringifyDeviceAddress, isBitDevice, isWordDevice, isAddressInRange } from './AddressParser';\n   ```\n\n4. **Add TypeScript documentation comments:**\n   - Add JSDoc comments to AstBuilder class and public methods\n   - Document GridCalculator methods\n   - Include @param and @returns annotations\n\nFollow barrel export patterns from `src/components/OneCanvas/index.ts` and `src/components/ScenarioEditor/index.ts`.",
            "status": "pending",
            "testStrategy": "Test flattenNodes on single leaf node returns array with that node. Test flattenNodes on series block with 3 children returns 4 nodes (block + 3 children). Test flattenNodes on nested structure returns all nodes at all levels. Test barrel exports are accessible: import { AstBuilder, GridCalculator } from '@/components/OneParser'. Verify TypeScript compilation succeeds with all exports.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Subtasks: 1) Implement address-to-Modbus type resolution using scenario.ts patterns 2) Create range allocation algorithm 3) Add conflict detection and validation"
      },
      {
        "id": "66",
        "title": "Implement Modbus Address Mapper",
        "description": "Create the Modbus address mapping module that converts LS PLC device addresses to Modbus addresses according to the defined mapping rules.",
        "details": "Create `src/components/OneParser/ModbusMapper.ts`:\n\n```typescript\nimport type { \n  DeviceAddress, DeviceType, ModbusAddress, ModbusAddressType, MappingRule \n} from './types';\nimport { isBitDevice, isWordDevice } from './AddressParser';\n\n/**\n * Default Modbus mapping rules for LS PLC devices\n */\nexport const DEFAULT_MAPPING_RULES: MappingRule[] = [\n  // Bit devices\n  { device: 'P', modbusType: 'discrete', offset: 0 },      // Input Relay -> Discrete Input\n  { device: 'M', modbusType: 'coil', offset: 0 },          // Auxiliary Relay -> Coil\n  { device: 'K', modbusType: 'coil', offset: 8192 },       // Keep Relay -> Coil (offset)\n  { device: 'T', modbusType: 'coil', offset: 10240 },      // Timer Contact -> Coil (read-only)\n  { device: 'C', modbusType: 'coil', offset: 12288 },      // Counter Contact -> Coil (read-only)\n  { device: 'F', modbusType: 'discrete', offset: 2048 },   // Special Relay -> Discrete Input (read-only)\n  \n  // Word devices\n  { device: 'D', modbusType: 'holding', offset: 0 },       // Data Register -> Holding Register\n  { device: 'R', modbusType: 'holding', offset: 10000 },   // File Register -> Holding Register\n  { device: 'Z', modbusType: 'holding', offset: 20000 },   // Index Register -> Holding Register\n  { device: 'N', modbusType: 'holding', offset: 20016 },   // Link Data Register -> Holding Register\n];\n\n/**\n * Special device addresses for timer/counter current values\n */\nexport const SPECIAL_MAPPINGS = {\n  TD: { modbusType: 'holding' as ModbusAddressType, offset: 28208 },  // Timer current value\n  CD: { modbusType: 'holding' as ModbusAddressType, offset: 30256 },  // Counter current value\n};\n\n/**\n * Modbus Address Mapper\n */\nexport class ModbusMapper {\n  private rules: Map<DeviceType, MappingRule>;\n  \n  constructor(customRules?: MappingRule[]) {\n    this.rules = new Map();\n    \n    // Initialize with default rules\n    for (const rule of DEFAULT_MAPPING_RULES) {\n      this.rules.set(rule.device, rule);\n    }\n    \n    // Override with custom rules if provided\n    if (customRules) {\n      for (const rule of customRules) {\n        this.rules.set(rule.device, rule);\n      }\n    }\n  }\n  \n  /**\n   * Map device address to Modbus address\n   */\n  mapToModbus(deviceAddr: DeviceAddress): ModbusAddress | null {\n    const rule = this.rules.get(deviceAddr.device);\n    if (!rule) {\n      return null;\n    }\n    \n    // Handle indexed addressing - cannot be mapped statically\n    if (deviceAddr.indexRegister !== undefined) {\n      console.warn(`Indexed address ${deviceAddr.device}[Z${deviceAddr.indexRegister}] cannot be mapped statically`);\n      return null;\n    }\n    \n    // Handle bit access on word devices\n    if (deviceAddr.bitIndex !== undefined && isWordDevice(deviceAddr.device)) {\n      // Word device bit access maps to coil area\n      // Address = (word_offset * 16) + bit_index\n      const wordOffset = rule.offset + deviceAddr.address;\n      return {\n        type: 'coil',\n        address: wordOffset * 16 + deviceAddr.bitIndex,\n      };\n    }\n    \n    return {\n      type: rule.modbusType,\n      address: rule.offset + deviceAddr.address,\n    };\n  }\n  \n  /**\n   * Map Modbus address back to device address\n   * Note: This may return multiple possible matches for overlapping ranges\n   */\n  mapFromModbus(modbusAddr: ModbusAddress): DeviceAddress[] {\n    const matches: DeviceAddress[] = [];\n    \n    for (const [device, rule] of this.rules) {\n      if (rule.modbusType === modbusAddr.type) {\n        const deviceAddress = modbusAddr.address - rule.offset;\n        if (deviceAddress >= 0) {\n          matches.push({\n            device,\n            address: deviceAddress,\n          });\n        }\n      }\n    }\n    \n    return matches;\n  }\n  \n  /**\n   * Map timer current value address (TD)\n   */\n  mapTimerDataToModbus(timerNumber: number): ModbusAddress {\n    return {\n      type: 'holding',\n      address: SPECIAL_MAPPINGS.TD.offset + timerNumber,\n    };\n  }\n  \n  /**\n   * Map counter current value address (CD)\n   */\n  mapCounterDataToModbus(counterNumber: number): ModbusAddress {\n    return {\n      type: 'holding',\n      address: SPECIAL_MAPPINGS.CD.offset + counterNumber,\n    };\n  }\n  \n  /**\n   * Get the mapping rule for a device type\n   */\n  getRule(device: DeviceType): MappingRule | undefined {\n    return this.rules.get(device);\n  }\n  \n  /**\n   * Check if a device address is read-only\n   */\n  isReadOnly(deviceAddr: DeviceAddress): boolean {\n    // F (Special Relay), T (Timer Contact), C (Counter Contact) are read-only\n    return ['F', 'T', 'C'].includes(deviceAddr.device);\n  }\n}\n\n/**\n * Format Modbus address for display\n */\nexport function formatModbusAddress(addr: ModbusAddress): string {\n  const prefix = {\n    'coil': 'C',\n    'discrete': 'DI',\n    'holding': 'HR',\n    'input': 'IR',\n  }[addr.type];\n  \n  return `${prefix}:${addr.address}`;\n}\n\n/**\n * Parse Modbus address string\n */\nexport function parseModbusAddress(str: string): ModbusAddress | null {\n  const match = str.match(/^(C|DI|HR|IR):(\\d+)$/i);\n  if (!match) return null;\n  \n  const typeMap: Record<string, ModbusAddressType> = {\n    'C': 'coil',\n    'DI': 'discrete',\n    'HR': 'holding',\n    'IR': 'input',\n  };\n  \n  return {\n    type: typeMap[match[1].toUpperCase()],\n    address: parseInt(match[2], 10),\n  };\n}\n```",
        "testStrategy": "1. Test P device maps to discrete input with offset 0\n2. Test M device maps to coil with offset 0\n3. Test K device maps to coil with offset 8192\n4. Test D device maps to holding register with offset 0\n5. Test bit access on word device (D0000.5)\n6. Test timer/counter data address mapping (TD, CD)\n7. Test reverse mapping from Modbus to device\n8. Test read-only device detection\n9. Test indexed address returns null (cannot map statically)",
        "priority": "medium",
        "dependencies": [
          "63"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Modbus mapping types and interfaces in OneParser types.ts",
            "description": "Extend the OneParser types.ts file with ModbusAddress, ModbusAddressType, and MappingRule interfaces required by the ModbusMapper module.",
            "dependencies": [],
            "details": "Add the following type definitions to `src/components/OneParser/types.ts`:\n\n1. **ModbusAddressType**: A union type `'coil' | 'discrete' | 'holding' | 'input'` representing the four Modbus memory areas.\n\n2. **ModbusAddress interface**: Contains `type: ModbusAddressType` and `address: number` to represent a mapped Modbus address.\n\n3. **MappingRule interface**: Contains `device: DeviceType`, `modbusType: ModbusAddressType`, and `offset: number` to define how each PLC device type maps to Modbus addresses.\n\nThese types integrate with the existing `DeviceAddress` and `DeviceType` types from Task 63's AddressParser. The types align with the existing `MemoryType` in `src/types/modbus.ts` for consistency across the codebase.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation passes with `pnpm tsc --noEmit`. Create test instances of each type to confirm type compatibility. Verify ModbusAddressType is compatible with existing MemoryType from src/types/modbus.ts.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement DEFAULT_MAPPING_RULES and SPECIAL_MAPPINGS constants",
            "description": "Create the default mapping rules array for standard LS PLC devices and special mappings for timer/counter current values in ModbusMapper.ts.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/OneParser/ModbusMapper.ts` and define:\n\n1. **DEFAULT_MAPPING_RULES array**: Export an array of MappingRule objects defining:\n   - Bit devices: P→discrete(0), M→coil(0), K→coil(8192), T→coil(10240), C→coil(12288), F→discrete(2048)\n   - Word devices: D→holding(0), R→holding(10000), Z→holding(20000), N→holding(20016)\n\n2. **SPECIAL_MAPPINGS object**: Export an object defining:\n   - TD (Timer Data): `{ modbusType: 'holding', offset: 28208 }` for timer current values\n   - CD (Counter Data): `{ modbusType: 'holding', offset: 30256 }` for counter current values\n\nInclude JSDoc comments explaining each mapping rule according to LS PLC documentation from PRD_Unit7_OneParser.md.",
            "status": "pending",
            "testStrategy": "Test that DEFAULT_MAPPING_RULES contains all 10 expected device types. Test that SPECIAL_MAPPINGS.TD.offset equals 28208 and SPECIAL_MAPPINGS.CD.offset equals 30256. Verify offset values match PRD specification.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement ModbusMapper class with mapToModbus method",
            "description": "Create the ModbusMapper class with constructor for rule initialization and the primary mapToModbus method for device-to-Modbus address conversion.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement the ModbusMapper class in `src/components/OneParser/ModbusMapper.ts`:\n\n1. **Private rules Map**: `Map<DeviceType, MappingRule>` for O(1) rule lookups.\n\n2. **Constructor**: Accept optional `customRules?: MappingRule[]` parameter. Initialize with DEFAULT_MAPPING_RULES, then override with custom rules if provided.\n\n3. **mapToModbus method**: `mapToModbus(deviceAddr: DeviceAddress): ModbusAddress | null`\n   - Return null if no rule exists for device type\n   - Return null with console.warn for indexed addressing (indexRegister !== undefined)\n   - Handle bit access on word devices: calculate `(wordOffset * 16) + bitIndex` mapping to coil area\n   - Standard mapping: apply `rule.offset + deviceAddr.address`\n\nImport `isBitDevice`, `isWordDevice` from AddressParser.ts (dependency from Task 63).",
            "status": "pending",
            "testStrategy": "Test P0001 maps to discrete input address 1. Test M0001 maps to coil address 1. Test K0001 maps to coil address 8193 (8192+1). Test D0000 maps to holding register address 0. Test D0001.5 maps to coil address 21 (1*16+5). Test D[Z0] returns null with console.warn.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement reverse mapping and specialized mapping methods",
            "description": "Add mapFromModbus for reverse mapping, mapTimerDataToModbus, mapCounterDataToModbus for special addresses, getRule for rule access, and isReadOnly for write protection.",
            "dependencies": [
              3
            ],
            "details": "Extend the ModbusMapper class with additional methods:\n\n1. **mapFromModbus**: `mapFromModbus(modbusAddr: ModbusAddress): DeviceAddress[]`\n   - Iterate through all rules matching modbusType\n   - Calculate potential device addresses by subtracting offset\n   - Return all valid matches (address >= 0) as DeviceAddress array\n   - Note: May return multiple matches for overlapping ranges\n\n2. **mapTimerDataToModbus**: `mapTimerDataToModbus(timerNumber: number): ModbusAddress`\n   - Return `{ type: 'holding', address: SPECIAL_MAPPINGS.TD.offset + timerNumber }`\n\n3. **mapCounterDataToModbus**: `mapCounterDataToModbus(counterNumber: number): ModbusAddress`\n   - Return `{ type: 'holding', address: SPECIAL_MAPPINGS.CD.offset + counterNumber }`\n\n4. **getRule**: `getRule(device: DeviceType): MappingRule | undefined`\n\n5. **isReadOnly**: `isReadOnly(deviceAddr: DeviceAddress): boolean`\n   - Return true for F (Special Relay), T (Timer Contact), C (Counter Contact)",
            "status": "pending",
            "testStrategy": "Test mapFromModbus(coil:0) returns M0000. Test mapFromModbus(coil:8192) returns both M8192 and K0000. Test mapTimerDataToModbus(0) returns holding:28208. Test mapCounterDataToModbus(100) returns holding:30356. Test isReadOnly returns true for F, T, C devices and false for M, D, P devices.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement formatModbusAddress and parseModbusAddress utility functions",
            "description": "Create standalone utility functions for formatting Modbus addresses to display strings and parsing display strings back to ModbusAddress objects.",
            "dependencies": [
              1
            ],
            "details": "Add the following exported functions to `src/components/OneParser/ModbusMapper.ts`:\n\n1. **formatModbusAddress**: `formatModbusAddress(addr: ModbusAddress): string`\n   - Map type to prefix: coil→'C', discrete→'DI', holding→'HR', input→'IR'\n   - Return format: `${prefix}:${addr.address}` (e.g., 'HR:1000', 'C:8192')\n\n2. **parseModbusAddress**: `parseModbusAddress(str: string): ModbusAddress | null`\n   - Parse format: `/^(C|DI|HR|IR):(\\d+)$/i`\n   - Map prefix to type: 'C'→coil, 'DI'→discrete, 'HR'→holding, 'IR'→input\n   - Return null for invalid format\n\nEnsure consistency with existing address formatting patterns in `src/types/scenario.ts` (uses 'H:' for holding) but follow the task specification using 'HR:' prefix. Add module exports in index barrel file.",
            "status": "pending",
            "testStrategy": "Test formatModbusAddress({type:'holding', address:1000}) returns 'HR:1000'. Test formatModbusAddress({type:'coil', address:0}) returns 'C:0'. Test parseModbusAddress('HR:1000') returns {type:'holding', address:1000}. Test parseModbusAddress('c:100') returns {type:'coil', address:100} (case insensitive). Test parseModbusAddress('INVALID') returns null.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Create orchestrator that coordinates CSV parser, address parser, AST builder, and Modbus mapper with progress reporting and error aggregation"
      },
      {
        "id": "67",
        "title": "Implement Tauri Parser Commands and Rust Backend",
        "description": "Create the Tauri command handlers for CSV parsing, address conversion, and program management with the Rust backend implementation.",
        "details": "Create `src-tauri/src/parser/mod.rs`:\n\n```rust\npub mod ast;\npub mod commands;\npub mod csv_parser;\npub mod grid;\npub mod instruction;\npub mod modbus_mapper;\npub mod symbol_table;\npub mod validator;\n\npub use commands::*;\n```\n\nCreate `src-tauri/src/parser/commands.rs`:\n\n```rust\nuse crate::parser::csv_parser::CsvReader;\nuse crate::parser::ast::{AstBuilder, LadderProgram};\nuse crate::parser::modbus_mapper::{ModbusMapper, ModbusAddress};\nuse crate::parser::validator::ProgramValidator;\nuse crate::error::ModOneResult;\nuse std::fs;\nuse std::io::BufReader;\n\n/// Parse CSV file and return LadderProgram\n#[tauri::command]\npub async fn parser_parse_csv(path: String) -> ModOneResult<LadderProgram> {\n    let file = fs::File::open(&path)?;\n    let reader = BufReader::new(file);\n    let mut csv_reader = CsvReader::new(reader);\n    \n    let rows = csv_reader.read_all()?;\n    let builder = AstBuilder::new();\n    let program = builder.build_from_rows(rows)?;\n    \n    Ok(program)\n}\n\n/// Parse CSV string content and return LadderProgram\n#[tauri::command]\npub async fn parser_parse_csv_string(content: String) -> ModOneResult<LadderProgram> {\n    let reader = BufReader::new(content.as_bytes());\n    let mut csv_reader = CsvReader::new(reader);\n    \n    let rows = csv_reader.read_all()?;\n    let builder = AstBuilder::new();\n    let program = builder.build_from_rows(rows)?;\n    \n    Ok(program)\n}\n\n/// Validate a ladder program\n#[tauri::command]\npub async fn parser_validate_program(program: LadderProgram) -> ModOneResult<ValidationResult> {\n    let validator = ProgramValidator::new();\n    let result = validator.validate(&program);\n    Ok(result)\n}\n\n/// Map device address to Modbus address\n#[tauri::command]\npub async fn parser_map_address_to_modbus(device_address: String) -> ModOneResult<Option<ModbusAddress>> {\n    let mapper = ModbusMapper::default();\n    let device_addr = crate::parser::ast::parse_device_address(&device_address)?;\n    Ok(mapper.map_to_modbus(&device_addr))\n}\n\n/// Map Modbus address to device address(es)\n#[tauri::command]\npub async fn parser_map_modbus_to_address(modbus_address: ModbusAddress) -> ModOneResult<Vec<String>> {\n    let mapper = ModbusMapper::default();\n    let addresses = mapper.map_from_modbus(&modbus_address);\n    Ok(addresses.into_iter().map(|a| a.to_string()).collect())\n}\n\n/// Convert LadderProgram back to CSV format\n#[tauri::command]\npub async fn parser_program_to_csv(program: LadderProgram) -> ModOneResult<String> {\n    let builder = AstBuilder::new();\n    let csv = builder.to_csv(&program)?;\n    Ok(csv)\n}\n\n/// Save program to file\n#[tauri::command]\npub async fn parser_save_program(path: String, program: LadderProgram) -> ModOneResult<()> {\n    let json = serde_json::to_string_pretty(&program)?;\n    fs::write(&path, json)?;\n    Ok(())\n}\n\n/// Load program from file\n#[tauri::command]\npub async fn parser_load_program(path: String) -> ModOneResult<LadderProgram> {\n    let content = fs::read_to_string(&path)?;\n    let program: LadderProgram = serde_json::from_str(&content)?;\n    Ok(program)\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct ValidationResult {\n    pub valid: bool,\n    pub errors: Vec<ValidationError>,\n    pub warnings: Vec<ValidationWarning>,\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct ValidationError {\n    pub network_id: String,\n    pub node_id: Option<String>,\n    pub message: String,\n    pub error_type: String,\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct ValidationWarning {\n    pub network_id: String,\n    pub node_id: Option<String>,\n    pub message: String,\n    pub warning_type: String,\n}\n```\n\nUpdate `src-tauri/src/commands/mod.rs` to include parser commands:\n\n```rust\npub mod parser;\npub use parser::*;\n```\n\nUpdate `src-tauri/src/lib.rs` to register commands:\n\n```rust\npub mod parser;\n\n// In run() function, add to invoke_handler:\nparser_parse_csv,\nparser_parse_csv_string,\nparser_validate_program,\nparser_map_address_to_modbus,\nparser_map_modbus_to_address,\nparser_program_to_csv,\nparser_save_program,\nparser_load_program,\n```\n\nCreate TypeScript service `src/services/parserService.ts`:\n\n```typescript\nimport { invoke } from '@tauri-apps/api/core';\nimport type { LadderProgram, ModbusAddress } from '../components/OneParser/types';\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: ValidationError[];\n  warnings: ValidationWarning[];\n}\n\nexport interface ValidationError {\n  networkId: string;\n  nodeId?: string;\n  message: string;\n  errorType: string;\n}\n\nexport interface ValidationWarning {\n  networkId: string;\n  nodeId?: string;\n  message: string;\n  warningType: string;\n}\n\nexport const parserService = {\n  async parseCsv(path: string): Promise<LadderProgram> {\n    return invoke('parser_parse_csv', { path });\n  },\n  \n  async parseCsvString(content: string): Promise<LadderProgram> {\n    return invoke('parser_parse_csv_string', { content });\n  },\n  \n  async validateProgram(program: LadderProgram): Promise<ValidationResult> {\n    return invoke('parser_validate_program', { program });\n  },\n  \n  async mapAddressToModbus(deviceAddress: string): Promise<ModbusAddress | null> {\n    return invoke('parser_map_address_to_modbus', { deviceAddress });\n  },\n  \n  async mapModbusToAddress(modbusAddress: ModbusAddress): Promise<string[]> {\n    return invoke('parser_map_modbus_to_address', { modbusAddress });\n  },\n  \n  async programToCsv(program: LadderProgram): Promise<string> {\n    return invoke('parser_program_to_csv', { program });\n  },\n  \n  async saveProgram(path: string, program: LadderProgram): Promise<void> {\n    return invoke('parser_save_program', { path, program });\n  },\n  \n  async loadProgram(path: string): Promise<LadderProgram> {\n    return invoke('parser_load_program', { path });\n  },\n};\n```",
        "testStrategy": "1. Test parser_parse_csv with sample XG5000 CSV file\n2. Test parser_parse_csv_string with inline CSV content\n3. Test parser_validate_program returns validation results\n4. Test address mapping commands\n5. Test program save/load round-trip\n6. Test CSV reverse conversion produces valid output\n7. Test error handling for invalid files/content",
        "priority": "high",
        "dependencies": [
          "65",
          "66"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Parser Module Structure and Core Types",
            "description": "Create the parser module directory structure and define core Rust types for LadderProgram, LadderNetwork, LadderNode, and related AST structures with serde serialization support.",
            "dependencies": [],
            "details": "Create `src-tauri/src/parser/mod.rs` with submodule declarations (ast, commands, csv_parser, grid, instruction, modbus_mapper, symbol_table, validator). Create `src-tauri/src/parser/ast.rs` with core types: LadderProgram, LadderNetwork, LadderNode (enum for Contact, Coil, Timer, Counter, Block), DeviceAddress, and associated parsing functions. All types must derive Serialize, Deserialize, Debug, Clone. Add parser error types to the existing ModOneError enum in error.rs including ParserError, CsvParseError, ValidationError variants.",
            "status": "pending",
            "testStrategy": "Unit test that LadderProgram can be serialized to JSON and deserialized back. Test DeviceAddress parsing for various formats (P00001, M00100, D00000.5). Verify all types implement required traits.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement CSV Parser for XG5000 Ladder Export Format",
            "description": "Implement the CsvReader struct that parses XG5000 CSV export files and converts rows into structured data that can be processed by AstBuilder.",
            "dependencies": [
              1
            ],
            "details": "Create `src-tauri/src/parser/csv_parser.rs` implementing CsvReader<R: Read> with methods: new(reader), read_all() -> Result<Vec<CsvRow>>. CsvRow should capture all fields from XG5000 export format (network ID, row, column, instruction, operands). Use the existing csv crate dependency. Handle CSV header detection and validation. Implement reverse conversion: to_csv(program: &LadderProgram) -> Result<String> for round-trip support. Add proper error handling for malformed CSV data.",
            "status": "pending",
            "testStrategy": "Test parsing a sample XG5000 CSV file with multiple networks and instructions. Test error handling for missing columns, invalid data types. Test round-trip: parse CSV -> build program -> write CSV -> compare with original structure.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement AstBuilder and Modbus Mapper",
            "description": "Create AstBuilder for constructing LadderProgram from CSV rows, and ModbusMapper for device address to Modbus address conversion with bidirectional mapping support.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src-tauri/src/parser/ast.rs` AstBuilder with: new(), build_from_rows(Vec<CsvRow>) -> Result<LadderProgram>, to_csv(&LadderProgram) -> Result<String>. Create `src-tauri/src/parser/modbus_mapper.rs` with ModbusMapper implementing DEFAULT_MAPPING_RULES for LS PLC devices: P->discrete(offset 0), M->coil(offset 0), K->coil(offset 8192), D->holding(offset 0). Implement map_to_modbus(&DeviceAddress) -> Option<ModbusAddress> and map_from_modbus(&ModbusAddress) -> Vec<DeviceAddress>. Handle bit access on word devices (D0000.5).",
            "status": "pending",
            "testStrategy": "Test AstBuilder constructs valid program from CSV rows. Test P device maps to discrete input, M to coil, D to holding register. Test bit access mapping for D0000.5. Test reverse mapping from Modbus address back to device address.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Tauri Command Handlers for Parser Operations",
            "description": "Create the Tauri command handlers in commands.rs that expose parser functionality to the frontend including CSV parsing, validation, address mapping, and program save/load operations.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create `src-tauri/src/parser/commands.rs` with 8 async Tauri commands: parser_parse_csv(path) reads file and returns LadderProgram, parser_parse_csv_string(content) parses inline CSV, parser_validate_program(program) returns ValidationResult, parser_map_address_to_modbus(address) returns Option<ModbusAddress>, parser_map_modbus_to_address(address) returns Vec<String>, parser_program_to_csv(program) returns CSV string, parser_save_program(path, program) saves JSON, parser_load_program(path) loads JSON. Update src-tauri/src/commands/mod.rs to include parser module. Update src-tauri/src/lib.rs to register all parser commands in invoke_handler.",
            "status": "pending",
            "testStrategy": "Integration test parser_parse_csv with real XG5000 export file. Test parser_parse_csv_string with inline CSV content. Test validation returns proper errors for invalid programs. Test save/load round-trip preserves program structure.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create TypeScript ParserService and Types",
            "description": "Create the TypeScript service layer that wraps Tauri parser commands and provides typed interfaces for frontend components to interact with the parser backend.",
            "dependencies": [
              4
            ],
            "details": "Create `src/components/OneParser/types.ts` with TypeScript interfaces matching Rust types: LadderProgram, LadderNetwork, LadderNode (union type), DeviceAddress, ModbusAddress, ValidationResult, ValidationError, ValidationWarning. Create `src/services/parserService.ts` using @tauri-apps/api/core invoke() with methods: parseCsv(path), parseCsvString(content), validateProgram(program), mapAddressToModbus(address), mapModbusToAddress(address), programToCsv(program), saveProgram(path, program), loadProgram(path). Export from services/index.ts. Ensure all types are properly exported for use by OneParser components.",
            "status": "pending",
            "testStrategy": "Type checking passes with TypeScript strict mode. Test service methods can invoke backend commands without type errors. Verify error handling propagates backend errors correctly to frontend.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement Tauri commands for parsing operations following patterns in src-tauri/src/commands/scenario.rs"
      },
      {
        "id": "68",
        "title": "Implement Program Validator and Error Handling",
        "description": "Create a comprehensive validator for ladder programs that checks for syntax errors, address conflicts, and logical issues.",
        "details": "Create `src/components/OneParser/Validator.ts`:\n\n```typescript\nimport type { \n  LadderProgram, LadderNetwork, LadderNode, DeviceAddress,\n  ContactNode, CoilNode, TimerNode, CounterNode, BlockNode\n} from './types';\nimport { isAddressInRange, stringifyDeviceAddress } from './AddressParser';\n\nexport interface ValidationError {\n  networkId: string;\n  nodeId?: string;\n  message: string;\n  errorType: 'syntax' | 'address' | 'logic' | 'structure';\n  severity: 'error' | 'warning';\n}\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: ValidationError[];\n  warnings: ValidationError[];\n}\n\n/**\n * Ladder Program Validator\n */\nexport class ProgramValidator {\n  private errors: ValidationError[] = [];\n  private warnings: ValidationError[] = [];\n  private usedOutputs: Map<string, string> = new Map();  // address -> network that uses it\n  \n  /**\n   * Validate a complete ladder program\n   */\n  validate(program: LadderProgram): ValidationResult {\n    this.errors = [];\n    this.warnings = [];\n    this.usedOutputs.clear();\n    \n    // Validate each network\n    for (const network of program.networks) {\n      this.validateNetwork(network);\n    }\n    \n    // Check for global issues\n    this.checkDuplicateOutputs();\n    \n    return {\n      valid: this.errors.length === 0,\n      errors: this.errors.filter(e => e.severity === 'error'),\n      warnings: this.errors.filter(e => e.severity === 'warning').concat(this.warnings),\n    };\n  }\n  \n  /**\n   * Validate a single network\n   */\n  private validateNetwork(network: LadderNetwork): void {\n    // Check for empty network\n    if (network.nodes.length === 0) {\n      this.addWarning(network.id, undefined, 'Empty network', 'structure');\n      return;\n    }\n    \n    // Validate each node\n    for (const node of network.nodes) {\n      this.validateNode(network.id, node);\n    }\n    \n    // Check for output instruction\n    const hasOutput = network.nodes.some(n => \n      ['coil_out', 'coil_set', 'coil_rst', 'timer_ton', 'timer_tof', 'timer_tmr',\n       'counter_ctu', 'counter_ctd', 'counter_ctud'].includes(n.type)\n    );\n    \n    if (!hasOutput) {\n      this.addWarning(network.id, undefined, 'Network has no output instruction', 'structure');\n    }\n  }\n  \n  /**\n   * Validate a single node\n   */\n  private validateNode(networkId: string, node: LadderNode): void {\n    // Validate address if present\n    if ('address' in node && node.address) {\n      this.validateAddress(networkId, node.id, node.address);\n    }\n    \n    // Type-specific validation\n    switch (node.type) {\n      case 'contact_no':\n      case 'contact_nc':\n      case 'contact_p':\n      case 'contact_n':\n        this.validateContact(networkId, node as ContactNode);\n        break;\n        \n      case 'coil_out':\n      case 'coil_set':\n      case 'coil_rst':\n        this.validateCoil(networkId, node as CoilNode);\n        break;\n        \n      case 'timer_ton':\n      case 'timer_tof':\n      case 'timer_tmr':\n        this.validateTimer(networkId, node as TimerNode);\n        break;\n        \n      case 'counter_ctu':\n      case 'counter_ctd':\n      case 'counter_ctud':\n        this.validateCounter(networkId, node as CounterNode);\n        break;\n        \n      case 'block_series':\n      case 'block_parallel':\n        this.validateBlock(networkId, node as BlockNode);\n        break;\n    }\n  }\n  \n  /**\n   * Validate device address\n   */\n  private validateAddress(networkId: string, nodeId: string, address: DeviceAddress): void {\n    // Check address range\n    if (!isAddressInRange(address.device, address.address)) {\n      this.addError(networkId, nodeId, \n        `Address ${stringifyDeviceAddress(address)} is out of range`, 'address');\n    }\n    \n    // Check bit index for word devices\n    if (address.bitIndex !== undefined) {\n      if (address.bitIndex < 0 || address.bitIndex > 15) {\n        this.addError(networkId, nodeId, \n          `Bit index ${address.bitIndex} is out of range (0-15)`, 'address');\n      }\n    }\n    \n    // Check index register range\n    if (address.indexRegister !== undefined) {\n      if (address.indexRegister < 0 || address.indexRegister > 15) {\n        this.addError(networkId, nodeId, \n          `Index register Z${address.indexRegister} is out of range (0-15)`, 'address');\n      }\n    }\n  }\n  \n  private validateContact(networkId: string, node: ContactNode): void {\n    // Contacts can use any bit device or word device with bit access\n    const device = node.address.device;\n    if (!['P', 'M', 'K', 'F', 'T', 'C'].includes(device) && \n        node.address.bitIndex === undefined) {\n      this.addWarning(networkId, node.id, \n        `Contact using word device ${device} without bit access`, 'logic');\n    }\n  }\n  \n  private validateCoil(networkId: string, node: CoilNode): void {\n    const device = node.address.device;\n    \n    // Coils should output to writable devices (M, K)\n    if (!['M', 'K'].includes(device)) {\n      if (['P', 'F', 'T', 'C'].includes(device)) {\n        this.addError(networkId, node.id, \n          `Cannot write to read-only device ${device}`, 'logic');\n      }\n    }\n    \n    // Track used outputs for duplicate detection\n    const addrKey = stringifyDeviceAddress(node.address);\n    this.usedOutputs.set(addrKey, networkId);\n  }\n  \n  private validateTimer(networkId: string, node: TimerNode): void {\n    // Timer must use T device\n    if (node.address.device !== 'T') {\n      this.addError(networkId, node.id, \n        `Timer must use T device, not ${node.address.device}`, 'logic');\n    }\n    \n    // Preset must be positive\n    if (node.preset <= 0) {\n      this.addWarning(networkId, node.id, \n        'Timer preset should be positive', 'logic');\n    }\n  }\n  \n  private validateCounter(networkId: string, node: CounterNode): void {\n    // Counter must use C device\n    if (node.address.device !== 'C') {\n      this.addError(networkId, node.id, \n        `Counter must use C device, not ${node.address.device}`, 'logic');\n    }\n    \n    // Preset must be positive\n    if (node.preset <= 0) {\n      this.addWarning(networkId, node.id, \n        'Counter preset should be positive', 'logic');\n    }\n  }\n  \n  private validateBlock(networkId: string, node: BlockNode): void {\n    // Block must have at least 2 children\n    if (node.children.length < 2) {\n      this.addError(networkId, node.id, \n        'Block must have at least 2 children', 'structure');\n    }\n    \n    // Recursively validate children\n    for (const child of node.children) {\n      this.validateNode(networkId, child);\n    }\n  }\n  \n  private checkDuplicateOutputs(): void {\n    // Check for same address used as output in multiple networks\n    const addressCount = new Map<string, string[]>();\n    \n    for (const [addr, network] of this.usedOutputs) {\n      if (!addressCount.has(addr)) {\n        addressCount.set(addr, []);\n      }\n      addressCount.get(addr)!.push(network);\n    }\n    \n    for (const [addr, networks] of addressCount) {\n      if (networks.length > 1) {\n        this.addWarning(networks[0], undefined, \n          `Address ${addr} is used as output in multiple networks: ${networks.join(', ')}`, 'logic');\n      }\n    }\n  }\n  \n  private addError(networkId: string, nodeId: string | undefined, message: string, \n                   errorType: ValidationError['errorType']): void {\n    this.errors.push({ networkId, nodeId, message, errorType, severity: 'error' });\n  }\n  \n  private addWarning(networkId: string, nodeId: string | undefined, message: string,\n                     errorType: ValidationError['errorType']): void {\n    this.warnings.push({ networkId, nodeId, message, errorType, severity: 'warning' });\n  }\n}\n```",
        "testStrategy": "1. Test validation catches address out of range errors\n2. Test validation catches read-only device write attempts\n3. Test validation warns about empty networks\n4. Test validation warns about missing output instructions\n5. Test validation detects duplicate output addresses\n6. Test timer/counter device validation\n7. Test block structure validation\n8. Test valid programs pass validation",
        "priority": "medium",
        "dependencies": [
          "65"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define ValidationError and ValidationResult Types in OneParser types.ts",
            "description": "Extend the OneParser types.ts file with ValidationError interface and ValidationResult interface that capture error details including network ID, node ID, error message, error type, and severity level.",
            "dependencies": [],
            "details": "Add to src/components/OneParser/types.ts the following type definitions:\n\n```typescript\nexport type ValidationErrorType = 'syntax' | 'address' | 'logic' | 'structure';\nexport type ValidationSeverity = 'error' | 'warning';\n\nexport interface ValidationError {\n  networkId: string;\n  nodeId?: string;\n  message: string;\n  errorType: ValidationErrorType;\n  severity: ValidationSeverity;\n}\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: ValidationError[];\n  warnings: ValidationError[];\n}\n```\n\nThese types follow the existing codebase pattern seen in connectionValidator.ts and error.ts where discriminated types are used for error categorization. The errorType field allows filtering by error category (syntax issues, address problems, logic errors, structural problems), while severity enables distinguishing between blocking errors and non-blocking warnings.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation with `pnpm tsc --noEmit`. Create test instances of ValidationError with each errorType and severity combination. Test that ValidationResult can contain multiple errors and warnings. Ensure types integrate properly with existing LadderProgram, LadderNetwork, and LadderNode types from Task 64 and 65.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement ProgramValidator Class with Address Validation Methods",
            "description": "Create the ProgramValidator class in Validator.ts with core address validation logic that checks address ranges using isAddressInRange from AddressParser and validates bit index bounds (0-15) and index register bounds (0-15).",
            "dependencies": [
              1
            ],
            "details": "Create src/components/OneParser/Validator.ts with the ProgramValidator class:\n\n```typescript\nimport type { LadderProgram, LadderNetwork, LadderNode, DeviceAddress, ValidationError, ValidationResult } from './types';\nimport { isAddressInRange, stringifyDeviceAddress } from './AddressParser';\n\nexport class ProgramValidator {\n  private errors: ValidationError[] = [];\n  private warnings: ValidationError[] = [];\n  private usedOutputs: Map<string, string> = new Map();\n\n  validate(program: LadderProgram): ValidationResult {\n    this.errors = [];\n    this.warnings = [];\n    this.usedOutputs.clear();\n    // Implementation in subsequent subtasks\n    return { valid: this.errors.length === 0, errors: [...this.errors], warnings: [...this.warnings] };\n  }\n\n  private validateAddress(networkId: string, nodeId: string, address: DeviceAddress): void {\n    if (!isAddressInRange(address.device, address.address)) {\n      this.addError(networkId, nodeId, `Address ${stringifyDeviceAddress(address)} is out of range`, 'address');\n    }\n    if (address.bitIndex !== undefined && (address.bitIndex < 0 || address.bitIndex > 15)) {\n      this.addError(networkId, nodeId, `Bit index ${address.bitIndex} is out of range (0-15)`, 'address');\n    }\n    if (address.indexRegister !== undefined && (address.indexRegister < 0 || address.indexRegister > 15)) {\n      this.addError(networkId, nodeId, `Index register Z${address.indexRegister} is out of range (0-15)`, 'address');\n    }\n  }\n\n  private addError(networkId: string, nodeId: string | undefined, message: string, errorType: ValidationError['errorType']): void {\n    this.errors.push({ networkId, nodeId, message, errorType, severity: 'error' });\n  }\n\n  private addWarning(networkId: string, nodeId: string | undefined, message: string, errorType: ValidationError['errorType']): void {\n    this.warnings.push({ networkId, nodeId, message, errorType, severity: 'warning' });\n  }\n}\n```\n\nDevice ranges from PRD: P(0-2047), M(0-8191), K(0-2047), F(0-2047), T(0-2047), C(0-2047), D(0-9999), R(0-9999), Z(0-15), N(0-8191).",
            "status": "pending",
            "testStrategy": "Test validateAddress correctly identifies out-of-range addresses for each device type (P2048 invalid, P2047 valid). Test bit index validation rejects bitIndex=16 and accepts bitIndex=15. Test index register validation rejects indexRegister=16. Verify addError/addWarning correctly populate errors/warnings arrays with proper structure.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Node-Specific Validation Methods for Contacts, Coils, Timers, and Counters",
            "description": "Add type-specific validation methods to ProgramValidator that check logical constraints: contacts should use bit devices, coils cannot write to read-only devices (P, F, T, C), timers must use T device with positive preset, counters must use C device with positive preset.",
            "dependencies": [
              2
            ],
            "details": "Add the following methods to the ProgramValidator class:\n\n```typescript\nprivate validateContact(networkId: string, node: ContactNode): void {\n  const device = node.address.device;\n  // Contacts can use bit devices (P, M, K, F, T, C) or word devices with bit access\n  if (!['P', 'M', 'K', 'F', 'T', 'C'].includes(device) && node.address.bitIndex === undefined) {\n    this.addWarning(networkId, node.id, `Contact using word device ${device} without bit access`, 'logic');\n  }\n}\n\nprivate validateCoil(networkId: string, node: CoilNode): void {\n  const device = node.address.device;\n  // Per PRD: P (Input), F (Special), T (Timer contact), C (Counter contact) are read-only\n  if (['P', 'F', 'T', 'C'].includes(device)) {\n    this.addError(networkId, node.id, `Cannot write to read-only device ${device}`, 'logic');\n  }\n  // Track output address for duplicate detection\n  const addrKey = stringifyDeviceAddress(node.address);\n  this.usedOutputs.set(addrKey, networkId);\n}\n\nprivate validateTimer(networkId: string, node: TimerNode): void {\n  if (node.address.device !== 'T') {\n    this.addError(networkId, node.id, `Timer must use T device, not ${node.address.device}`, 'logic');\n  }\n  if (node.preset <= 0) {\n    this.addWarning(networkId, node.id, 'Timer preset should be positive', 'logic');\n  }\n}\n\nprivate validateCounter(networkId: string, node: CounterNode): void {\n  if (node.address.device !== 'C') {\n    this.addError(networkId, node.id, `Counter must use C device, not ${node.address.device}`, 'logic');\n  }\n  if (node.preset <= 0) {\n    this.addWarning(networkId, node.id, 'Counter preset should be positive', 'logic');\n  }\n}\n```\n\nThe read-only device check is critical: P (input relays), F (special relays), T (timer contacts), and C (counter contacts) cannot be written to directly - only M (auxiliary) and K (keep) are writable coils.",
            "status": "pending",
            "testStrategy": "Test validateCoil rejects writes to P, F, T, C devices with 'error' severity. Test validateCoil accepts writes to M, K devices. Test validateTimer rejects non-T device with error. Test validateTimer warns on preset <= 0. Test validateCounter similarly for C device. Test validateContact warns when using D device without bitIndex.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Network and Block Validation with Structure Checks",
            "description": "Add validateNetwork and validateBlock methods that check for empty networks, missing output instructions, and ensure block nodes have at least 2 children with recursive child validation.",
            "dependencies": [
              3
            ],
            "details": "Add network-level and block validation methods:\n\n```typescript\nprivate validateNetwork(network: LadderNetwork): void {\n  // Check for empty network\n  if (network.nodes.length === 0) {\n    this.addWarning(network.id, undefined, 'Empty network', 'structure');\n    return;\n  }\n\n  // Validate each node\n  for (const node of network.nodes) {\n    this.validateNode(network.id, node);\n  }\n\n  // Check for output instruction (coils, timers, counters)\n  const outputTypes = ['coil_out', 'coil_set', 'coil_rst', 'timer_ton', 'timer_tof', 'timer_tmr', 'counter_ctu', 'counter_ctd', 'counter_ctud'];\n  const hasOutput = network.nodes.some(n => outputTypes.includes(n.type));\n  if (!hasOutput) {\n    this.addWarning(network.id, undefined, 'Network has no output instruction', 'structure');\n  }\n}\n\nprivate validateBlock(networkId: string, node: BlockNode): void {\n  if (node.children.length < 2) {\n    this.addError(networkId, node.id, 'Block must have at least 2 children', 'structure');\n  }\n  // Recursively validate children\n  for (const child of node.children) {\n    this.validateNode(networkId, child);\n  }\n}\n\nprivate validateNode(networkId: string, node: LadderNode): void {\n  if ('address' in node && node.address) {\n    this.validateAddress(networkId, node.id, node.address);\n  }\n  switch (node.type) {\n    case 'contact_no': case 'contact_nc': case 'contact_p': case 'contact_n':\n      this.validateContact(networkId, node as ContactNode); break;\n    case 'coil_out': case 'coil_set': case 'coil_rst':\n      this.validateCoil(networkId, node as CoilNode); break;\n    case 'timer_ton': case 'timer_tof': case 'timer_tmr':\n      this.validateTimer(networkId, node as TimerNode); break;\n    case 'counter_ctu': case 'counter_ctd': case 'counter_ctud':\n      this.validateCounter(networkId, node as CounterNode); break;\n    case 'block_series': case 'block_parallel':\n      this.validateBlock(networkId, node as BlockNode); break;\n  }\n}\n```\n\nThis enables detection of malformed structures from CSV parsing issues or manual AST construction errors.",
            "status": "pending",
            "testStrategy": "Test validateNetwork warns on empty network (nodes.length === 0). Test validateNetwork warns when no output instruction present (contacts only). Test validateNetwork passes when at least one coil/timer/counter output exists. Test validateBlock errors when children.length < 2. Test validateBlock recursively validates nested children. Test validateNode dispatches to correct handler based on node.type.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Duplicate Output Detection and Complete validate() Method Integration",
            "description": "Add checkDuplicateOutputs method to detect when the same output address is used in multiple networks, and wire up the complete validate() method to iterate through all networks and perform global validation checks.",
            "dependencies": [
              4
            ],
            "details": "Complete the ProgramValidator with global validation and final integration:\n\n```typescript\npublic validate(program: LadderProgram): ValidationResult {\n  this.errors = [];\n  this.warnings = [];\n  this.usedOutputs.clear();\n\n  // Validate each network\n  for (const network of program.networks) {\n    this.validateNetwork(network);\n  }\n\n  // Check for global issues\n  this.checkDuplicateOutputs();\n\n  return {\n    valid: this.errors.length === 0,\n    errors: this.errors.filter(e => e.severity === 'error'),\n    warnings: this.errors.filter(e => e.severity === 'warning').concat(this.warnings),\n  };\n}\n\nprivate checkDuplicateOutputs(): void {\n  const addressNetworks = new Map<string, string[]>();\n\n  // Build map of address -> networks that use it\n  for (const [addr, network] of this.usedOutputs) {\n    if (!addressNetworks.has(addr)) {\n      addressNetworks.set(addr, []);\n    }\n    addressNetworks.get(addr)!.push(network);\n  }\n\n  // Warn about duplicates\n  for (const [addr, networks] of addressNetworks) {\n    if (networks.length > 1) {\n      this.addWarning(networks[0], undefined,\n        `Address ${addr} is used as output in multiple networks: ${networks.join(', ')}`, 'logic');\n    }\n  }\n}\n```\n\nAlso export a convenience function:\n\n```typescript\nexport function validateProgram(program: LadderProgram): ValidationResult {\n  const validator = new ProgramValidator();\n  return validator.validate(program);\n}\n```\n\nExport from index file: `export { ProgramValidator, validateProgram } from './Validator';`\n\nDuplicate output detection is important because writing to the same coil from multiple networks can cause unpredictable behavior in PLC execution.",
            "status": "pending",
            "testStrategy": "Test checkDuplicateOutputs warns when M0001 used in network1 and network2. Test no warning when each output address used in only one network. Test validate() returns valid:true when no errors present. Test validate() returns valid:false when at least one error exists. Test errors array contains only severity:'error' items. Test warnings array contains both severity:'warning' from errors and from warnings list. Integration test: validate a complete LadderProgram with mixed valid/invalid nodes.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Create React hooks for OneParser integration including useParseFile, useParserProgress, and useParsedData"
      },
      {
        "id": "69",
        "title": "Create OneParser Main Module and Integration Tests",
        "description": "Create the main OneParser module that ties together all components and write comprehensive integration tests with sample XG5000 CSV files.",
        "details": "Create `src/components/OneParser/OneParser.ts`:\n\n```typescript\nimport type { LadderProgram, ProgramMetadata, CsvRow } from './types';\nimport { CsvReader } from './CsvReader';\nimport { AstBuilder } from './AstBuilder';\nimport { ProgramValidator, ValidationResult } from './Validator';\nimport { ModbusMapper } from './ModbusMapper';\nimport { GridCalculator } from './GridCalculator';\nimport { parserService } from '../../services/parserService';\n\nexport interface ParseOptions {\n  /** Use Tauri backend for parsing (default: true in Tauri context) */\n  useBackend?: boolean;\n  /** Program metadata to include */\n  metadata?: Partial<ProgramMetadata>;\n  /** Validate after parsing (default: true) */\n  validate?: boolean;\n}\n\nexport interface ParseResult {\n  program: LadderProgram;\n  validation?: ValidationResult;\n}\n\n/**\n * OneParser - Main parser module for LS PLC CSV files\n * \n * Parses XG5000 CSV exports into AST format for visualization and simulation.\n * \n * @example\n * ```typescript\n * const parser = new OneParser();\n * const result = await parser.parseFile('/path/to/program.csv');\n * if (result.validation?.valid) {\n *   console.log('Program parsed successfully');\n * }\n * ```\n */\nexport class OneParser {\n  private astBuilder: AstBuilder;\n  private validator: ProgramValidator;\n  private modbusMapper: ModbusMapper;\n  private gridCalculator: GridCalculator;\n  \n  constructor() {\n    this.astBuilder = new AstBuilder();\n    this.validator = new ProgramValidator();\n    this.modbusMapper = new ModbusMapper();\n    this.gridCalculator = new GridCalculator();\n  }\n  \n  /**\n   * Parse CSV file from path (uses Tauri backend)\n   */\n  async parseFile(path: string, options: ParseOptions = {}): Promise<ParseResult> {\n    const program = await parserService.parseCsv(path);\n    \n    let validation: ValidationResult | undefined;\n    if (options.validate !== false) {\n      validation = this.validator.validate(program);\n    }\n    \n    return { program, validation };\n  }\n  \n  /**\n   * Parse CSV string content\n   */\n  async parseString(content: string, options: ParseOptions = {}): Promise<ParseResult> {\n    let program: LadderProgram;\n    \n    if (options.useBackend !== false && window.__TAURI__) {\n      program = await parserService.parseCsvString(content);\n    } else {\n      program = this.astBuilder.buildProgram(content, options.metadata);\n    }\n    \n    let validation: ValidationResult | undefined;\n    if (options.validate !== false) {\n      validation = this.validator.validate(program);\n    }\n    \n    return { program, validation };\n  }\n  \n  /**\n   * Validate an existing program\n   */\n  validate(program: LadderProgram): ValidationResult {\n    return this.validator.validate(program);\n  }\n  \n  /**\n   * Convert program back to CSV format\n   */\n  async toCSV(program: LadderProgram): Promise<string> {\n    return parserService.programToCsv(program);\n  }\n  \n  /**\n   * Save program to file\n   */\n  async saveProgram(path: string, program: LadderProgram): Promise<void> {\n    return parserService.saveProgram(path, program);\n  }\n  \n  /**\n   * Load program from file\n   */\n  async loadProgram(path: string): Promise<LadderProgram> {\n    return parserService.loadProgram(path);\n  }\n  \n  /**\n   * Get Modbus mapper instance\n   */\n  getModbusMapper(): ModbusMapper {\n    return this.modbusMapper;\n  }\n  \n  /**\n   * Get grid calculator instance\n   */\n  getGridCalculator(): GridCalculator {\n    return this.gridCalculator;\n  }\n}\n\n// Export singleton instance\nexport const oneParser = new OneParser();\n```\n\nCreate `src/components/OneParser/index.ts`:\n\n```typescript\n// Main parser\nexport { OneParser, oneParser } from './OneParser';\nexport type { ParseOptions, ParseResult } from './OneParser';\n\n// Types\nexport * from './types';\n\n// Components\nexport { CsvReader } from './CsvReader';\nexport { AstBuilder } from './AstBuilder';\nexport { InstructionParser } from './InstructionParser';\nexport { ProgramValidator } from './Validator';\nexport type { ValidationResult, ValidationError } from './Validator';\nexport { ModbusMapper, formatModbusAddress, parseModbusAddress } from './ModbusMapper';\nexport { GridCalculator } from './GridCalculator';\n\n// Address utilities\nexport {\n  parseDeviceAddress,\n  stringifyDeviceAddress,\n  isValidDevice,\n  isBitDevice,\n  isWordDevice,\n  isAddressInRange,\n  DEVICE_RANGES,\n} from './AddressParser';\n```\n\nCreate test file `src/components/OneParser/__tests__/OneParser.test.ts`:\n\n```typescript\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { OneParser } from '../OneParser';\nimport { parseDeviceAddress, stringifyDeviceAddress } from '../AddressParser';\nimport { ModbusMapper } from '../ModbusMapper';\n\n// Sample XG5000 CSV content\nconst SAMPLE_CSV = `No,Step,Instruction,Operand1,Operand2,Operand3,Comment\n1,0,LOAD,P0001,,,Start Button\n2,0,OR,M0001,,,Self-hold\n3,0,LOADN,P0002,,,Stop Button\n4,0,ANDB,,,,AND Block\n5,0,OUT,M0001,,,Motor ON\n6,1,LOAD,M0001,,,Motor Running\n7,1,TON,T0001,1000,,Motor Delay\n8,1,OUT,M0002,,,Delay Complete\n`;\n\ndescribe('OneParser', () => {\n  let parser: OneParser;\n  \n  beforeEach(() => {\n    parser = new OneParser();\n  });\n  \n  describe('parseString', () => {\n    it('should parse CSV content into LadderProgram', async () => {\n      const result = await parser.parseString(SAMPLE_CSV, { useBackend: false });\n      \n      expect(result.program).toBeDefined();\n      expect(result.program.networks).toHaveLength(2);\n      expect(result.program.networks[0].step).toBe(0);\n      expect(result.program.networks[1].step).toBe(1);\n    });\n    \n    it('should validate program by default', async () => {\n      const result = await parser.parseString(SAMPLE_CSV, { useBackend: false });\n      \n      expect(result.validation).toBeDefined();\n      expect(result.validation?.valid).toBe(true);\n    });\n  });\n});\n\ndescribe('Address Parser', () => {\n  it('should parse standard addresses', () => {\n    const addr = parseDeviceAddress('P0001');\n    expect(addr).toEqual({ device: 'P', address: 1 });\n  });\n  \n  it('should parse bit access addresses', () => {\n    const addr = parseDeviceAddress('D0000.5');\n    expect(addr).toEqual({ device: 'D', address: 0, bitIndex: 5 });\n  });\n  \n  it('should parse indexed addresses', () => {\n    const addr = parseDeviceAddress('D[Z0]');\n    expect(addr).toEqual({ device: 'D', address: 0, indexRegister: 0 });\n  });\n  \n  it('should round-trip addresses', () => {\n    const original = 'M0001';\n    const addr = parseDeviceAddress(original);\n    const result = stringifyDeviceAddress(addr!);\n    expect(result).toBe(original);\n  });\n});\n\ndescribe('Modbus Mapper', () => {\n  let mapper: ModbusMapper;\n  \n  beforeEach(() => {\n    mapper = new ModbusMapper();\n  });\n  \n  it('should map P device to discrete input', () => {\n    const addr = parseDeviceAddress('P0001')!;\n    const modbus = mapper.mapToModbus(addr);\n    expect(modbus).toEqual({ type: 'discrete', address: 1 });\n  });\n  \n  it('should map M device to coil', () => {\n    const addr = parseDeviceAddress('M0001')!;\n    const modbus = mapper.mapToModbus(addr);\n    expect(modbus).toEqual({ type: 'coil', address: 1 });\n  });\n  \n  it('should map D device to holding register', () => {\n    const addr = parseDeviceAddress('D0100')!;\n    const modbus = mapper.mapToModbus(addr);\n    expect(modbus).toEqual({ type: 'holding', address: 100 });\n  });\n});\n```",
        "testStrategy": "1. Integration test: Parse sample XG5000 CSV file end-to-end\n2. Integration test: Validate parsed program\n3. Integration test: Convert program back to CSV and verify\n4. Integration test: Save and load program JSON\n5. Test Modbus address mapping for all device types\n6. Test grid calculation produces valid layout\n7. Test symbol table contains all used addresses\n8. E2E test: Load CSV, visualize in LadderEditor (Unit 8)\n9. E2E test: Execute program in OneSim (Unit 9)",
        "priority": "medium",
        "dependencies": [
          "67",
          "68"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create OneParser Directory Structure and Core Types File",
            "description": "Set up the OneParser component directory with the comprehensive types.ts file containing all TypeScript interfaces for LadderProgram, LadderNetwork, LadderNode variants, DeviceAddress, and related types.",
            "dependencies": [],
            "details": "Create directory `src/components/OneParser/` and file `src/components/OneParser/types.ts` with complete type definitions:\n\n1. **ProgramMetadata interface**: version, name, description, author, createdAt, updatedAt\n2. **DeviceAddress interface**: device (P|M|K|F|T|C|D|R|Z|N), address (number), bitIndex (optional 0-15), indexRegister (optional 0-15)\n3. **ModbusAddress interface**: type ('coil'|'discrete'|'holding'|'input'), address (number)\n4. **LadderNode union type** with discriminated types:\n   - ContactNode: type ('contact_no'|'contact_nc'|'contact_p'|'contact_n'), id, address, comment\n   - CoilNode: type ('coil_out'|'coil_set'|'coil_rst'), id, address, comment\n   - TimerNode: type ('timer_ton'|'timer_tof'|'timer_tmr'), id, address, preset, comment\n   - CounterNode: type ('counter_ctu'|'counter_ctd'|'counter_ctud'), id, address, preset, comment\n   - BlockNode: type ('block_series'|'block_parallel'), id, children\n5. **LadderNetwork interface**: id, step, nodes, comment\n6. **LadderProgram interface**: metadata, networks, symbols\n7. **CsvRow interface**: no, step, instruction, operand1-3, comment\n8. **ValidationError/ValidationResult types** (matching Task 68 specifications)\n\nFollow existing codebase patterns from `src/types/scenario.ts` and `src/types/modbus.ts` for consistency.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation passes with `pnpm tsc --noEmit`. Import types in a test file and verify all interfaces are properly exported. Test that discriminated union types work correctly with type guards. Ensure types align with the Rust struct definitions from Task 67.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement AddressParser and ModbusMapper Utility Modules",
            "description": "Create AddressParser.ts for parsing LS PLC device addresses (P0001, M0001, D0000.5, D[Z0]) and ModbusMapper.ts for bidirectional mapping between device addresses and Modbus addresses.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/OneParser/AddressParser.ts` with:\n\n1. **DEVICE_RANGES constant**: Define valid ranges per device type - P(0-2047), M(0-8191), K(0-2047), F(0-2047), T(0-2047), C(0-2047), D(0-9999), R(0-9999), Z(0-15), N(0-8191)\n2. **parseDeviceAddress(input: string): DeviceAddress | null**: Parse standard addresses (P0001), bit access (D0000.5), indexed addresses (D[Z0]), combined formats (D0100[Z0].5)\n3. **stringifyDeviceAddress(addr: DeviceAddress): string**: Convert back to string format, preserving bitIndex and indexRegister\n4. **isValidDevice(device: string): boolean**: Check if device letter is valid\n5. **isBitDevice(device: string): boolean**: Returns true for P, M, K, F, T, C\n6. **isWordDevice(device: string): boolean**: Returns true for D, R, N\n7. **isAddressInRange(device: string, address: number): boolean**: Validate against DEVICE_RANGES\n\nCreate `src/components/OneParser/ModbusMapper.ts` with:\n\n1. **ModbusMapper class** with configurable mapping rules:\n   - P -> discrete (offset 0)\n   - M -> coil (offset 0)\n   - K -> coil (offset 8192)\n   - D -> holding (offset 0)\n   - T, C, N -> appropriate register types\n2. **mapToModbus(addr: DeviceAddress): ModbusAddress | null**: Convert device to Modbus address\n3. **mapFromModbus(modbus: ModbusAddress): DeviceAddress[]**: Reverse mapping (may return multiple due to overlapping ranges)\n4. **formatModbusAddress/parseModbusAddress**: String utilities matching existing `addressParser.ts` patterns",
            "status": "pending",
            "testStrategy": "Test parseDeviceAddress for all formats: standard (P0001, M1234), bit access (D0000.5), indexed (D[Z0]), combined (D0100[Z0].5). Test stringifyDeviceAddress round-trips correctly. Test isAddressInRange rejects out-of-range addresses. Test ModbusMapper maps P->discrete, M->coil, K->coil(+8192), D->holding. Test reverse mapping from ModbusAddress back to device.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create OneParser Main Module with Facade Pattern Integration",
            "description": "Implement the main OneParser.ts class that integrates all parser components (AstBuilder, Validator, ModbusMapper, GridCalculator) and provides a clean public API for parsing CSV content, validating programs, and file operations.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/components/OneParser/OneParser.ts` implementing the main parser facade:\n\n1. **ParseOptions interface**: useBackend (boolean), metadata (Partial<ProgramMetadata>), validate (boolean, default true)\n2. **ParseResult interface**: program (LadderProgram), validation (ValidationResult optional)\n3. **OneParser class** with:\n   - Constructor initializing AstBuilder, ProgramValidator, ModbusMapper, GridCalculator instances\n   - **parseFile(path: string, options?: ParseOptions): Promise<ParseResult>**: Uses parserService.parseCsv from Tauri backend, optionally validates\n   - **parseString(content: string, options?: ParseOptions): Promise<ParseResult>**: Checks window.__TAURI__ to use backend or frontend AstBuilder\n   - **validate(program: LadderProgram): ValidationResult**: Delegates to ProgramValidator\n   - **toCSV(program: LadderProgram): Promise<string>**: Delegates to parserService.programToCsv\n   - **saveProgram(path: string, program: LadderProgram): Promise<void>**: Save as JSON via parserService\n   - **loadProgram(path: string): Promise<LadderProgram>**: Load JSON via parserService\n   - **getModbusMapper(): ModbusMapper**: Accessor for mapper instance\n   - **getGridCalculator(): GridCalculator**: Accessor for grid calculator\n4. **Export singleton**: `export const oneParser = new OneParser();`\n\nNote: AstBuilder, ProgramValidator, GridCalculator implementations come from Tasks 67 and 68. Create placeholder/stub implementations if dependencies not ready.",
            "status": "pending",
            "testStrategy": "Test parseString with mock CSV content in non-Tauri environment (useBackend: false). Test validation runs by default. Test validation can be disabled. Test getModbusMapper returns valid instance. Verify parseFile throws when Tauri not available. Test saveProgram/loadProgram round-trip (mock Tauri invoke).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create Barrel Export Index File and Component Integration",
            "description": "Build the index.ts barrel file that exports all public OneParser APIs, types, and utilities in an organized manner, ensuring clean import paths for consumers.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create `src/components/OneParser/index.ts` with organized exports:\n\n```typescript\n// Main parser\nexport { OneParser, oneParser } from './OneParser';\nexport type { ParseOptions, ParseResult } from './OneParser';\n\n// Types - all from types.ts\nexport type {\n  LadderProgram,\n  LadderNetwork,\n  LadderNode,\n  ContactNode,\n  CoilNode,\n  TimerNode,\n  CounterNode,\n  BlockNode,\n  DeviceAddress,\n  ModbusAddress,\n  ProgramMetadata,\n  CsvRow,\n} from './types';\n\n// Validation\nexport { ProgramValidator } from './Validator';\nexport type { ValidationResult, ValidationError } from './Validator';\n\n// Address utilities\nexport {\n  parseDeviceAddress,\n  stringifyDeviceAddress,\n  isValidDevice,\n  isBitDevice,\n  isWordDevice,\n  isAddressInRange,\n  DEVICE_RANGES,\n} from './AddressParser';\n\n// Modbus mapping\nexport { ModbusMapper, formatModbusAddress, parseModbusAddress } from './ModbusMapper';\n```\n\nAdditionally:\n1. Update `src/services/index.ts` to include parserService export when it exists\n2. Ensure all exports use type-only exports where appropriate (`export type`) for pure type definitions\n3. Follow existing barrel file patterns from `src/components/OneCanvas/index.ts` and `src/components/ScenarioEditor/index.ts`",
            "status": "pending",
            "testStrategy": "Import all exports from '@components/OneParser' in a test file and verify no TypeScript errors. Verify named imports work: `import { oneParser, parseDeviceAddress, ModbusMapper } from '@components/OneParser'`. Verify type imports work: `import type { LadderProgram, ValidationResult } from '@components/OneParser'`. Ensure no circular dependency issues.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Write Comprehensive Integration Tests with Sample XG5000 CSV",
            "description": "Create integration test file using Vitest that tests end-to-end parsing, validation, address parsing, and Modbus mapping with realistic XG5000 CSV sample data.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create `src/components/OneParser/__tests__/OneParser.test.ts` with Vitest:\n\n1. **Sample XG5000 CSV constant** containing realistic ladder logic:\n   - Network 0: Self-holding circuit (LOAD P0001, OR M0001, LOADN P0002, ANDB, OUT M0001)\n   - Network 1: Timer circuit (LOAD M0001, TON T0001 1000, OUT M0002)\n   - Include comments, multiple operands, edge cases\n\n2. **OneParser describe block**:\n   - Test parseString parses CSV into LadderProgram with correct network count\n   - Test validation runs automatically and returns valid:true for valid program\n   - Test validation can be disabled via options\n   - Test parseString with metadata option includes metadata in result\n\n3. **Address Parser describe block**:\n   - Test parseDeviceAddress with standard formats: P0001, M1234, D9999\n   - Test parseDeviceAddress with bit access: D0000.5, D0000.15\n   - Test parseDeviceAddress with indexed: D[Z0], D0100[Z0]\n   - Test parseDeviceAddress with combined: D0100[Z0].5\n   - Test stringifyDeviceAddress round-trips all formats\n   - Test invalid addresses return null: P99999, D-1, invalid device\n\n4. **Modbus Mapper describe block**:\n   - Test P device maps to discrete input at correct offset\n   - Test M device maps to coil at offset 0\n   - Test K device maps to coil at offset 8192\n   - Test D device maps to holding register\n   - Test reverse mapping from ModbusAddress\n\n5. **Validation describe block** (if ProgramValidator available):\n   - Test valid program passes validation\n   - Test invalid address range detected\n   - Test duplicate output warning generated",
            "status": "pending",
            "testStrategy": "Run `pnpm test` to execute Vitest tests. All tests should pass. Coverage should include: OneParser class methods, AddressParser functions, ModbusMapper class, Validation integration. Test with both valid and invalid inputs to ensure proper error handling. Verify tests run in isolation without Tauri dependency (useBackend: false).",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Create comprehensive test suites for OneParser including unit tests for each module, integration tests, and sample PLC files for validation"
      },
      {
        "id": "70",
        "title": "Define Ladder Editor Types and Data Structures",
        "description": "Create TypeScript type definitions for ladder diagram elements, AST node structures, grid cell positions, and monitoring state interfaces.",
        "details": "Create `src/types/ladder.ts` with the following type definitions:\n\n1. **Ladder Element Types:**\n```typescript\ntype LadderElementType = 'contact_no' | 'contact_nc' | 'contact_p' | 'contact_n' | 'coil' | 'coil_set' | 'coil_reset' | 'timer_ton' | 'timer_tof' | 'timer_tmr' | 'counter_ctu' | 'counter_ctd' | 'counter_ctud' | 'compare_eq' | 'compare_gt' | 'compare_lt' | 'compare_ge' | 'compare_le' | 'compare_ne' | 'wire_h' | 'wire_v' | 'wire_corner' | 'wire_junction' | 'power_rail' | 'neutral_rail';\n```\n\n2. **Grid Cell Position:**\n```typescript\ninterface GridPosition { row: number; column: number; }\ninterface CellSize { width: number; height: number; }\ninterface GridConfig { columns: number; cellWidth: number; cellHeight: number; }\n```\n\n3. **Ladder Element Interface:**\n```typescript\ninterface LadderElement {\n  id: string;\n  type: LadderElementType;\n  position: GridPosition;\n  address?: string; // e.g., 'X0', 'Y0', 'T0', 'C0'\n  label?: string;\n  properties: ElementProperties;\n}\n```\n\n4. **AST Node Types (for OneParser integration):**\n```typescript\ninterface LadderASTNode {\n  type: 'series' | 'parallel' | 'element';\n  element?: LadderElement;\n  children?: LadderASTNode[];\n}\n```\n\n5. **Network Structure:**\n```typescript\ninterface LadderNetwork {\n  id: string;\n  label?: string;\n  elements: Map<string, LadderElement>;\n  wires: LadderWire[];\n  ast?: LadderASTNode;\n}\n```\n\n6. **Monitoring State:**\n```typescript\ninterface LadderMonitoringState {\n  deviceStates: Map<string, boolean | number>;\n  forcedDevices: Set<string>;\n  energizedWires: Set<string>;\n  timerStates: Map<string, { et: number; pt: number; running: boolean; done: boolean }>;\n  counterStates: Map<string, { cv: number; pv: number }>;\n}\n```\n\n7. **Type Guards and Default Values**\n\nExport all types from `src/types/index.ts`.",
        "testStrategy": "1. TypeScript compilation passes without errors\n2. All type definitions are properly exported\n3. Type guards return correct boolean values for each element type\n4. Default values are valid according to their type definitions\n5. Create unit tests in `src/types/__tests__/ladder.test.ts` to verify type guards",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Core Ladder Element Types and Enums",
            "description": "Create the foundational LadderElementType union type covering all ladder diagram element categories: contacts, coils, wires, timers, counters, and comparison elements.",
            "dependencies": [],
            "details": "Create `src/types/ladder.ts` and define:\n1. `LadderElementType` union type with all element categories:\n   - Contacts: 'contact_no' | 'contact_nc' | 'contact_p' | 'contact_n'\n   - Coils: 'coil' | 'coil_set' | 'coil_reset'\n   - Timers: 'timer_ton' | 'timer_tof' | 'timer_tmr'\n   - Counters: 'counter_ctu' | 'counter_ctd' | 'counter_ctud'\n   - Comparisons: 'compare_eq' | 'compare_gt' | 'compare_lt' | 'compare_ge' | 'compare_le' | 'compare_ne'\n   - Wires: 'wire_h' | 'wire_v' | 'wire_corner' | 'wire_junction'\n   - Rails: 'power_rail' | 'neutral_rail'\n\n2. Category subset types for grouping:\n   - `ContactType` - subset of contact elements\n   - `CoilType` - subset of coil elements\n   - `TimerType` - subset of timer elements\n   - `CounterType` - subset of counter elements\n   - `CompareType` - subset of comparison elements\n   - `WireType` - subset of wire elements\n   - `RailType` - subset of rail elements\n\nFollow the discriminated union pattern established in `OneCanvas/types.ts`.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation passes. Test that LadderElementType correctly accepts all valid element strings and rejects invalid ones through type checking.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define Grid Position and Configuration Types",
            "description": "Create interfaces for grid-based positioning including GridPosition, CellSize, and GridConfig that define the ladder diagram coordinate system.",
            "dependencies": [
              1
            ],
            "details": "Add to `src/types/ladder.ts`:\n\n1. `GridPosition` interface:\n   ```typescript\n   interface GridPosition {\n     row: number;    // 0-indexed row in the grid\n     column: number; // 0-indexed column in the grid\n   }\n   ```\n\n2. `CellSize` interface:\n   ```typescript\n   interface CellSize {\n     width: number;  // Cell width in pixels\n     height: number; // Cell height in pixels\n   }\n   ```\n\n3. `GridConfig` interface:\n   ```typescript\n   interface GridConfig {\n     columns: number;    // Number of columns per rung (default: 10)\n     cellWidth: number;  // Width of each cell in pixels\n     cellHeight: number; // Height of each cell in pixels\n     showGridLines?: boolean; // Optional grid line display\n   }\n   ```\n\n4. `DEFAULT_GRID_CONFIG` constant with sensible defaults:\n   - columns: 10\n   - cellWidth: 80\n   - cellHeight: 60\n\n5. Utility type `GridSpan` for elements that span multiple cells:\n   ```typescript\n   interface GridSpan {\n     rows: number;\n     columns: number;\n   }\n   ```",
            "status": "pending",
            "testStrategy": "Verify GridPosition, CellSize, and GridConfig interfaces compile correctly. Test that DEFAULT_GRID_CONFIG constant matches the interface definition.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Define Ladder Element Interfaces and Properties",
            "description": "Create the LadderElement interface with type-specific properties following the BaseBlock generic pattern from OneCanvas types.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add to `src/types/ladder.ts`:\n\n1. `ElementProperties` base interface:\n   ```typescript\n   interface ElementProperties {\n     inverted?: boolean;\n     comment?: string;\n   }\n   ```\n\n2. Specialized property interfaces:\n   - `ContactProperties` - extends ElementProperties with negated edge detection\n   - `CoilProperties` - extends ElementProperties with set/reset flags\n   - `TimerProperties` - preset time (PT), time base\n   - `CounterProperties` - preset value (PV), count direction\n   - `CompareProperties` - comparison value, data type\n\n3. `BaseLadderElement<T extends LadderElementType>` generic interface:\n   ```typescript\n   interface BaseLadderElement<T extends LadderElementType = LadderElementType> {\n     id: string;\n     type: T;\n     position: GridPosition;\n     address?: string; // Device address (e.g., 'X0', 'Y0', 'T0')\n     label?: string;\n     selected?: boolean;\n     properties: ElementProperties;\n   }\n   ```\n\n4. Specialized element interfaces using discriminated union pattern:\n   - `ContactElement` - for all contact types\n   - `CoilElement` - for all coil types\n   - `TimerElement` - for timer types with preset/elapsed time\n   - `CounterElement` - for counter types with preset/current value\n   - `CompareElement` - for comparison operations\n   - `WireElement` - for wire routing\n   - `RailElement` - for power/neutral rails\n\n5. `LadderElement` discriminated union of all element types",
            "status": "pending",
            "testStrategy": "Verify discriminated union narrowing works correctly. Test that accessing type-specific properties requires proper type guards. Verify all interfaces export correctly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Define AST Node Types and Network Structure",
            "description": "Create LadderASTNode interface for OneParser integration and LadderNetwork structure for organizing ladder rungs.",
            "dependencies": [
              3
            ],
            "details": "Add to `src/types/ladder.ts`:\n\n1. `LadderASTNodeType` union type:\n   ```typescript\n   type LadderASTNodeType = 'series' | 'parallel' | 'element';\n   ```\n\n2. `LadderASTNode` interface for IL/ST code generation:\n   ```typescript\n   interface LadderASTNode {\n     type: LadderASTNodeType;\n     element?: LadderElement; // Only for 'element' type nodes\n     children?: LadderASTNode[]; // Only for 'series' | 'parallel' nodes\n     negated?: boolean; // For NOT operations\n   }\n   ```\n\n3. `LadderWire` interface for explicit wire connections:\n   ```typescript\n   interface LadderWire {\n     id: string;\n     from: { elementId: string; port: 'left' | 'right' | 'top' | 'bottom' };\n     to: { elementId: string; port: 'left' | 'right' | 'top' | 'bottom' };\n     type: 'horizontal' | 'vertical' | 'corner';\n   }\n   ```\n\n4. `LadderNetwork` (Rung) interface:\n   ```typescript\n   interface LadderNetwork {\n     id: string;\n     label?: string;\n     comment?: string;\n     elements: Map<string, LadderElement>;\n     wires: LadderWire[];\n     ast?: LadderASTNode; // Computed AST from topology\n     enabled: boolean;\n   }\n   ```\n\n5. `LadderProgram` top-level container:\n   ```typescript\n   interface LadderProgram {\n     id: string;\n     name: string;\n     networks: LadderNetwork[];\n     metadata: LadderProgramMetadata;\n   }\n   ```\n\n6. `LadderProgramMetadata` interface with name, version, author, dates",
            "status": "pending",
            "testStrategy": "Verify AST node types support recursive structure for nested series/parallel combinations. Test LadderNetwork can hold complex rung topologies. Verify serialization compatibility.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Define Monitoring State Types, Type Guards, and Exports",
            "description": "Create LadderMonitoringState interface for runtime simulation, implement type guards for element categories, add default values, and export all types from index.ts.",
            "dependencies": [
              3,
              4
            ],
            "details": "Add to `src/types/ladder.ts`:\n\n1. `TimerState` interface:\n   ```typescript\n   interface TimerState {\n     et: number;      // Elapsed time\n     pt: number;      // Preset time\n     running: boolean;\n     done: boolean;\n   }\n   ```\n\n2. `CounterState` interface:\n   ```typescript\n   interface CounterState {\n     cv: number; // Current value\n     pv: number; // Preset value\n     done: boolean;\n   }\n   ```\n\n3. `LadderMonitoringState` interface:\n   ```typescript\n   interface LadderMonitoringState {\n     deviceStates: Map<string, boolean | number>;\n     forcedDevices: Set<string>;\n     energizedWires: Set<string>;\n     timerStates: Map<string, TimerState>;\n     counterStates: Map<string, CounterState>;\n   }\n   ```\n\n4. Type guards following OneCanvas pattern:\n   - `isContactElement(element): element is ContactElement`\n   - `isCoilElement(element): element is CoilElement`\n   - `isTimerElement(element): element is TimerElement`\n   - `isCounterElement(element): element is CounterElement`\n   - `isCompareElement(element): element is CompareElement`\n   - `isWireElement(element): element is WireElement`\n   - `isValidLadderElementType(type): type is LadderElementType`\n\n5. Default value constants:\n   - `DEFAULT_GRID_CONFIG`\n   - `DEFAULT_MONITORING_STATE`\n   - `DEFAULT_TIMER_STATE`\n   - `DEFAULT_COUNTER_STATE`\n\n6. Update `src/types/index.ts` to export all ladder types:\n   ```typescript\n   export * from './ladder';\n   ```",
            "status": "pending",
            "testStrategy": "Unit test all type guards return correct boolean values for each element type. Verify DEFAULT_MONITORING_STATE creates valid empty state. Test TypeScript compilation passes with all exports. Create `src/types/__tests__/ladder.test.ts` with type guard tests.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Define TypeScript types for LadderEditor including LadderElement union type, GridCell, Rung, LadderProgram following OneCanvas/types.ts discriminated union patterns"
      },
      {
        "id": "71",
        "title": "Create Ladder Editor Zustand Store",
        "description": "Implement a Zustand store for ladder editor state management including networks, elements, selection, monitoring state, and undo/redo history.",
        "details": "Create `src/stores/ladderStore.ts` following the existing `canvasStore.ts` pattern:\n\n1. **State Interface:**\n```typescript\ninterface LadderState {\n  networks: Map<string, LadderNetwork>;\n  currentNetworkId: string | null;\n  selectedElementIds: Set<string>;\n  clipboard: LadderElement[];\n  gridConfig: GridConfig;\n  mode: 'edit' | 'monitor';\n  monitoringState: LadderMonitoringState | null;\n  isDirty: boolean;\n  history: HistorySnapshot[];\n  historyIndex: number;\n}\n```\n\n2. **Actions:**\n- `addNetwork()` / `removeNetwork(id)` / `selectNetwork(id)`\n- `addElement(networkId, element, position)` / `removeElement(id)` / `moveElement(id, position)`\n- `updateElement(id, updates)` / `duplicateElement(id)`\n- `setSelection(ids)` / `toggleSelection(id)` / `clearSelection()` / `selectAll()`\n- `copyToClipboard()` / `pasteFromClipboard(position)` / `cutSelection()`\n- `undo()` / `redo()` / `pushHistory()`\n- `startMonitoring()` / `stopMonitoring()` / `updateMonitoringState(state)`\n- `forceDevice(address, value)` / `releaseForce(address)`\n- `loadFromAST(ast)` / `exportToAST()`\n- `clearAll()` / `markSaved()`\n\n3. **Selectors:**\n- `selectCurrentNetwork`, `selectElements`, `selectSelectedElements`\n- `selectMonitoringState`, `selectCanUndo`, `selectCanRedo`\n\n4. **Middleware:** Use `devtools` and `immer` middleware like canvasStore\n\n5. **History Management:** Implement max 50 snapshots with proper cloning",
        "testStrategy": "1. Unit tests for all store actions\n2. Verify undo/redo correctly restores state\n3. Test selection operations (single, multi, range)\n4. Test clipboard operations\n5. Verify history doesn't exceed max size\n6. Test monitoring state updates",
        "priority": "high",
        "dependencies": [
          "70"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Ladder Store TypeScript Types and Interfaces",
            "description": "Create the TypeScript type definitions for all ladder-related data structures including LadderNetwork, LadderElement, LadderMonitoringState, GridConfig, HistorySnapshot, and the main LadderState/LadderActions interfaces.",
            "dependencies": [],
            "details": "Create type definitions in `src/stores/ladderStore.ts` following the canvasStore.ts pattern:\n\n1. **LadderElement Types:**\n```typescript\ntype LadderElementType = 'contact_no' | 'contact_nc' | 'contact_p' | 'contact_n' | 'coil' | 'coil_set' | 'coil_reset' | 'timer_ton' | 'timer_tof' | 'timer_tmr' | 'counter_ctu' | 'counter_ctd' | 'counter_ctud' | 'compare' | 'wire_h' | 'wire_v' | 'wire_corner' | 'wire_junction';\n\ninterface LadderElement {\n  id: string;\n  type: LadderElementType;\n  networkId: string;\n  row: number;\n  col: number;\n  address?: string;\n  preset?: number;\n  comment?: string;\n}\n```\n\n2. **LadderNetwork Interface:**\n```typescript\ninterface LadderNetwork {\n  id: string;\n  name: string;\n  elements: Map<string, LadderElement>;\n  rowCount: number;\n}\n```\n\n3. **GridConfig Interface:**\n```typescript\ninterface GridConfig {\n  columns: number;\n  cellWidth: number;\n  cellHeight: number;\n  showPowerRail: boolean;\n  showNeutralRail: boolean;\n}\n```\n\n4. **LadderMonitoringState Interface:**\n```typescript\ninterface LadderMonitoringState {\n  elementStates: Map<string, boolean>;\n  wireStates: Map<string, boolean>;\n  timerValues: Map<string, { elapsed: number; preset: number }>;\n  counterValues: Map<string, { current: number; preset: number }>;\n  forcedAddresses: Map<string, { value: boolean; original: boolean }>;\n}\n```\n\n5. **HistorySnapshot for undo/redo:**\n```typescript\ninterface HistorySnapshot {\n  networks: Array<[string, LadderNetwork]>;\n  currentNetworkId: string | null;\n}\n```\n\n6. **Main State and Actions interfaces following canvasStore pattern.**",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation succeeds. Ensure all interfaces are properly exported. Test that types are compatible with immer middleware requirements (no readonly constraints that prevent mutation).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Core State and Network Management Actions",
            "description": "Implement the Zustand store initialization with initial state, and create network management actions (addNetwork, removeNetwork, selectNetwork) with proper history tracking.",
            "dependencies": [
              1
            ],
            "details": "Set up the store structure following canvasStore.ts exactly:\n\n1. **Constants:**\n```typescript\nconst MAX_HISTORY_SIZE = 50;\nconst DEFAULT_COLUMNS = 10;\nconst DEFAULT_CELL_WIDTH = 80;\nconst DEFAULT_CELL_HEIGHT = 40;\n```\n\n2. **Initial State:**\n```typescript\nconst initialState: LadderState = {\n  networks: new Map(),\n  currentNetworkId: null,\n  selectedElementIds: new Set(),\n  clipboard: [],\n  gridConfig: {\n    columns: DEFAULT_COLUMNS,\n    cellWidth: DEFAULT_CELL_WIDTH,\n    cellHeight: DEFAULT_CELL_HEIGHT,\n    showPowerRail: true,\n    showNeutralRail: true,\n  },\n  mode: 'edit',\n  monitoringState: null,\n  isDirty: false,\n  history: [],\n  historyIndex: -1,\n};\n```\n\n3. **Store Creation with Middleware:**\n```typescript\nexport const useLadderStore = create<LadderStore>()(\n  devtools(\n    immer((set, get) => ({ ... })),\n    { name: 'ladder-store' }\n  )\n);\n```\n\n4. **Helper Functions:**\n- `generateId(prefix: string)` for unique IDs\n- `createSnapshot(networks, currentNetworkId)` for history\n- `restoreSnapshot(snapshot)` for undo/redo\n- `pushHistory(state)` helper to manage history stack\n\n5. **Network Actions:**\n- `addNetwork()`: Create new network with unique ID, push history, set as current\n- `removeNetwork(id)`: Remove network, clear selection if in that network, push history\n- `selectNetwork(id)`: Set currentNetworkId, clear selection",
            "status": "pending",
            "testStrategy": "Unit test addNetwork creates network with correct structure. Test removeNetwork properly cleans up references. Verify selectNetwork updates currentNetworkId. Check history is pushed on network modifications.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Element CRUD and Selection Actions",
            "description": "Create actions for element management (add, remove, move, update, duplicate) and selection operations (setSelection, toggleSelection, clearSelection, selectAll) with proper history tracking.",
            "dependencies": [
              2
            ],
            "details": "Implement element and selection actions:\n\n1. **Element Actions:**\n- `addElement(networkId, element, position)`: Validate position, create element with generated ID, add to network's elements Map, push history\n- `removeElement(id)`: Find element across networks, remove from Map, remove from selection, push history\n- `moveElement(id, position)`: Update element's row/col, validate bounds, push history\n- `updateElement(id, updates)`: Partial update (address, preset, comment), push history\n- `duplicateElement(id)`: Copy element with new ID, offset position by 1 cell, push history\n\n2. **Selection Actions:**\n- `setSelection(ids)`: Replace selectedElementIds with new Set(ids)\n- `toggleSelection(id)`: Add/remove from Set\n- `clearSelection()`: Empty the Set\n- `selectAll()`: Add all element IDs from current network to selection\n\n3. **Validation Helper:**\n```typescript\nfunction isValidPosition(network: LadderNetwork, row: number, col: number, excludeId?: string): boolean {\n  // Check bounds and no overlap\n}\n```\n\n4. **Ensure history is pushed BEFORE modifications** (matching canvasStore pattern):\n```typescript\n// Push history\nconst snapshot = createSnapshot(state.networks, state.currentNetworkId);\nstate.history = state.history.slice(0, state.historyIndex + 1);\nstate.history.push(snapshot);\nif (state.history.length > MAX_HISTORY_SIZE) {\n  state.history.shift();\n} else {\n  state.historyIndex++;\n}\n```",
            "status": "pending",
            "testStrategy": "Test addElement creates element with correct properties. Verify removeElement cleans up selection. Test moveElement validates bounds. Test selection operations correctly update selectedElementIds Set. Verify history is pushed for all modifying actions.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Clipboard, Undo/Redo, and Monitoring Actions",
            "description": "Create clipboard operations (copy, cut, paste), history navigation (undo, redo, pushHistory), and monitoring mode actions (startMonitoring, stopMonitoring, updateMonitoringState, forceDevice, releaseForce).",
            "dependencies": [
              3
            ],
            "details": "1. **Clipboard Actions:**\n- `copyToClipboard()`: Deep clone selected elements to clipboard array\n- `cutSelection()`: Copy then remove selected elements, push history\n- `pasteFromClipboard(position)`: Clone clipboard elements with new IDs, offset positions relative to paste position, add to current network, push history\n\n2. **History Actions (matching canvasStore.ts pattern):**\n- `undo()`: If historyIndex >= 0, save current state for redo if at end, restore previous snapshot, decrement historyIndex, clear selection\n- `redo()`: If historyIndex < history.length - 1, increment historyIndex, restore next snapshot, clear selection\n- `pushHistory()`: Manually trigger history snapshot (for external use)\n\n3. **Monitoring Actions:**\n- `startMonitoring()`: Set mode to 'monitor', initialize monitoringState with empty Maps\n- `stopMonitoring()`: Set mode to 'edit', clear monitoringState and forcedAddresses\n- `updateMonitoringState(state)`: Merge incoming state into monitoringState Maps\n- `forceDevice(address, value)`: Add/update forcedAddresses Map entry with forced value and original\n- `releaseForce(address)`: Remove from forcedAddresses Map\n\n4. **Deep Clone Helper for Clipboard:**\n```typescript\nfunction cloneElement(element: LadderElement, newId: string): LadderElement {\n  return { ...element, id: newId };\n}\n```",
            "status": "pending",
            "testStrategy": "Test copyToClipboard stores selected elements. Test cutSelection removes elements after copying. Test pasteFromClipboard creates new elements with unique IDs. Verify undo/redo correctly restores state including networks and selection. Test monitoring state updates and force/release operations.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement AST Integration, Grid Config, and Selectors",
            "description": "Create loadFromAST and exportToAST actions for OneParser integration, grid configuration actions, utility actions (clearAll, markSaved, reset), and all selector functions.",
            "dependencies": [
              4
            ],
            "details": "1. **AST Integration Actions:**\n- `loadFromAST(ast)`: Convert AST to networks/elements structure, clear history, reset state\n```typescript\nloadFromAST: (ast: LadderProgram) => {\n  // Convert AST networks to Map<string, LadderNetwork>\n  // Each AST rung becomes elements in a network\n  // Clear history and set isDirty = false\n}\n```\n- `exportToAST()`: Convert current networks back to AST format for saving\n\n2. **Grid Configuration Actions:**\n- `setGridConfig(config: Partial<GridConfig>)`: Update grid configuration\n- `togglePowerRail()` / `toggleNeutralRail()`: Convenience toggles\n\n3. **Utility Actions:**\n- `clearAll()`: Push history, reset to initial state but keep empty network\n- `markSaved()`: Set isDirty = false\n- `reset()`: Full reset to initialState (no history push)\n\n4. **Selectors (following canvasStore pattern):**\n```typescript\nexport const selectNetworks = (state: LadderStore) => state.networks;\nexport const selectCurrentNetwork = (state: LadderStore) => \n  state.currentNetworkId ? state.networks.get(state.currentNetworkId) : null;\nexport const selectCurrentNetworkId = (state: LadderStore) => state.currentNetworkId;\nexport const selectElements = (state: LadderStore) => {\n  const network = selectCurrentNetwork(state);\n  return network?.elements ?? new Map();\n};\nexport const selectSelectedElementIds = (state: LadderStore) => state.selectedElementIds;\nexport const selectSelectedElements = (state: LadderStore) => { ... };\nexport const selectGridConfig = (state: LadderStore) => state.gridConfig;\nexport const selectMode = (state: LadderStore) => state.mode;\nexport const selectMonitoringState = (state: LadderStore) => state.monitoringState;\nexport const selectIsDirty = (state: LadderStore) => state.isDirty;\nexport const selectCanUndo = (state: LadderStore) => state.historyIndex >= 0;\nexport const selectCanRedo = (state: LadderStore) => state.historyIndex < state.history.length - 1;\nexport const selectClipboard = (state: LadderStore) => state.clipboard;\nexport const selectElementById = (id: string) => (state: LadderStore) => { ... };\nexport const selectNetworkById = (id: string) => (state: LadderStore) => state.networks.get(id);\n```\n\n5. **Export default:**\n```typescript\nexport default useLadderStore;\n```",
            "status": "pending",
            "testStrategy": "Test loadFromAST correctly converts AST structure to store format. Verify exportToAST produces valid AST. Test all selectors return correct data. Verify clearAll resets state but preserves structure. Test markSaved clears dirty flag. Integration test with mock AST data.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Create Zustand store for LadderEditor state management with history/undo, following canvasStore.ts patterns with immer middleware"
      },
      {
        "id": "72",
        "title": "Implement Basic Ladder Grid Component",
        "description": "Create the core LadderGrid component that renders a configurable grid with power rail (left), neutral rail (right), and empty cells for element placement.",
        "details": "Create `src/components/LadderEditor/LadderGrid.tsx`:\n\n1. **Grid Layout:**\n```tsx\ninterface LadderGridProps {\n  networkId: string;\n  columnCount?: number; // default 10\n  cellWidth?: number; // default 80\n  cellHeight?: number; // default 40\n  readonly?: boolean;\n}\n```\n\n2. **Rendering Structure:**\n- Use CSS Grid for layout: `grid-template-columns: 30px repeat(${columns}, ${cellWidth}px) 30px`\n- Left column: PowerRail component (always visible)\n- Middle columns: LadderCell components (draggable targets)\n- Right column: NeutralRail component\n\n3. **Components to Create:**\n- `PowerRail.tsx`: Vertical power rail with connection points\n- `NeutralRail.tsx`: Vertical neutral rail with connection points\n- `LadderCell.tsx`: Empty cell that accepts dropped elements\n\n4. **Cell Rendering:**\n```tsx\nconst LadderCell = ({ row, col, element, isSelected, onDrop }) => (\n  <div\n    className={cn(\n      'border border-dashed border-neutral-700',\n      'flex items-center justify-center',\n      isSelected && 'ring-2 ring-blue-500',\n      'transition-colors hover:bg-neutral-800/50'\n    )}\n    style={{ width: cellWidth, height: cellHeight }}\n  >\n    {element && <LadderElementRenderer element={element} />}\n  </div>\n);\n```\n\n5. **Grid Lines:** Add subtle grid lines using Tailwind borders\n\n6. **Row Headers:** Optional row numbers on the left (for network identification)\n\n7. **Viewport:** Wrap grid in scrollable container with overflow-auto",
        "testStrategy": "1. Grid renders correct number of columns and rows\n2. Power and neutral rails display correctly\n3. Cells are clickable and show hover states\n4. Grid is responsive to column count changes\n5. Scrolling works for large grids\n6. Selection highlighting appears on clicked cells",
        "priority": "high",
        "dependencies": [
          "70",
          "71"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create LadderGrid Base Component with CSS Grid Layout",
            "description": "Implement the core LadderGrid.tsx component with CSS Grid-based layout structure supporting configurable column count and cell dimensions.",
            "dependencies": [],
            "details": "Create `src/components/LadderEditor/LadderGrid.tsx` with:\n1. Define LadderGridProps interface with networkId, columnCount (default 10), cellWidth (default 80), cellHeight (default 40), readonly\n2. Implement CSS Grid layout using `grid-template-columns: 30px repeat(${columns}, ${cellWidth}px) 30px`\n3. Create scrollable container wrapper with overflow-auto for viewport handling\n4. Add responsive width calculation based on props\n5. Implement grid lines using Tailwind border utilities (border-dashed, border-neutral-700)",
            "status": "pending",
            "testStrategy": "1. Verify grid renders with correct column count\n2. Test default props (10 columns, 80px width, 40px height)\n3. Verify custom dimensions are applied correctly\n4. Test scrolling behavior for large grids\n5. Verify CSS Grid template is generated correctly",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement PowerRail and NeutralRail Components",
            "description": "Create the PowerRail (left column) and NeutralRail (right column) components that display vertical rails with connection points.",
            "dependencies": [
              1
            ],
            "details": "Create rail components:\n1. `PowerRail.tsx`: Vertical power rail spanning all rows\n   - Render as left-most column (30px width)\n   - Add connection points at each row\n   - Use consistent visual style (typically a vertical line with horizontal stubs)\n2. `NeutralRail.tsx`: Vertical neutral rail\n   - Render as right-most column (30px width)\n   - Add connection points at each row\n   - Visual distinction from power rail\n3. Both components should accept row count prop for dynamic height\n4. Add hover states for connection points",
            "status": "pending",
            "testStrategy": "1. Verify PowerRail renders in leftmost column position\n2. Verify NeutralRail renders in rightmost column position\n3. Test connection points align with row heights\n4. Verify hover states on connection points\n5. Test with varying row counts",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement LadderCell Component with Selection States",
            "description": "Create the LadderCell component that represents individual grid cells with element rendering, selection highlighting, and hover states.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/LadderEditor/LadderCell.tsx`:\n1. Implement LadderCell props: row, col, element, isSelected, onDrop, readonly\n2. Render styled div with:\n   - Base styles: border border-dashed border-neutral-700\n   - Flex centering for content\n   - Selection ring: ring-2 ring-blue-500 when isSelected\n   - Hover state: bg-neutral-800/50 transition\n   - Dynamic width/height from props\n3. Conditionally render LadderElementRenderer when element exists\n4. Handle click events for selection\n5. Support drop target indicator styles",
            "status": "pending",
            "testStrategy": "1. Verify cell renders with correct dimensions\n2. Test selection highlight appears when isSelected=true\n3. Verify hover state changes background\n4. Test element rendering when element prop provided\n5. Test click handler triggers selection callback",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Virtualized Row Rendering",
            "description": "Add virtualization support for efficient rendering of large ladder programs using windowing technique to only render visible rows.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement virtualization:\n1. Install or use existing virtualization library (react-virtual or similar)\n2. Create useVirtualizedRows hook:\n   - Calculate visible rows based on container scroll position\n   - Maintain buffer rows above/below viewport (overscan)\n   - Handle dynamic row heights if needed\n3. Modify LadderGrid to use virtual list:\n   - Track scroll container ref\n   - Render only visible rows plus overscan\n   - Use absolute positioning or transform for row placement\n4. Optimize re-renders with useMemo for row data\n5. Handle scroll events efficiently with throttling",
            "status": "pending",
            "testStrategy": "1. Verify only visible rows plus overscan are rendered\n2. Test smooth scrolling with 100+ rows\n3. Verify memory usage stays constant regardless of row count\n4. Test scroll position preservation on re-render\n5. Performance test with large datasets",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Keyboard Navigation and Selection Management",
            "description": "Add keyboard navigation support for moving selection between cells and selection management for single/multi-cell selection.",
            "dependencies": [
              1,
              3
            ],
            "details": "Implement navigation and selection:\n1. Create useGridNavigation hook:\n   - Track current selection (row, col)\n   - Handle arrow key navigation (up, down, left, right)\n   - Tab/Shift+Tab for horizontal movement\n   - Home/End for row start/end\n   - Ctrl+Home/End for grid start/end\n2. Create useGridSelection hook:\n   - Single cell selection on click\n   - Multi-select with Shift+Click (range)\n   - Ctrl+Click for toggle selection\n   - Track selected cells Set\n3. Add keyboard event listeners to grid container\n4. Ensure focus management (tabIndex, focus states)\n5. Optional row headers with row numbers for network identification",
            "status": "pending",
            "testStrategy": "1. Test arrow key navigation moves selection correctly\n2. Verify Tab moves to next cell, Shift+Tab to previous\n3. Test Home/End keys for row navigation\n4. Verify Shift+Click creates range selection\n5. Test Ctrl+Click toggles individual cell selection\n6. Verify focus is maintained during navigation",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Build LadderGrid component with virtualized row rendering, keyboard navigation, selection management, and responsive column width"
      },
      {
        "id": "73",
        "title": "Implement Ladder Element Components",
        "description": "Create React components for all ladder diagram elements including contacts (NO, NC, P, N), coils (standard, set, reset), and their visual representations.",
        "details": "Create `src/components/LadderEditor/elements/` directory:\n\n1. **Contact Components:**\n- `Contact.tsx`: Base contact component with variants\n```tsx\ninterface ContactProps {\n  type: 'no' | 'nc' | 'p' | 'n';\n  address: string;\n  label?: string;\n  isEnergized?: boolean; // for monitoring\n  isForced?: boolean;\n  onDoubleClick?: () => void;\n}\n\n// Visual representations:\n// NO: ──[ ]──  (open square brackets)\n// NC: ──[/]──  (with diagonal line)\n// P:  ──[↑]──  (rising edge arrow)\n// N:  ──[↓]──  (falling edge arrow)\n```\n\n2. **Coil Components:**\n- `Coil.tsx`: Base coil component with variants\n```tsx\ninterface CoilProps {\n  type: 'output' | 'set' | 'reset';\n  address: string;\n  label?: string;\n  isEnergized?: boolean;\n  isForced?: boolean;\n}\n\n// Visual representations:\n// Output: ──( )──  (parentheses)\n// Set:    ──(S)──  (S inside)\n// Reset:  ──(R)──  (R inside)\n```\n\n3. **Styling:**\n- Default state: neutral-400 stroke\n- Energized (ON): green-500 fill with green-400 stroke\n- Coil ON: red-500 fill\n- Forced: yellow-500 border ring\n- Use SVG for crisp rendering at all sizes\n\n4. **Element Renderer:**\n```tsx\n// LadderElementRenderer.tsx\nconst LadderElementRenderer = ({ element, monitoring }) => {\n  switch (element.type) {\n    case 'contact_no': return <Contact type=\"no\" {...props} />;\n    case 'contact_nc': return <Contact type=\"nc\" {...props} />;\n    // ... etc\n  }\n};\n```\n\n5. **Address Display:** Show address below element (e.g., \"X0\", \"Y1\")\n\n6. **Hover State:** Show tooltip with full device info on hover",
        "testStrategy": "1. All contact types render with correct visual symbols\n2. All coil types render with correct visual symbols\n3. Energized state shows green fill for contacts\n4. Energized state shows red fill for coils\n5. Forced state shows yellow border\n6. Address labels display correctly\n7. Double-click triggers edit callback",
        "priority": "high",
        "dependencies": [
          "70",
          "72"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Contact Component with SVG Rendering",
            "description": "Build the base Contact component that renders all four contact types (NO, NC, P, N) using SVG for crisp visuals at all zoom levels.",
            "dependencies": [],
            "details": "Create `src/components/LadderEditor/elements/Contact.tsx` with:\n\n1. **Interface Definition:**\n```tsx\ninterface ContactProps {\n  type: 'no' | 'nc' | 'p' | 'n';\n  address: string;\n  label?: string;\n  isEnergized?: boolean;\n  isForced?: boolean;\n  onDoubleClick?: () => void;\n}\n```\n\n2. **SVG Rendering for Each Type:**\n- NO (Normally Open): Two vertical lines with horizontal connectors `──[ ]──`\n- NC (Normally Closed): Same as NO with diagonal line through `──[/]──`\n- P (Positive Edge): Square with rising edge arrow `──[↑]──`\n- N (Negative Edge): Square with falling edge arrow `──[↓]──`\n\n3. **Component Structure:**\n- Use `<svg>` with viewBox for scalability\n- Render contact symbol based on `type` prop\n- Display address label below the symbol\n- Forward `onDoubleClick` for editing functionality",
            "status": "pending",
            "testStrategy": "1. Render each contact type and verify correct SVG symbol appears\n2. Verify address label displays correctly below contact\n3. Test onDoubleClick callback fires when contact is double-clicked\n4. Snapshot tests for each contact type variant",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Coil Component with SVG Rendering",
            "description": "Build the base Coil component that renders all three coil types (output, set, reset) using SVG graphics.",
            "dependencies": [],
            "details": "Create `src/components/LadderEditor/elements/Coil.tsx` with:\n\n1. **Interface Definition:**\n```tsx\ninterface CoilProps {\n  type: 'output' | 'set' | 'reset';\n  address: string;\n  label?: string;\n  isEnergized?: boolean;\n  isForced?: boolean;\n  onDoubleClick?: () => void;\n}\n```\n\n2. **SVG Rendering for Each Type:**\n- Output (Standard): Parentheses shape `──( )──`\n- Set: Circle with 'S' character inside `──(S)──`\n- Reset: Circle with 'R' character inside `──(R)──`\n\n3. **Component Structure:**\n- Use `<svg>` with viewBox for scalability\n- Render coil symbol based on `type` prop\n- Center S/R text properly within the coil circle\n- Display address label below the coil\n- Forward `onDoubleClick` for editing functionality",
            "status": "pending",
            "testStrategy": "1. Render each coil type and verify correct SVG symbol appears\n2. Verify S and R characters are centered in set/reset coils\n3. Verify address label displays correctly below coil\n4. Test onDoubleClick callback fires when coil is double-clicked",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Element State Styling System",
            "description": "Create a consistent styling system for element states including default, energized, and forced states with proper color indicators.",
            "dependencies": [
              1,
              2
            ],
            "details": "Update Contact and Coil components with state-based styling:\n\n1. **Color Constants (create shared styles file):**\n```tsx\n// elements/styles.ts\nexport const ELEMENT_COLORS = {\n  default: { stroke: 'rgb(163, 163, 163)', fill: 'transparent' }, // neutral-400\n  energizedContact: { stroke: 'rgb(74, 222, 128)', fill: 'rgb(34, 197, 94)' }, // green-400/500\n  energizedCoil: { stroke: 'rgb(248, 113, 113)', fill: 'rgb(239, 68, 68)' }, // red-400/500\n  forced: { ring: 'rgb(234, 179, 8)' }, // yellow-500\n};\n```\n\n2. **Dynamic Styling Logic:**\n- Apply `energizedContact` colors when `isEnergized=true` on contacts\n- Apply `energizedCoil` colors when `isEnergized=true` on coils\n- Add yellow ring/border when `isForced=true`\n- Combine energized + forced states correctly\n\n3. **CSS Classes or Tailwind Integration:**\n- Use CSS-in-JS or Tailwind classes for state management\n- Ensure smooth transitions between states for monitoring mode",
            "status": "pending",
            "testStrategy": "1. Contact shows neutral-400 stroke in default state\n2. Contact shows green-500 fill when energized\n3. Coil shows red-500 fill when energized\n4. Both show yellow-500 ring when forced\n5. Combined energized+forced state displays correctly",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create LadderElementRenderer Component",
            "description": "Build a switch-based renderer component that maps element types to their corresponding Contact or Coil components.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create `src/components/LadderEditor/elements/LadderElementRenderer.tsx`:\n\n1. **Props Interface:**\n```tsx\ninterface LadderElementRendererProps {\n  element: {\n    type: 'contact_no' | 'contact_nc' | 'contact_p' | 'contact_n' | 'coil' | 'coil_set' | 'coil_reset';\n    address: string;\n    label?: string;\n  };\n  monitoring?: {\n    isEnergized: boolean;\n    isForced: boolean;\n  };\n  onDoubleClick?: () => void;\n}\n```\n\n2. **Switch Logic:**\n```tsx\nswitch (element.type) {\n  case 'contact_no': return <Contact type=\"no\" {...props} />;\n  case 'contact_nc': return <Contact type=\"nc\" {...props} />;\n  case 'contact_p': return <Contact type=\"p\" {...props} />;\n  case 'contact_n': return <Contact type=\"n\" {...props} />;\n  case 'coil': return <Coil type=\"output\" {...props} />;\n  case 'coil_set': return <Coil type=\"set\" {...props} />;\n  case 'coil_reset': return <Coil type=\"reset\" {...props} />;\n  default: return null;\n}\n```\n\n3. **Export Barrel File:**\n- Create `elements/index.ts` exporting all components",
            "status": "pending",
            "testStrategy": "1. Renderer returns correct Contact component for contact_no/nc/p/n types\n2. Renderer returns correct Coil component for coil/set/reset types\n3. Monitoring props are passed through correctly\n4. Unknown element type returns null without error",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create LadderCell Component with Interaction Features",
            "description": "Build the LadderCell component that wraps elements with selection states, connection indicators, hover tooltips, and drag-drop integration points.",
            "dependencies": [
              4
            ],
            "details": "Create `src/components/LadderEditor/LadderCell.tsx`:\n\n1. **Props Interface:**\n```tsx\ninterface LadderCellProps {\n  element?: LadderElement | null;\n  row: number;\n  col: number;\n  isSelected?: boolean;\n  isDropTarget?: boolean;\n  hasLeftConnection?: boolean;\n  hasRightConnection?: boolean;\n  monitoring?: MonitoringState;\n  onSelect?: (row: number, col: number) => void;\n  onDoubleClick?: (element: LadderElement) => void;\n}\n```\n\n2. **Visual Features:**\n- Selection highlight (blue border/background)\n- Drop target highlight for drag-drop\n- Connection lines (horizontal) to adjacent cells\n- Empty cell placeholder styling\n\n3. **Hover Tooltip:**\n- Show device info on hover: address, type, current value, forced status\n- Use a tooltip library or custom implementation\n\n4. **Event Handlers:**\n- Click to select cell\n- Double-click to edit element\n- Prepare data attributes for @dnd-kit integration (droppable area)\n\n5. **Grid Integration:**\n- Fixed cell dimensions matching ladder grid layout\n- Responsive to grid zoom level",
            "status": "pending",
            "testStrategy": "1. Empty cell renders with placeholder styling\n2. Cell with element renders LadderElementRenderer\n3. Selected cell shows blue highlight\n4. Hover shows tooltip with device info\n5. Click handler calls onSelect with correct row/col\n6. Double-click opens element editor\n7. Connection indicators display correctly",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Create LadderCell component with element rendering, selection states, connection indicators, and drag-drop integration"
      },
      {
        "id": "74",
        "title": "Implement Timer and Counter Element Components",
        "description": "Create React components for timer blocks (TON, TOF, TMR) and counter blocks (CTU, CTD, CTUD) with preset/elapsed value displays.",
        "details": "Create additional components in `src/components/LadderEditor/elements/`:\n\n1. **Timer Component:**\n```tsx\n// Timer.tsx\ninterface TimerProps {\n  type: 'ton' | 'tof' | 'tmr';\n  address: string; // e.g., 'T0'\n  presetTime: number; // PT in ms\n  elapsedTime?: number; // ET in ms (monitoring)\n  isRunning?: boolean;\n  isDone?: boolean;\n  onEdit?: () => void;\n}\n\n// Visual: Box with timer symbol\n// ┌─────────┐\n// │  TON    │\n// │ T0      │\n// │ PT: 1000│\n// │ ET: 500 │ (monitoring only)\n// │ [====  ]│ (progress bar, monitoring)\n// └─────────┘\n```\n\n2. **Counter Component:**\n```tsx\n// Counter.tsx\ninterface CounterProps {\n  type: 'ctu' | 'ctd' | 'ctud';\n  address: string; // e.g., 'C0'\n  presetValue: number; // PV\n  currentValue?: number; // CV (monitoring)\n  isDone?: boolean;\n  onEdit?: () => void;\n}\n\n// Visual: Box with counter symbol\n// ┌─────────┐\n// │  CTU    │\n// │ C0      │\n// │ PV: 10  │\n// │ CV: 5   │ (monitoring only)\n// └─────────┘\n```\n\n3. **Block Sizing:** Timer and counter blocks occupy 2 columns width (160px) and 2 rows height (80px)\n\n4. **Styling States:**\n- Idle: neutral-700 background\n- Running (timer): yellow-900/30 background with pulse animation\n- Done: green-900/30 background\n- Counting (counter): blue-900/30 background\n\n5. **Progress Visualization:**\n- Timer: Horizontal progress bar showing ET/PT ratio\n- Counter: Optional progress bar showing CV/PV ratio\n\n6. **Input/Output Pins:**\n- Timer: EN (enable), RESET, Q (done output)\n- Counter: CU/CD (count up/down), RESET, Q (done output)",
        "testStrategy": "1. Timer types render with correct labels (TON, TOF, TMR)\n2. Counter types render with correct labels (CTU, CTD, CTUD)\n3. Progress bar displays correctly based on ET/PT ratio\n4. Running state shows animation\n5. Done state shows green background\n6. PT/PV values display correctly\n7. ET/CV values only show in monitoring mode",
        "priority": "medium",
        "dependencies": [
          "73"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Timer Component Base Structure",
            "description": "Set up the Timer.tsx component with TimerProps interface, basic visual structure showing timer symbol, type label (TON/TOF/TMR), address display, and preset/elapsed time values.",
            "dependencies": [],
            "details": "Create `src/components/LadderEditor/elements/Timer.tsx` with:\n1. Define TimerProps interface with type ('ton'|'tof'|'tmr'), address, presetTime, elapsedTime, isRunning, isDone, and onEdit props\n2. Create box layout with dimensions 160px width x 80px height (2 columns x 2 rows)\n3. Display timer type label (TON, TOF, TMR) at top\n4. Show address (e.g., 'T0') below type\n5. Display PT (preset time) value in ms\n6. Display ET (elapsed time) value when provided (monitoring mode)\n7. Use Tailwind CSS for styling with neutral-700 base background",
            "status": "pending",
            "testStrategy": "Verify Timer component renders with correct type labels (TON, TOF, TMR), displays address and PT/ET values correctly, and maintains proper dimensions (160px x 80px)",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Counter Component Base Structure",
            "description": "Set up the Counter.tsx component with CounterProps interface, basic visual structure showing counter symbol, type label (CTU/CTD/CTUD), address display, and preset/current values.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/LadderEditor/elements/Counter.tsx` with:\n1. Define CounterProps interface with type ('ctu'|'ctd'|'ctud'), address, presetValue, currentValue, isDone, and onEdit props\n2. Create box layout with dimensions 160px width x 80px height (2 columns x 2 rows)\n3. Display counter type label (CTU, CTD, CTUD) at top\n4. Show address (e.g., 'C0') below type\n5. Display PV (preset value) \n6. Display CV (current value) when provided (monitoring mode)\n7. Use Tailwind CSS for styling matching Timer component style",
            "status": "pending",
            "testStrategy": "Verify Counter component renders with correct type labels (CTU, CTD, CTUD), displays address and PV/CV values correctly, and maintains proper dimensions (160px x 80px)",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Styling States and Animations",
            "description": "Add visual styling states for both Timer and Counter components including idle, running, done, and counting states with appropriate background colors and animations.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement state-based styling for both components:\n1. Idle state: neutral-700 background (default)\n2. Running state (timer): yellow-900/30 background with CSS pulse animation using @keyframes\n3. Done state: green-900/30 background for both timer and counter when isDone is true\n4. Counting state (counter): blue-900/30 background when counter is actively counting\n5. Create utility function or shared styles for common state backgrounds\n6. Implement smooth transitions between states using Tailwind transition classes\n7. Add border styling to indicate selected/hovered states",
            "status": "pending",
            "testStrategy": "Test that running timer shows yellow background with pulse animation, done state shows green background, counting counter shows blue background, and transitions between states are smooth",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Progress Visualization Bars",
            "description": "Add horizontal progress bar visualization for Timer components showing ET/PT ratio and optional progress bar for Counter components showing CV/PV ratio.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create progress bar visualization:\n1. Timer progress bar: Horizontal bar at bottom of timer block\n   - Width percentage = (elapsedTime / presetTime) * 100\n   - Color: gradient from neutral to yellow (running) or green (done)\n   - Show bar only when elapsedTime is provided (monitoring mode)\n2. Counter progress bar (optional):\n   - Width percentage = (currentValue / presetValue) * 100\n   - Color: blue gradient for counting state\n   - Handle CTD (count down) by inverting calculation\n3. Use consistent bar height (8px) and rounded corners\n4. Add subtle animation for value changes",
            "status": "pending",
            "testStrategy": "Verify progress bar displays correctly based on ET/PT and CV/PV ratios, handles edge cases (0 values, exceeding preset), and updates smoothly during monitoring",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Input/Output Pin Connections",
            "description": "Add visual input/output pin representations for Timer (EN, RESET, Q) and Counter (CU/CD, RESET, Q) components with connection points for ladder logic wiring.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create pin connection system for both components:\n1. Timer pins:\n   - Left side inputs: EN (enable), RESET\n   - Right side output: Q (done output)\n2. Counter pins:\n   - Left side inputs: CU (count up) / CD (count down), RESET\n   - CTUD type needs both CU and CD pins\n   - Right side output: Q (done output)\n3. Pin visual representation:\n   - Small circles (6px) at connection points\n   - Labels adjacent to pins (EN, Q, etc.)\n   - Highlight active/energized pins during monitoring\n4. Position pins correctly for grid alignment\n5. Export pin positions for drag-and-drop connection system",
            "status": "pending",
            "testStrategy": "Verify all pin types render at correct positions, pins are properly labeled, active state highlighting works during monitoring, and pin positions align with grid system for connections",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement contact element components (NO, NC, positive/negative edge) with visual states, address display, and interactive feedback"
      },
      {
        "id": "75",
        "title": "Implement Wire and Connection Components",
        "description": "Create wire components for horizontal, vertical, corner, and junction connections with energized state visualization.",
        "details": "Create wire components in `src/components/LadderEditor/elements/`:\n\n1. **Wire Types:**\n```tsx\n// Wire.tsx\ninterface WireProps {\n  type: 'horizontal' | 'vertical' | 'corner_tl' | 'corner_tr' | 'corner_bl' | 'corner_br' | 'junction_t' | 'junction_b' | 'junction_l' | 'junction_r' | 'cross';\n  isEnergized?: boolean;\n}\n```\n\n2. **Visual Representations (using SVG):**\n```\nHorizontal: ────────\nVertical:   │\n            │\nCorner TL:  ┌──\nCorner TR:  ──┐\nCorner BL:  └──\nCorner BR:  ──┘\nJunction T: ──┬──\nJunction B: ──┴──\nCross:      ──┼──\n```\n\n3. **Styling:**\n```tsx\nconst wireStyles = {\n  default: 'stroke-neutral-400 stroke-2',\n  energized: 'stroke-green-500 stroke-[3px]',\n};\n```\n\n4. **Energized Animation:**\n- Add subtle glow effect: `filter: drop-shadow(0 0 2px rgb(34 197 94))`\n- Optional: Flow animation using CSS keyframes with moving dash pattern\n\n5. **Auto-Wire Generation Utility:**\n```typescript\n// utils/wireGenerator.ts\nfunction generateWires(\n  elements: LadderElement[],\n  gridConfig: GridConfig\n): LadderWire[] {\n  // Algorithm:\n  // 1. For column 0, connect to power rail\n  // 2. For output elements, connect to neutral rail\n  // 3. Connect horizontally between adjacent elements\n  // 4. For parallel branches, add vertical wires at branch/merge points\n}\n```\n\n6. **Connection Points:**\n- Each element has left and right connection points\n- Wires connect between these points\n- Validate connections (output can't connect to output)",
        "testStrategy": "1. All wire types render with correct SVG paths\n2. Energized wires show green color and glow\n3. Flow animation plays when enabled\n4. Auto-wire generation creates correct horizontal connections\n5. Auto-wire connects elements to power rail correctly\n6. Vertical wires generated correctly for parallel branches\n7. Wire intersection points render as junctions",
        "priority": "medium",
        "dependencies": [
          "73"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Wire Types Interface and Props",
            "description": "Create TypeScript interfaces for wire components including WireProps with all wire types (horizontal, vertical, corners, junctions, cross) and energized state.",
            "dependencies": [],
            "details": "Create `src/components/LadderEditor/elements/Wire.tsx` with the WireProps interface defining all 11 wire types: 'horizontal', 'vertical', 'corner_tl', 'corner_tr', 'corner_bl', 'corner_br', 'junction_t', 'junction_b', 'junction_l', 'junction_r', and 'cross'. Include optional isEnergized boolean prop. Also define LadderWire type for the wire data structure with position, type, and state information.",
            "status": "pending",
            "testStrategy": "Verify TypeScript interfaces compile without errors. Test that all wire types are properly typed and can be instantiated with correct props.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement SVG Wire Visual Components",
            "description": "Create SVG-based visual representations for all wire types including horizontal lines, vertical lines, corners (TL, TR, BL, BR), junctions (T, B, L, R), and cross connections.",
            "dependencies": [
              1
            ],
            "details": "Implement SVG path rendering for each wire type in Wire.tsx component. Use appropriate SVG elements (line, path) to draw: horizontal (────), vertical (│), corner_tl (┌──), corner_tr (──┐), corner_bl (└──), corner_br (──┘), junction_t (──┬──), junction_b (──┴──), junction_l, junction_r, and cross (──┼──). Ensure all wires align with the grid cell dimensions and connect properly at edges.",
            "status": "pending",
            "testStrategy": "Render each wire type and visually verify correct SVG paths. Test that wires align properly within grid cells. Verify corner and junction wires connect correctly at cell boundaries.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Wire Styling and Energized State Visualization",
            "description": "Add styling for default and energized wire states including colors, stroke widths, glow effects, and optional flow animation using CSS keyframes.",
            "dependencies": [
              2
            ],
            "details": "Create wireStyles object with 'default' (stroke-neutral-400 stroke-2) and 'energized' (stroke-green-500 stroke-[3px]) styles. Implement energized glow effect using CSS filter: drop-shadow(0 0 2px rgb(34 197 94)). Add optional flow animation using CSS keyframes with moving dash pattern (stroke-dasharray and stroke-dashoffset animation). Create Tailwind classes or CSS module for wire styling. Ensure smooth transitions between default and energized states.",
            "status": "pending",
            "testStrategy": "Test default wire renders with neutral-400 color and 2px stroke. Test energized wire shows green-500 color, 3px stroke, and glow effect. Verify flow animation plays correctly when enabled. Test transition between states is smooth.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create Auto-Wire Generation Utility",
            "description": "Implement wireGenerator utility function that automatically generates appropriate wires based on element positions, connecting elements to power rails and each other.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/LadderEditor/utils/wireGenerator.ts` with generateWires function that takes LadderElement[] and GridConfig as parameters. Implement algorithm: 1) For column 0 elements, generate horizontal wires connecting to power rail. 2) For output elements (coils), generate horizontal wires connecting to neutral rail. 3) Connect horizontally between adjacent elements in the same rung. 4) For parallel branches, add vertical wires at branch and merge points. 5) Detect and generate appropriate junction/corner wires at intersection points.",
            "status": "pending",
            "testStrategy": "Test single element generates correct power rail connection. Test output elements connect to neutral rail. Test adjacent elements are connected horizontally. Test parallel branches generate correct vertical wires and junctions. Test complex ladder configurations generate correct wire topology.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Connection Points and Wire Validation",
            "description": "Add connection point system for ladder elements with left/right connection points, and implement validation logic to prevent invalid connections (e.g., output to output).",
            "dependencies": [
              2,
              4
            ],
            "details": "Define connection point interface with position (left, right) and type (input, output). Add connection point metadata to each element type: contacts have input on left and output on right; coils have input only. Implement connection validation utility that: 1) Checks if wire endpoints are valid connection points. 2) Validates that outputs don't connect directly to other outputs. 3) Ensures proper flow direction (left to right for horizontal, top to bottom for parallel branches). Integrate validation with auto-wire generation to skip invalid connections.",
            "status": "pending",
            "testStrategy": "Test contacts expose left input and right output connection points. Test coils expose only left input connection point. Verify output-to-output connections are rejected. Test wire validation prevents invalid topologies. Test integrated validation with auto-wire generator produces only valid connections.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement coil element components (output, set, reset, inverted) with visual states and address display"
      },
      {
        "id": "76",
        "title": "Implement Drag and Drop for Ladder Elements",
        "description": "Implement drag-and-drop functionality using @dnd-kit for placing elements from toolbox to grid and moving elements within the grid.",
        "details": "Create drag-and-drop system following existing `useDragDrop.ts` pattern:\n\n1. **Toolbox Component:**\n```tsx\n// LadderToolbox.tsx\nconst toolboxItems: ToolboxItem[] = [\n  { type: 'contact_no', label: 'NO Contact', icon: '[ ]' },\n  { type: 'contact_nc', label: 'NC Contact', icon: '[/]' },\n  { type: 'contact_p', label: 'P Contact', icon: '[↑]' },\n  { type: 'contact_n', label: 'N Contact', icon: '[↓]' },\n  { type: 'coil', label: 'Coil', icon: '( )' },\n  { type: 'coil_set', label: 'Set Coil', icon: '(S)' },\n  { type: 'coil_reset', label: 'Reset Coil', icon: '(R)' },\n  { type: 'timer_ton', label: 'TON Timer', icon: 'TON' },\n  { type: 'timer_tof', label: 'TOF Timer', icon: 'TOF' },\n  { type: 'counter_ctu', label: 'CTU Counter', icon: 'CTU' },\n  { type: 'counter_ctd', label: 'CTD Counter', icon: 'CTD' },\n];\n```\n\n2. **Draggable Toolbox Item:**\n```tsx\nimport { useDraggable } from '@dnd-kit/core';\n\nconst DraggableToolboxItem = ({ item }) => {\n  const { attributes, listeners, setNodeRef, isDragging } = useDraggable({\n    id: `toolbox-${item.type}`,\n    data: { type: 'toolbox-item', elementType: item.type },\n  });\n  // ...\n};\n```\n\n3. **Droppable Grid Cell:**\n```tsx\nimport { useDroppable } from '@dnd-kit/core';\n\nconst DroppableCell = ({ row, col, onDrop }) => {\n  const { setNodeRef, isOver } = useDroppable({\n    id: `cell-${row}-${col}`,\n    data: { type: 'grid-cell', row, col },\n  });\n  // Highlight when drag is over\n};\n```\n\n4. **useLadderDragDrop Hook:**\n```typescript\n// hooks/useLadderDragDrop.ts\nexport function useLadderDragDrop() {\n  const addElement = useLadderStore(s => s.addElement);\n  const moveElement = useLadderStore(s => s.moveElement);\n\n  const handleDragEnd = (event: DragEndEvent) => {\n    const { active, over } = event;\n    if (!over) return;\n\n    const activeData = active.data.current;\n    const overData = over.data.current;\n\n    if (activeData?.type === 'toolbox-item' && overData?.type === 'grid-cell') {\n      // Create new element at grid position\n      addElement(activeData.elementType, { row: overData.row, col: overData.col });\n    } else if (activeData?.type === 'grid-element' && overData?.type === 'grid-cell') {\n      // Move existing element\n      moveElement(activeData.elementId, { row: overData.row, col: overData.col });\n    }\n  };\n\n  return { handleDragEnd };\n}\n```\n\n5. **Validation:** Check if target cell is empty and valid for element type (e.g., coils only in last 2 columns)",
        "testStrategy": "1. Dragging from toolbox shows drag overlay\n2. Dropping on empty cell creates element\n3. Dropping on occupied cell is rejected\n4. Moving element within grid updates position\n5. Coils can only be placed in output columns\n6. Cancel drag with Escape key\n7. Touch support works on mobile",
        "priority": "high",
        "dependencies": [
          "72",
          "73",
          "71"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement LadderToolbox Component with Draggable Items",
            "description": "Create the LadderToolbox component containing all ladder element types (contacts, coils, timers, counters) as draggable items using @dnd-kit's useDraggable hook.",
            "dependencies": [],
            "details": "Create `src/components/LadderEditor/LadderToolbox.tsx` with toolbox items array containing all element types (contact_no, contact_nc, contact_p, contact_n, coil, coil_set, coil_reset, timer_ton, timer_tof, counter_ctu, counter_ctd). Implement DraggableToolboxItem component using useDraggable hook from @dnd-kit/core with proper data attributes (type: 'toolbox-item', elementType). Style the toolbox with icons and labels, showing visual feedback when dragging (isDragging state). Group items by category (Contacts, Coils, Timers, Counters) for better UX.",
            "status": "pending",
            "testStrategy": "1. Verify all toolbox items render with correct icons and labels. 2. Test that dragging an item shows drag overlay. 3. Verify isDragging state changes appropriately. 4. Test keyboard accessibility for drag initiation.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement DroppableCell Component for Grid",
            "description": "Create the DroppableCell component that wraps grid cells and enables them to receive dropped ladder elements using @dnd-kit's useDroppable hook.",
            "dependencies": [
              1
            ],
            "details": "Create DroppableCell component in `src/components/LadderEditor/DroppableCell.tsx` using useDroppable hook from @dnd-kit/core. Each cell should have unique ID (`cell-${row}-${col}`) and data attributes (type: 'grid-cell', row, col). Implement visual feedback for drag-over state (isOver) with highlight styling. Handle both empty cells and cells with existing elements (for move operations). Integrate with existing LadderGrid component to wrap each cell appropriately.",
            "status": "pending",
            "testStrategy": "1. Verify cells highlight when dragging over them. 2. Test isOver state updates correctly on drag enter/leave. 3. Verify cell coordinates are passed correctly in data attribute. 4. Test visual distinction between valid and invalid drop targets.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement useLadderDragDrop Hook with DndContext",
            "description": "Create the useLadderDragDrop hook that handles drag-and-drop logic and integrates with LadderStore for adding and moving elements.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/hooks/useLadderDragDrop.ts` following existing useDragDrop.ts pattern. Implement handleDragEnd function that processes DragEndEvent from @dnd-kit. Handle two scenarios: (1) toolbox-item dropped on grid-cell calls addElement with elementType and position, (2) grid-element dropped on grid-cell calls moveElement with elementId and new position. Set up DndContext provider in LadderEditor with handleDragEnd callback. Implement DragOverlay component for visual drag preview. Connect to useLadderStore actions (addElement, moveElement).",
            "status": "pending",
            "testStrategy": "1. Test dropping toolbox item on empty cell creates element at correct position. 2. Test moving existing element updates its position. 3. Verify dropping outside valid area does nothing. 4. Test cancel drag with Escape key. 5. Verify store state updates correctly after operations.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Placement Validation Logic",
            "description": "Add validation rules to restrict element placement based on element type and grid position, including coil-only output columns and occupied cell detection.",
            "dependencies": [
              3
            ],
            "details": "Create validation functions in `src/components/LadderEditor/utils/placementValidation.ts`. Implement: (1) isValidPlacement(elementType, row, col, existingElements) - checks if placement is allowed, (2) canPlaceCoil(col, gridColumns) - coils only in last 2 columns, (3) isCellOccupied(row, col, elements) - prevents overlap. Integrate validation into handleDragEnd - reject invalid drops with optional user feedback. Add visual indication of valid/invalid drop zones during drag (update isOver styling based on validation). Handle edge cases like horizontal elements spanning multiple cells.",
            "status": "pending",
            "testStrategy": "1. Verify coils can only be placed in last 2 columns. 2. Test that dropping on occupied cell is rejected. 3. Test contacts can be placed in any non-output column. 4. Verify validation feedback appears during drag. 5. Test edge case of timer/counter multi-cell elements.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Timer and Counter Configuration Dialogs",
            "description": "Create configuration dialogs for timer (TON, TOF) and counter (CTU, CTD) elements to set preset values, device addresses, and display current values during monitoring.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create `src/components/LadderEditor/dialogs/TimerConfigDialog.tsx` and `CounterConfigDialog.tsx`. Timer dialog: preset time value input (with unit selection ms/s), device address assignment, show current elapsed time during monitoring. Counter dialog: preset count value input, device address, show current count during monitoring. Implement TimerCounterElement component with visual display showing preset (PV) and current (CV) values. Dialogs should open on double-click or context menu of timer/counter elements. Save configuration to element properties in LadderStore. Style consistent with existing project dialogs.",
            "status": "pending",
            "testStrategy": "1. Test timer dialog opens for TON/TOF elements. 2. Test counter dialog opens for CTU/CTD elements. 3. Verify preset value saves to element properties. 4. Test current value displays correctly in monitoring mode. 5. Verify device address validation. 6. Test dialog cancel does not save changes.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement timer (TON, TOF, RTO) and counter (CTU, CTD) elements with preset/current value display and configuration dialogs"
      },
      {
        "id": "77",
        "title": "Implement Properties Panel and Element Editing",
        "description": "Create a properties panel component that displays and allows editing of selected ladder element properties including address, label, and type-specific settings.",
        "details": "Create properties panel components:\n\n1. **LadderPropertiesPanel.tsx:**\n```tsx\ninterface LadderPropertiesPanelProps {\n  className?: string;\n}\n\nconst LadderPropertiesPanel = ({ className }) => {\n  const selectedElements = useLadderStore(selectSelectedElements);\n  \n  if (selectedElements.length === 0) {\n    return <EmptyState message=\"Select an element to view properties\" />;\n  }\n  \n  if (selectedElements.length > 1) {\n    return <MultiSelectProperties elements={selectedElements} />;\n  }\n  \n  const element = selectedElements[0];\n  return <SingleElementProperties element={element} />;\n};\n```\n\n2. **Property Editors by Element Type:**\n```tsx\n// properties/ContactProperties.tsx\nconst ContactProperties = ({ element }) => (\n  <>\n    <PropertyField label=\"Address\" value={element.address} onChange={...} />\n    <PropertyField label=\"Type\" value={element.type} options={contactTypes} />\n    <PropertyField label=\"Label\" value={element.label} />\n  </>\n);\n\n// properties/TimerProperties.tsx\nconst TimerProperties = ({ element }) => (\n  <>\n    <PropertyField label=\"Address\" value={element.address} />\n    <PropertyField label=\"Type\" value={element.type} options={timerTypes} />\n    <PropertyField label=\"Preset (ms)\" type=\"number\" value={element.properties.pt} />\n  </>\n);\n\n// properties/CounterProperties.tsx\nconst CounterProperties = ({ element }) => (\n  <>\n    <PropertyField label=\"Address\" value={element.address} />\n    <PropertyField label=\"Type\" value={element.type} options={counterTypes} />\n    <PropertyField label=\"Preset Value\" type=\"number\" value={element.properties.pv} />\n  </>\n);\n```\n\n3. **Device Selection Dialog:**\n```tsx\n// dialogs/DeviceSelectDialog.tsx\n// Modal for selecting device address with:\n// - Device type selector (X, Y, M, T, C, D, etc.)\n// - Address number input\n// - Recently used devices list\n// - Search/filter functionality\n```\n\n4. **Inline Editing:** Double-click element to open quick edit popover\n\n5. **Validation:** Validate address format, show errors for invalid input\n\n6. **Apply Changes:** Changes apply immediately via store update",
        "testStrategy": "1. Panel shows 'Select element' when nothing selected\n2. Panel shows correct properties for each element type\n3. Changing address updates element in store\n4. Changing type updates element type\n5. Timer PT field accepts numeric input\n6. Counter PV field accepts numeric input\n7. Invalid address shows error state\n8. Multi-select shows common properties only",
        "priority": "medium",
        "dependencies": [
          "73",
          "74",
          "71"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Core Properties Panel Component",
            "description": "Implement the main LadderPropertiesPanel.tsx component that handles selection state display (empty, single, multi-select) and serves as the container for property editors.",
            "dependencies": [],
            "details": "Create LadderPropertiesPanel.tsx with:\n1. useLadderStore hook to get selectedElements via selectSelectedElements selector\n2. EmptyState component displayed when no elements selected with message 'Select an element to view properties'\n3. MultiSelectProperties component for handling multiple selected elements (showing count and common properties)\n4. SingleElementProperties component that routes to appropriate type-specific editor\n5. Element type detection logic to render correct property editor\n6. className prop support for styling flexibility\n7. Panel header showing element type icon and address",
            "status": "pending",
            "testStrategy": "1. Panel shows EmptyState when selectedElements.length === 0\n2. Panel shows MultiSelectProperties when selectedElements.length > 1\n3. Panel shows SingleElementProperties for single selection\n4. Correct element type detected and displayed in header\n5. className prop applied correctly to container",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Basic Property Editors (Contact, Coil, Timer, Counter)",
            "description": "Create type-specific property editor components for Contact, Coil, Timer, and Counter ladder elements with their respective configurable properties.",
            "dependencies": [
              1
            ],
            "details": "Create property editor components in src/components/LadderEditor/properties/:\n1. PropertyField.tsx - reusable input component supporting text, number, select types with label and onChange\n2. ContactProperties.tsx - Address field, Type select (NO/NC/P/N), Label field\n3. CoilProperties.tsx - Address field, Type select (normal/set/reset), Label field\n4. TimerProperties.tsx - Address field, Type select (TON/TOF/TOFF), Preset (PT) number input in milliseconds, Label\n5. CounterProperties.tsx - Address field, Type select (CTU/CTD/CTUD), Preset Value (PV) number input, Label\n6. Wire store update via useLadderStore's updateElement action on property change\n7. Debounce numeric inputs to prevent excessive store updates",
            "status": "pending",
            "testStrategy": "1. ContactProperties shows address, type, label fields\n2. Type dropdown shows correct options for each element type\n3. Changing address updates element in store\n4. Timer PT field accepts only numeric input\n5. Counter PV field accepts only numeric input\n6. Label changes persist to store\n7. PropertyField renders correct input type based on 'type' prop",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create Device Selection Dialog",
            "description": "Implement a modal dialog component for selecting device addresses with device type selector, address input, recently used list, and search functionality.",
            "dependencies": [
              1
            ],
            "details": "Create dialogs/DeviceSelectDialog.tsx:\n1. Dialog component using existing UI dialog pattern (likely shadcn/ui Dialog)\n2. Device type selector tabs/buttons for X, Y, P, M, K, L, F, T, C, D, S, Z, R device types\n3. Address number input with type-appropriate validation (bit vs word devices)\n4. Recently used devices list stored in localStorage (last 10 used addresses)\n5. Search/filter input to filter device list by address pattern\n6. Device preview showing current value if in monitoring mode\n7. Confirm/Cancel buttons with keyboard support (Enter to confirm, Escape to cancel)\n8. onSelect callback returning full device address string (e.g., 'M00001')\n9. Integration with PropertyField via button that opens dialog",
            "status": "pending",
            "testStrategy": "1. Dialog opens when triggered from PropertyField\n2. Device type selector changes available address range\n3. Address input validates format for selected device type\n4. Recently used list updates on selection\n5. Search filters device list correctly\n6. Enter key confirms selection\n7. Escape key closes dialog without selection\n8. onSelect callback receives correct address format",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Compare and Math Block Property Editors",
            "description": "Create property editors for compare blocks (EQ, GT, LT, GE, LE) and math blocks (ADD, SUB, MUL, DIV) with multi-operand configuration support.",
            "dependencies": [
              2
            ],
            "details": "Create additional property editors:\n1. CompareProperties.tsx - Operand1 address field, Operator select (EQ/GT/LT/GE/LE), Operand2 field (address or constant), Output coil address\n2. MathProperties.tsx - Operand1 address, Operator select (ADD/SUB/MUL/DIV), Operand2 field (address or constant), Destination address for result\n3. OperandField.tsx - compound component allowing toggle between device address and constant value\n4. Support for word device addresses (D, T-data, C-data, Z) as operands\n5. Constant value input with 16-bit signed integer validation (-32768 to 32767)\n6. Data type indicator showing WORD operations\n7. Preview of operation in human-readable format (e.g., 'D0001 + D0002 → D0003')\n8. Validation ensuring destination address is writable device type",
            "status": "pending",
            "testStrategy": "1. CompareProperties renders two operand fields and operator selector\n2. MathProperties renders two operands, operator, and destination\n3. OperandField toggles between address and constant mode\n4. Constant values validated within 16-bit signed range\n5. Operation preview updates as fields change\n6. Destination validation rejects read-only devices\n7. Store updates correctly with all operand configurations",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Validation System and Inline Editing",
            "description": "Implement address format validation with error display and double-click inline editing functionality for quick property changes directly on elements.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement validation and inline editing:\n1. Address validation utility using AddressParser patterns (X/Y 00000-0511, P/M/K/L/F 00000-4095, etc.)\n2. ValidationError component showing red border and error message below field\n3. Real-time validation on input change with debounce\n4. Prevent store update when validation fails\n5. InlineEditPopover.tsx - popover component triggered on element double-click\n6. Quick edit fields: primary address field with device dialog button, type selector if applicable\n7. Apply button or Enter key to confirm changes, Escape or click-away to cancel\n8. Visual feedback on element when inline edit is active (highlight border)\n9. Integration with LadderElement component's onDoubleClick handler\n10. Error summary in properties panel header when any field has validation error",
            "status": "pending",
            "testStrategy": "1. Invalid address format shows validation error\n2. Valid address clears error state\n3. Store not updated when validation fails\n4. Double-click on element opens InlineEditPopover\n5. InlineEditPopover positioned correctly near element\n6. Enter key applies changes and closes popover\n7. Escape key cancels without applying changes\n8. Element shows highlight when inline edit active\n9. Error summary appears in panel header for validation errors",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement compare blocks (EQ, GT, LT, GE, LE) and math blocks (ADD, SUB, MUL, DIV) with operand configuration"
      },
      {
        "id": "78",
        "title": "Implement Keyboard Shortcuts and Context Menu",
        "description": "Add keyboard shortcuts for common operations (delete, copy, paste, undo/redo, navigation) and implement right-click context menu for element operations.",
        "details": "Create keyboard and context menu handling:\n\n1. **Keyboard Shortcuts Hook:**\n```typescript\n// hooks/useLadderKeyboardShortcuts.ts\nexport function useLadderKeyboardShortcuts() {\n  const {\n    removeElement, copyToClipboard, pasteFromClipboard,\n    cutSelection, undo, redo, selectAll, clearSelection,\n    moveElement, selectedElementIds\n  } = useLadderStore();\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Don't handle if in input field\n      if (e.target instanceof HTMLInputElement) return;\n\n      if (e.key === 'Delete' || e.key === 'Backspace') {\n        selectedElementIds.forEach(id => removeElement(id));\n      }\n      if (e.ctrlKey || e.metaKey) {\n        switch (e.key) {\n          case 'c': copyToClipboard(); break;\n          case 'v': pasteFromClipboard(); break;\n          case 'x': cutSelection(); break;\n          case 'z': e.shiftKey ? redo() : undo(); break;\n          case 'y': redo(); break;\n          case 'd': duplicateSelection(); e.preventDefault(); break;\n          case 'a': selectAll(); e.preventDefault(); break;\n        }\n      }\n      // Arrow key navigation\n      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {\n        navigateCells(e.key);\n      }\n      if (e.key === 'Escape') clearSelection();\n      if (e.key === 'Enter') openElementEditor();\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [selectedElementIds]);\n}\n```\n\n2. **Context Menu Component:**\n```tsx\n// LadderContextMenu.tsx\ninterface ContextMenuProps {\n  x: number;\n  y: number;\n  element: LadderElement | null;\n  onClose: () => void;\n}\n\nconst menuItems = [\n  { label: 'Edit Properties', shortcut: 'Enter', action: 'edit' },\n  { label: 'Cut', shortcut: 'Ctrl+X', action: 'cut' },\n  { label: 'Copy', shortcut: 'Ctrl+C', action: 'copy' },\n  { label: 'Paste', shortcut: 'Ctrl+V', action: 'paste' },\n  { label: 'Delete', shortcut: 'Del', action: 'delete' },\n  { divider: true },\n  { label: 'Insert NO Contact', action: 'insert_contact_no' },\n  { label: 'Insert NC Contact', action: 'insert_contact_nc' },\n  { label: 'Insert Coil', action: 'insert_coil' },\n  { divider: true },\n  { label: 'Add Parallel Branch', action: 'add_branch' },\n  { divider: true },\n  { label: 'Cross Reference', action: 'cross_reference' },\n  { label: 'Go to Definition', action: 'goto_definition' },\n];\n```\n\n3. **Right-click Handling:**\n```tsx\nconst handleContextMenu = (e: React.MouseEvent, element?: LadderElement) => {\n  e.preventDefault();\n  setContextMenu({ x: e.clientX, y: e.clientY, element });\n};\n```\n\n4. **Cell Navigation:** Arrow keys move focus between cells",
        "testStrategy": "1. Delete key removes selected elements\n2. Ctrl+C copies selection to clipboard\n3. Ctrl+V pastes from clipboard\n4. Ctrl+Z undoes last action\n5. Ctrl+Y redoes undone action\n6. Arrow keys navigate between cells\n7. Enter opens element editor\n8. Context menu appears on right-click\n9. Context menu closes on click outside\n10. All menu actions execute correctly",
        "priority": "medium",
        "dependencies": [
          "71",
          "76",
          "77"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create useLadderKeyboardShortcuts Hook Foundation",
            "description": "Implement the base keyboard shortcuts hook with event listener setup, input field detection to prevent conflicts, and core editing operations (Delete/Backspace for element removal, Ctrl+Z/Y for undo/redo).",
            "dependencies": [],
            "details": "Create `src/components/LadderEditor/hooks/useLadderKeyboardShortcuts.ts` with:\n\n1. **Hook Structure:**\n- Import necessary store actions from useLadderStore\n- Set up useEffect with keydown event listener on window\n- Implement cleanup on unmount\n\n2. **Input Field Detection:**\n- Check if e.target is HTMLInputElement or HTMLTextAreaElement\n- Return early to allow normal text input behavior\n\n3. **Delete Operations:**\n- Handle 'Delete' and 'Backspace' keys\n- Iterate over selectedElementIds and call removeElement for each\n- Prevent default browser behavior\n\n4. **Undo/Redo:**\n- Handle Ctrl+Z (or Cmd+Z on Mac) for undo\n- Handle Ctrl+Shift+Z and Ctrl+Y for redo\n- Use e.metaKey for Mac compatibility\n\n5. **Dependencies:**\n- Include selectedElementIds in useEffect dependency array\n- Ensure proper cleanup to prevent memory leaks",
            "status": "pending",
            "testStrategy": "1. Verify Delete key removes selected elements from ladder\n2. Verify Backspace key also triggers deletion\n3. Verify Ctrl+Z undoes the last action\n4. Verify Ctrl+Y and Ctrl+Shift+Z redo undone actions\n5. Verify keyboard shortcuts don't fire when typing in input fields\n6. Verify event listeners are cleaned up on component unmount",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Clipboard and Selection Shortcuts",
            "description": "Add keyboard shortcuts for clipboard operations (copy, paste, cut), duplication, and selection management to the keyboard shortcuts hook.",
            "dependencies": [
              1
            ],
            "details": "Extend `useLadderKeyboardShortcuts.ts` with clipboard and selection handling:\n\n1. **Clipboard Operations:**\n- Ctrl+C: Call copyToClipboard() to copy selected elements\n- Ctrl+V: Call pasteFromClipboard() to paste at current position\n- Ctrl+X: Call cutSelection() to cut selected elements\n\n2. **Duplication:**\n- Ctrl+D: Call duplicateSelection() to duplicate selected elements\n- Prevent default browser behavior (bookmark dialog)\n- Position duplicated elements offset from originals\n\n3. **Selection Management:**\n- Ctrl+A: Call selectAll() to select all elements in current network\n- Prevent default browser select-all behavior\n- Escape: Call clearSelection() to deselect all\n\n4. **Store Actions Required:**\n- Ensure useLadderStore exports: copyToClipboard, pasteFromClipboard, cutSelection, duplicateSelection, selectAll, clearSelection\n- These may need to be implemented if not already present\n\n5. **Mac Support:**\n- Use (e.ctrlKey || e.metaKey) for cross-platform compatibility",
            "status": "pending",
            "testStrategy": "1. Verify Ctrl+C copies selected elements to internal clipboard\n2. Verify Ctrl+V pastes elements from clipboard\n3. Verify Ctrl+X cuts elements (copies then deletes)\n4. Verify Ctrl+D duplicates selected elements\n5. Verify Ctrl+A selects all elements in the network\n6. Verify Escape clears selection\n7. Test Mac keyboard with Cmd key combinations",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Arrow Key Cell Navigation",
            "description": "Add arrow key navigation for moving focus between ladder grid cells, with Enter key to open element editor and proper focus management.",
            "dependencies": [
              1
            ],
            "details": "Extend `useLadderKeyboardShortcuts.ts` with navigation capabilities:\n\n1. **Arrow Key Handling:**\n- Detect ArrowUp, ArrowDown, ArrowLeft, ArrowRight keys\n- Implement navigateCells(direction) function\n- Calculate target cell based on current selection and grid structure\n\n2. **Navigation Logic:**\n- Get current focused cell position from store\n- Calculate new position based on direction\n- Respect grid boundaries (don't go negative or beyond max)\n- Handle network boundaries (moving between networks)\n\n3. **Focus Management:**\n- Update focusedCellId in store when navigating\n- Visual focus indicator should follow the focused cell\n- Consider shift+arrow for extending selection\n\n4. **Enter Key:**\n- Implement openElementEditor() when Enter is pressed\n- If cell has element, open property editor dialog\n- If cell is empty, optionally open element insertion menu\n\n5. **Store Requirements:**\n- Add focusedCellId state to store\n- Add setFocusedCell action\n- Add navigateToCell helper function",
            "status": "pending",
            "testStrategy": "1. Verify ArrowRight moves focus to next cell in row\n2. Verify ArrowLeft moves focus to previous cell\n3. Verify ArrowDown moves to cell below in next network\n4. Verify ArrowUp moves to cell above in previous network\n5. Verify navigation stops at grid boundaries\n6. Verify Enter opens element editor for selected element\n7. Verify focus indicator visually follows navigation",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create LadderContextMenu Component",
            "description": "Build the context menu React component with styled menu items, keyboard shortcut hints, dividers, and proper positioning relative to click location.",
            "dependencies": [],
            "details": "Create `src/components/LadderEditor/LadderContextMenu.tsx`:\n\n1. **Component Props:**\n```typescript\ninterface ContextMenuProps {\n  x: number;\n  y: number;\n  element: LadderElement | null;\n  onClose: () => void;\n}\n```\n\n2. **Menu Items Definition:**\n- Edit Properties (Enter)\n- Divider\n- Cut (Ctrl+X), Copy (Ctrl+C), Paste (Ctrl+V), Delete (Del)\n- Divider\n- Insert NO Contact, Insert NC Contact, Insert Coil\n- Divider\n- Add Parallel Branch\n- Divider\n- Cross Reference, Go to Definition\n\n3. **Styling:**\n- Use shadcn/ui DropdownMenu or custom styled component\n- Show keyboard shortcuts right-aligned in muted text\n- Highlight on hover, disabled state for unavailable actions\n- Support divider items for visual grouping\n\n4. **Positioning:**\n- Position at (x, y) from click event\n- Adjust if menu would overflow viewport\n- Use fixed positioning or portal for proper z-index\n\n5. **Accessibility:**\n- Support keyboard navigation within menu\n- Focus trap while menu is open\n- Close on Escape key",
            "status": "pending",
            "testStrategy": "1. Verify menu renders at correct x,y position\n2. Verify menu items display with correct labels and shortcuts\n3. Verify dividers render between item groups\n4. Verify hover highlighting works\n5. Verify disabled items appear grayed out\n6. Verify menu doesn't overflow viewport edges\n7. Verify Escape key closes the menu",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate Context Menu with Ladder Grid",
            "description": "Connect the context menu to the ladder grid with right-click handling, action dispatching, click-outside detection, and conditional menu item availability based on selection state.",
            "dependencies": [
              4
            ],
            "details": "Integrate context menu into `LadderGrid.tsx` or parent component:\n\n1. **Context Menu State:**\n```typescript\nconst [contextMenu, setContextMenu] = useState<{\n  x: number;\n  y: number;\n  element: LadderElement | null;\n} | null>(null);\n```\n\n2. **Right-Click Handler:**\n- Add onContextMenu to grid cells and elements\n- Prevent default browser context menu\n- Capture click position and target element\n- Set contextMenu state to show menu\n\n3. **Action Dispatching:**\n- Map menu action strings to store actions\n- Handle: edit, cut, copy, paste, delete\n- Handle: insert_contact_no, insert_contact_nc, insert_coil\n- Handle: add_branch, cross_reference, goto_definition\n- Close menu after action execution\n\n4. **Click-Outside Detection:**\n- Use useClickOutside hook or onBlur\n- Close menu when clicking outside\n- Close menu when pressing Escape\n\n5. **Conditional Availability:**\n- Disable Cut/Copy/Delete if no selection\n- Disable Paste if clipboard empty\n- Disable element-specific actions if no element\n- Show different options for empty cells vs elements",
            "status": "pending",
            "testStrategy": "1. Verify right-click on element shows context menu\n2. Verify right-click on empty cell shows appropriate menu\n3. Verify clicking Cut executes cut action\n4. Verify clicking Copy executes copy action\n5. Verify clicking Delete removes element\n6. Verify Insert actions create new elements\n7. Verify clicking outside menu closes it\n8. Verify disabled items cannot be clicked",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement drag-and-drop for ladder elements using @dnd-kit with palette dragging, grid placement, and element reordering"
      },
      {
        "id": "79",
        "title": "Implement AST to Grid Conversion",
        "description": "Create utility functions to convert OneParser AST output into ladder grid elements with correct positioning, handling series and parallel blocks.",
        "details": "Create AST conversion utilities in `src/components/LadderEditor/utils/`:\n\n1. **AST to Grid Converter:**\n```typescript\n// utils/gridConverter.ts\ninterface ConversionResult {\n  elements: LadderElement[];\n  wires: LadderWire[];\n  rowCount: number;\n}\n\nexport function astToGrid(\n  ast: LadderASTNode,\n  gridConfig: GridConfig\n): ConversionResult {\n  const elements: LadderElement[] = [];\n  const wires: LadderWire[] = [];\n  let currentRow = 0;\n  let currentCol = 0;\n\n  function traverse(node: LadderASTNode, row: number, col: number): { endCol: number; endRow: number } {\n    if (node.type === 'element') {\n      // Place element at position\n      elements.push({\n        id: generateId(),\n        type: mapASTTypeToElementType(node.element.type),\n        position: { row, column: col },\n        address: node.element.address,\n        properties: node.element.properties,\n      });\n      return { endCol: col + 1, endRow: row };\n    }\n\n    if (node.type === 'series') {\n      // Children placed horizontally (column increment)\n      let currentCol = col;\n      let maxRow = row;\n      for (const child of node.children) {\n        const result = traverse(child, row, currentCol);\n        currentCol = result.endCol;\n        maxRow = Math.max(maxRow, result.endRow);\n      }\n      return { endCol: currentCol, endRow: maxRow };\n    }\n\n    if (node.type === 'parallel') {\n      // Children placed vertically (row increment)\n      let currentRow = row;\n      let maxCol = col;\n      for (const child of node.children) {\n        const result = traverse(child, currentRow, col);\n        maxCol = Math.max(maxCol, result.endCol);\n        currentRow = result.endRow + 1;\n      }\n      // Add vertical wires at branch/merge points\n      addParallelWires(wires, row, currentRow - 1, col, maxCol);\n      return { endCol: maxCol, endRow: currentRow - 1 };\n    }\n  }\n\n  traverse(ast, 0, 0);\n  return { elements, wires, rowCount: currentRow + 1 };\n}\n```\n\n2. **Element Type Mapping:**\n```typescript\nfunction mapASTTypeToElementType(astType: string): LadderElementType {\n  const mapping: Record<string, LadderElementType> = {\n    'contact': 'contact_no',\n    'contact_nc': 'contact_nc',\n    'contact_p': 'contact_p',\n    'contact_n': 'contact_n',\n    'coil': 'coil',\n    'coil_s': 'coil_set',\n    'coil_r': 'coil_reset',\n    'ton': 'timer_ton',\n    'tof': 'timer_tof',\n    'ctu': 'counter_ctu',\n    'ctd': 'counter_ctd',\n  };\n  return mapping[astType] || 'contact_no';\n}\n```\n\n3. **Wire Generation for Parallel Branches:**\n```typescript\nfunction addParallelWires(\n  wires: LadderWire[],\n  startRow: number,\n  endRow: number,\n  branchCol: number,\n  mergeCol: number\n): void {\n  // Add vertical wire at branch point\n  for (let row = startRow; row <= endRow; row++) {\n    wires.push({ type: 'wire_v', position: { row, column: branchCol - 1 } });\n  }\n  // Add vertical wire at merge point\n  for (let row = startRow; row <= endRow; row++) {\n    wires.push({ type: 'wire_v', position: { row, column: mergeCol } });\n  }\n}\n```",
        "testStrategy": "1. Simple series elements convert to horizontal layout\n2. Parallel blocks convert to multiple rows\n3. Nested series/parallel blocks convert correctly\n4. Element addresses are preserved\n5. Wires are generated at correct positions\n6. Row count matches actual content\n7. Empty AST returns empty result",
        "priority": "high",
        "dependencies": [
          "70",
          "71",
          "75"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript interfaces and types for grid conversion",
            "description": "Create type definitions for ConversionResult, LadderElement, LadderWire, GridConfig, and position-related interfaces needed for AST to grid conversion.",
            "dependencies": [],
            "details": "Create or extend types in `src/components/LadderEditor/types/` including:\n- ConversionResult interface with elements, wires, and rowCount\n- LadderElement interface with id, type, position, address, and properties\n- LadderWire interface with type and position\n- GridConfig interface for grid configuration parameters\n- Position interface with row and column properties\n- Ensure LadderASTNode type is imported from OneParser types",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation succeeds with no type errors. Test that interfaces are properly exported and can be imported in the gridConverter module.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement element type mapping function",
            "description": "Create mapASTTypeToElementType function that converts OneParser AST element types to LadderElementType enum values.",
            "dependencies": [
              1
            ],
            "details": "Implement in `src/components/LadderEditor/utils/gridConverter.ts`:\n- Create mapping record from AST types (contact, contact_nc, contact_p, contact_n, coil, coil_s, coil_r, ton, tof, ctu, ctd) to LadderElementType values\n- Handle unknown types with fallback to 'contact_no'\n- Export function for use in traverse logic\n- Consider adding validation for unmapped types with console warnings",
            "status": "pending",
            "testStrategy": "Unit test each AST type maps to correct LadderElementType. Test unknown types fall back to contact_no. Test all timer and counter types map correctly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement series block traversal logic",
            "description": "Create traversal logic for series AST nodes that places child elements horizontally with incrementing column positions.",
            "dependencies": [
              1,
              2
            ],
            "details": "Within the traverse function in gridConverter.ts:\n- Handle 'series' node type by iterating through children\n- Place each child at current row, incrementing column after each placement\n- Track maximum row reached across all children for nested parallel blocks\n- Return endCol as final column position and endRow as maximum row reached\n- Generate horizontal wire connections between series elements",
            "status": "pending",
            "testStrategy": "Test simple series of 3 contacts produces horizontal layout. Test nested series within parallel maintains correct column progression. Test endCol and endRow values are accurate.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement parallel block traversal with wire generation",
            "description": "Create traversal logic for parallel AST nodes that places child branches vertically and generates vertical wires at branch/merge points.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement in gridConverter.ts:\n- Handle 'parallel' node type by iterating children with incrementing rows\n- Track maximum column reached across all branches for merge point\n- Implement addParallelWires function to generate vertical wires at branch column (branchCol - 1) and merge column (maxCol)\n- Add wire_v type wires for each row from startRow to endRow at both branch and merge points\n- Return endCol as maximum column and endRow as final row used",
            "status": "pending",
            "testStrategy": "Test parallel block with 2 branches creates 2 rows. Test vertical wires are generated at correct positions. Test nested parallel blocks generate wires at all levels.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement main astToGrid function and ID generation",
            "description": "Create the main astToGrid export function that orchestrates AST traversal and returns the complete ConversionResult with elements, wires, and row count.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Complete the gridConverter.ts module:\n- Implement generateId utility function for unique element IDs (UUID or incremental)\n- Create astToGrid function accepting LadderASTNode and GridConfig parameters\n- Initialize elements and wires arrays\n- Call traverse function starting at row 0, column 0\n- Handle element nodes by creating LadderElement with mapped type and address\n- Return ConversionResult with elements, wires, and calculated rowCount\n- Add validation for null/undefined AST input\n- Export all public functions and types",
            "status": "pending",
            "testStrategy": "Test empty AST returns empty result. Test simple rung with series and parallel converts correctly. Test element addresses are preserved. Test row count matches actual content. Integration test with sample OneParser output.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Build element palette with categorized ladder elements, search/filter, and drag source integration"
      },
      {
        "id": "80",
        "title": "Implement Grid to AST Conversion",
        "description": "Create utility functions to convert ladder grid layout back into AST format for saving and integration with OneParser.",
        "details": "Create Grid to AST conversion utilities:\n\n1. **Grid to AST Converter:**\n```typescript\n// utils/gridConverter.ts (add to existing file)\nexport function gridToAST(\n  elements: Map<string, LadderElement>,\n  wires: LadderWire[]\n): LadderASTNode {\n  // Step 1: Group elements by row\n  const rowGroups = groupElementsByRow(elements);\n  \n  // Step 2: Detect parallel connections from vertical wires\n  const parallelGroups = detectParallelGroups(rowGroups, wires);\n  \n  // Step 3: Build AST tree\n  return buildASTFromGroups(rowGroups, parallelGroups);\n}\n\nfunction groupElementsByRow(\n  elements: Map<string, LadderElement>\n): Map<number, LadderElement[]> {\n  const rows = new Map<number, LadderElement[]>();\n  for (const element of elements.values()) {\n    const row = element.position.row;\n    if (!rows.has(row)) rows.set(row, []);\n    rows.get(row)!.push(element);\n  }\n  // Sort elements in each row by column\n  for (const [row, elements] of rows) {\n    elements.sort((a, b) => a.position.column - b.position.column);\n  }\n  return rows;\n}\n```\n\n2. **Parallel Group Detection:**\n```typescript\nfunction detectParallelGroups(\n  rowGroups: Map<number, LadderElement[]>,\n  wires: LadderWire[]\n): ParallelGroup[] {\n  const groups: ParallelGroup[] = [];\n  \n  // Find vertical wire sequences\n  const verticalWires = wires.filter(w => w.type === 'wire_v');\n  \n  // Group by column position\n  const wireColumns = new Map<number, number[]>();\n  for (const wire of verticalWires) {\n    const col = wire.position.column;\n    if (!wireColumns.has(col)) wireColumns.set(col, []);\n    wireColumns.get(col)!.push(wire.position.row);\n  }\n  \n  // Identify branch/merge points\n  // ... implementation\n  \n  return groups;\n}\n```\n\n3. **AST Node Building:**\n```typescript\nfunction buildASTFromGroups(\n  rowGroups: Map<number, LadderElement[]>,\n  parallelGroups: ParallelGroup[]\n): LadderASTNode {\n  // If single row, create series node\n  if (rowGroups.size === 1) {\n    const elements = rowGroups.values().next().value;\n    return {\n      type: 'series',\n      children: elements.map(el => ({\n        type: 'element',\n        element: {\n          type: elementTypeToASTType(el.type),\n          address: el.address,\n          properties: el.properties,\n        },\n      })),\n    };\n  }\n  \n  // Multiple rows with parallel groups\n  return buildParallelAST(rowGroups, parallelGroups);\n}\n```\n\n4. **Flatten/Normalize AST:**\n```typescript\nfunction normalizeAST(ast: LadderASTNode): LadderASTNode {\n  // Remove unnecessary nesting\n  // Merge adjacent series nodes\n  // Sort parallel branches consistently\n}\n```",
        "testStrategy": "1. Single row converts to series AST node\n2. Multiple parallel rows convert correctly\n3. Nested structures convert to proper nesting\n4. Element properties preserved in conversion\n5. Round-trip (AST→Grid→AST) produces equivalent result\n6. Empty grid returns null/empty AST\n7. Normalized AST has no unnecessary nesting",
        "priority": "medium",
        "dependencies": [
          "79"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Row Grouping and Element Sorting",
            "description": "Create the groupElementsByRow utility function that organizes LadderElements from the grid Map into row-based groups, sorted by column position within each row.",
            "dependencies": [],
            "details": "Implement groupElementsByRow function in utils/gridConverter.ts:\n\n1. Create function signature: `function groupElementsByRow(elements: Map<string, LadderElement>): Map<number, LadderElement[]>`\n\n2. Iterate through all elements in the Map, grouping by `element.position.row`\n\n3. For each row group, sort elements by `element.position.column` in ascending order\n\n4. Handle edge cases:\n   - Empty element Map returns empty Map\n   - Single element returns Map with one row entry\n   - Validate row/column are valid numbers\n\n5. Export as named function for use in gridToAST and unit testing\n\n6. Add helper type for row groups if needed:\n```typescript\ntype RowGroups = Map<number, LadderElement[]>;\n```",
            "status": "pending",
            "testStrategy": "Unit tests: 1) Empty Map returns empty result, 2) Single element creates single row group, 3) Multiple elements same row sorted by column, 4) Multiple rows each sorted independently, 5) Elements with same position handled consistently",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Parallel Group Detection from Wires",
            "description": "Create the detectParallelGroups function that analyzes vertical wires to identify parallel connection structures (branches) in the ladder grid.",
            "dependencies": [
              1
            ],
            "details": "Implement parallel group detection in utils/gridConverter.ts:\n\n1. Create function signature: `function detectParallelGroups(rowGroups: Map<number, LadderElement[]>, wires: LadderWire[]): ParallelGroup[]`\n\n2. Define ParallelGroup interface:\n```typescript\ninterface ParallelGroup {\n  startColumn: number;\n  endColumn: number;\n  rows: number[];  // Which rows are part of this parallel group\n  branchPoints: { row: number; col: number }[];\n}\n```\n\n3. Filter wires to get vertical wires only (`wire.type === 'wire_v'`)\n\n4. Group vertical wires by column position to find vertical sequences\n\n5. Identify branch points where parallel paths start (row divergence) and merge points where they reconnect\n\n6. Build ParallelGroup objects for each identified parallel structure\n\n7. Handle nested parallel groups (parallel within parallel)\n\n8. Return empty array if no parallel groups found (single row ladder)",
            "status": "pending",
            "testStrategy": "Unit tests: 1) No vertical wires returns empty array, 2) Single vertical wire connecting two rows creates one parallel group, 3) Multiple independent parallel groups detected separately, 4) Nested parallel structures detected correctly, 5) Wire column positions correctly mapped to element columns",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement AST Node Building Functions",
            "description": "Create the buildASTFromGroups function and helper functions to construct LadderASTNode tree from row groups and parallel groups.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement AST building functions in utils/gridConverter.ts:\n\n1. Create elementTypeToASTType helper:\n```typescript\nfunction elementTypeToASTType(gridType: LadderElementType): LadderASTElementType\n```\nMap: contact_no→contact, contact_nc→contact_nc, coil→coil_out, etc.\n\n2. Implement buildASTFromGroups:\n```typescript\nfunction buildASTFromGroups(\n  rowGroups: Map<number, LadderElement[]>,\n  parallelGroups: ParallelGroup[]\n): LadderASTNode\n```\n\n3. For single row (no parallel groups):\n   - Create 'series' node with children array of element nodes\n   - Each child has type 'element' with address and properties\n\n4. For multiple rows with parallel groups:\n   - Call buildParallelAST helper\n   - Create 'parallel' node containing series nodes for each branch\n\n5. Preserve element properties (address, comment, timer presets, etc.) in AST nodes\n\n6. Handle empty rows gracefully (skip or create empty series)",
            "status": "pending",
            "testStrategy": "Unit tests: 1) Single row creates series AST node, 2) Two parallel rows create parallel node with two series children, 3) Element type mapping is correct for all contact/coil types, 4) Element properties preserved (address, comment), 5) Timer/counter presets included in AST",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement AST Normalization Function",
            "description": "Create the normalizeAST function to flatten unnecessary nesting, merge adjacent series nodes, and ensure consistent AST structure for storage and comparison.",
            "dependencies": [
              3
            ],
            "details": "Implement AST normalization in utils/gridConverter.ts:\n\n1. Create function signature: `function normalizeAST(ast: LadderASTNode): LadderASTNode`\n\n2. Implement recursive normalization:\n   - Remove single-child series/parallel nodes (unwrap)\n   - Merge adjacent series nodes into one\n   - Flatten nested series within series\n   - Flatten nested parallel within parallel at same level\n\n3. Sort parallel branches consistently (by first element address or row number) for deterministic output\n\n4. Remove empty nodes (series/parallel with no children)\n\n5. Preserve leaf element nodes unchanged\n\n6. Handle deep nesting (3+ levels) through recursive descent\n\n7. Return new normalized AST (immutable transformation, don't mutate input)",
            "status": "pending",
            "testStrategy": "Unit tests: 1) Single-child series unwrapped to child, 2) Adjacent series nodes merged, 3) Nested series flattened, 4) Empty nodes removed, 5) Parallel branches sorted consistently, 6) Deep nesting (3+ levels) correctly flattened, 7) Input AST not mutated",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Main gridToAST Function and Integration",
            "description": "Create the main gridToAST function that orchestrates the conversion pipeline and integrate with existing LadderEditor types for complete grid-to-AST workflow.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement main conversion function in utils/gridConverter.ts:\n\n1. Create main function signature:\n```typescript\nexport function gridToAST(\n  elements: Map<string, LadderElement>,\n  wires: LadderWire[]\n): LadderASTNode | null\n```\n\n2. Implement conversion pipeline:\n   - Step 1: Call groupElementsByRow(elements)\n   - Step 2: Call detectParallelGroups(rowGroups, wires)\n   - Step 3: Call buildASTFromGroups(rowGroups, parallelGroups)\n   - Step 4: Call normalizeAST(rawAST)\n   - Return normalized AST\n\n3. Handle edge cases:\n   - Empty elements Map returns null\n   - Elements with no wires still creates series AST\n   - Invalid element positions logged and skipped\n\n4. Add TypeScript type exports for integration:\n```typescript\nexport type { ParallelGroup, RowGroups };\n```\n\n5. Add JSDoc documentation for public API\n\n6. Ensure compatibility with existing LadderElement and LadderWire types from LadderEditor components",
            "status": "pending",
            "testStrategy": "Integration tests: 1) Empty grid returns null, 2) Single row converts to series node, 3) Multiple parallel rows convert correctly, 4) Nested structures produce proper nesting, 5) Round-trip test: gridToAST output can be used with astToGrid (if exists), 6) Element properties preserved through full pipeline",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Create properties panel for editing selected element properties including address, comment, timer presets, with validation"
      },
      {
        "id": "81",
        "title": "Implement Monitoring Mode and State Visualization",
        "description": "Create monitoring mode that displays real-time device states, wire energization, and timer/counter values with visual feedback.",
        "details": "Implement monitoring mode components and state management:\n\n1. **Monitoring State Management:**\n```typescript\n// In ladderStore.ts - add monitoring actions\nstartMonitoring: () => {\n  set(state => {\n    state.mode = 'monitor';\n    state.monitoringState = {\n      deviceStates: new Map(),\n      forcedDevices: new Set(),\n      energizedWires: new Set(),\n      timerStates: new Map(),\n      counterStates: new Map(),\n    };\n  });\n},\n\nupdateMonitoringState: (updates: Partial<LadderMonitoringState>) => {\n  set(state => {\n    if (!state.monitoringState) return;\n    Object.assign(state.monitoringState, updates);\n  });\n},\n```\n\n2. **useMonitoring Hook:**\n```typescript\n// hooks/useMonitoring.ts\nexport function useMonitoring() {\n  const mode = useLadderStore(s => s.mode);\n  const monitoringState = useLadderStore(s => s.monitoringState);\n  const updateMonitoringState = useLadderStore(s => s.updateMonitoringState);\n\n  // Subscribe to Tauri events for state updates\n  useEffect(() => {\n    if (mode !== 'monitor') return;\n\n    const unsubscribe = listen<MonitoringUpdate>('ladder:element-state', (event) => {\n      const { address, value, type } = event.payload;\n      updateMonitoringState({\n        deviceStates: new Map(monitoringState.deviceStates).set(address, value),\n      });\n    });\n\n    return () => { unsubscribe.then(fn => fn()); };\n  }, [mode]);\n\n  return { isMonitoring: mode === 'monitor', monitoringState };\n}\n```\n\n3. **Visual State Updates:**\n```tsx\n// Updated Contact component with monitoring\nconst Contact = ({ type, address, label }) => {\n  const { isMonitoring, monitoringState } = useMonitoring();\n  const isEnergized = isMonitoring && monitoringState?.deviceStates.get(address);\n  const isForced = isMonitoring && monitoringState?.forcedDevices.has(address);\n\n  return (\n    <div className={cn(\n      'flex items-center justify-center',\n      isEnergized && 'bg-green-500/30',\n      isForced && 'ring-2 ring-yellow-500'\n    )}>\n      <svg>...</svg>\n      <span className=\"text-xs\">{address}</span>\n    </div>\n  );\n};\n```\n\n4. **Wire Energization Visualization:**\n- Calculate energized path from power rail to active outputs\n- Show green color and glow for energized wires\n- Optional: CSS animation for current flow direction\n\n5. **Timer/Counter Live Display:**\n- Show progress bar for timer ET/PT\n- Update values in real-time\n- Pulse animation for running timers\n\n6. **Monitoring Toolbar:**\n```tsx\n// MonitoringToolbar.tsx\nconst MonitoringToolbar = () => (\n  <div className=\"flex items-center gap-2 p-2 bg-neutral-800\">\n    <Button onClick={startMonitoring}>Start</Button>\n    <Button onClick={stopMonitoring}>Stop</Button>\n    <span className=\"text-green-500\">● Connected</span>\n  </div>\n);\n```",
        "testStrategy": "1. Starting monitoring changes mode to 'monitor'\n2. Device state updates reflect in element visuals\n3. Energized contacts show green fill\n4. Energized coils show red fill\n5. Forced devices show yellow border\n6. Timer progress bar updates correctly\n7. Counter value display updates correctly\n8. Stopping monitoring clears monitoring state\n9. Wire energization calculates correctly from power to output",
        "priority": "medium",
        "dependencies": [
          "73",
          "74",
          "75",
          "71"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Monitoring State Management and useMonitoring Hook",
            "description": "Set up monitoring state in ladderStore with actions for starting/stopping monitoring and create the useMonitoring hook that subscribes to Tauri events for real-time state updates.",
            "dependencies": [],
            "details": "1. Add MonitoringState types to store types (deviceStates Map, forcedDevices Set, energizedWires Set, timerStates Map, counterStates Map)\n2. Implement startMonitoring action that sets mode to 'monitor' and initializes monitoringState\n3. Implement stopMonitoring action that resets mode to 'edit' and clears monitoringState\n4. Implement updateMonitoringState action for partial state updates\n5. Create hooks/useMonitoring.ts with subscription to 'ladder:element-state' Tauri events\n6. Handle cleanup of Tauri event listeners on unmount or mode change\n7. Create MonitoringToolbar component with Start/Stop buttons and connection status indicator",
            "status": "pending",
            "testStrategy": "1. Verify startMonitoring changes mode to 'monitor' and initializes all state maps\n2. Verify stopMonitoring resets mode and clears state\n3. Verify useMonitoring hook returns correct isMonitoring boolean based on mode\n4. Verify Tauri event subscription is established when monitoring starts\n5. Verify event listener cleanup occurs on unmount",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Element State Visualization for Contacts and Coils",
            "description": "Update Contact, Coil, and other ladder element components to display real-time monitoring states including energized status and forced device indicators.",
            "dependencies": [
              1
            ],
            "details": "1. Update Contact component to consume useMonitoring hook\n2. Add visual styling for energized contacts (green background/fill with bg-green-500/30)\n3. Add visual styling for forced devices (yellow ring indicator with ring-2 ring-yellow-500)\n4. Update Coil component with similar energized state visualization (red fill for active coils)\n5. Create utility function to check device state from monitoringState map\n6. Ensure visual updates are performant with proper memoization\n7. Add CSS transitions for smooth state change animations\n8. Handle NC (normally closed) contacts with inverted state logic",
            "status": "pending",
            "testStrategy": "1. Verify NO contact shows green when energized\n2. Verify NC contact shows green when device is OFF (inverted logic)\n3. Verify coil shows red when energized\n4. Verify forced device shows yellow border regardless of energized state\n5. Verify state changes animate smoothly\n6. Verify multiple elements update simultaneously without performance issues",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Wire Energization and Timer/Counter Live Display",
            "description": "Create wire energization visualization showing current flow paths from power rail to outputs, and implement real-time timer/counter value displays with progress indicators.",
            "dependencies": [
              1
            ],
            "details": "1. Implement wire energization path calculation from power rail through active elements\n2. Create CSS styles for energized wires (green color, glow effect with box-shadow)\n3. Optional: Add CSS animation for current flow direction indication\n4. Update LadderWire component to consume energizedWires from monitoringState\n5. Create TimerDisplay component showing ET/PT values with progress bar\n6. Create CounterDisplay component showing CV/PV values\n7. Add pulse/glow animation for running timers\n8. Subscribe to timer and counter state updates from Tauri events\n9. Implement real-time value updates with smooth transitions",
            "status": "pending",
            "testStrategy": "1. Verify wire shows green color when in energized path\n2. Verify wire returns to normal when path de-energizes\n3. Verify timer progress bar shows correct ET/PT ratio\n4. Verify timer values update in real-time during countdown\n5. Verify counter CV display updates on count changes\n6. Verify running timer shows pulse animation\n7. Verify energization path is correctly calculated through series/parallel branches",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Subtasks: 1) Implement series connection detection and wire routing 2) Implement parallel branch creation and management 3) Add visual indicators for connection types"
      },
      {
        "id": "82",
        "title": "Implement Force Device Feature",
        "description": "Add ability to force device values during monitoring mode, with visual indication of forced devices and ability to release force.",
        "details": "Implement force device functionality:\n\n1. **Force Device Dialog:**\n```tsx\n// dialogs/ForceDeviceDialog.tsx\ninterface ForceDeviceDialogProps {\n  device: { address: string; currentValue: boolean | number };\n  onForce: (address: string, value: boolean | number) => void;\n  onRelease: (address: string) => void;\n  onClose: () => void;\n}\n\nconst ForceDeviceDialog = ({ device, onForce, onRelease, onClose }) => {\n  const [value, setValue] = useState(device.currentValue);\n\n  return (\n    <Dialog open onClose={onClose}>\n      <DialogTitle>Force Device: {device.address}</DialogTitle>\n      <DialogContent>\n        {typeof device.currentValue === 'boolean' ? (\n          <Switch checked={value as boolean} onChange={(v) => setValue(v)} />\n        ) : (\n          <Input type=\"number\" value={value} onChange={(e) => setValue(+e.target.value)} />\n        )}\n      </DialogContent>\n      <DialogActions>\n        <Button onClick={() => onRelease(device.address)}>Release Force</Button>\n        <Button onClick={() => onForce(device.address, value)}>Force</Button>\n      </DialogActions>\n    </Dialog>\n  );\n};\n```\n\n2. **Store Actions:**\n```typescript\nforceDevice: (address: string, value: boolean | number) => {\n  set(state => {\n    if (!state.monitoringState) return;\n    state.monitoringState.forcedDevices.add(address);\n    state.monitoringState.deviceStates.set(address, value);\n  });\n  // Call Tauri command\n  invoke('ladder_force_device', { address, value });\n},\n\nreleaseForce: (address: string) => {\n  set(state => {\n    if (!state.monitoringState) return;\n    state.monitoringState.forcedDevices.delete(address);\n  });\n  invoke('ladder_release_force', { address });\n},\n```\n\n3. **Context Menu Integration:**\n- Add \"Force Device\" option to element context menu (monitoring mode only)\n- Add \"Release Force\" option for forced devices\n\n4. **Visual Indication:**\n- Yellow/orange border ring on forced elements\n- Force icon overlay (⚡ or 🔒)\n- List of forced devices in status bar or side panel\n\n5. **Forced Devices Panel:**\n```tsx\n// ForcedDevicesPanel.tsx\nconst ForcedDevicesPanel = () => {\n  const forcedDevices = useLadderStore(s => s.monitoringState?.forcedDevices);\n  const releaseForce = useLadderStore(s => s.releaseForce);\n\n  if (!forcedDevices?.size) return null;\n\n  return (\n    <div className=\"p-2 bg-yellow-900/20 rounded\">\n      <h4 className=\"text-sm font-medium mb-2\">Forced Devices</h4>\n      {[...forcedDevices].map(address => (\n        <div key={address} className=\"flex items-center justify-between\">\n          <span>{address}</span>\n          <Button size=\"sm\" onClick={() => releaseForce(address)}>Release</Button>\n        </div>\n      ))}\n    </div>\n  );\n};\n```\n\n6. **Safety Warning:** Show confirmation dialog when forcing outputs",
        "testStrategy": "1. Force dialog opens for device in monitoring mode\n2. Forcing boolean device updates visual state\n3. Forcing numeric device accepts number input\n4. Forced device shows yellow border\n5. Release force removes yellow border\n6. Forced devices list shows all forced devices\n7. Tauri commands are invoked correctly\n8. Force persists until released\n9. Stopping monitoring releases all forces",
        "priority": "low",
        "dependencies": [
          "81"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ForceDeviceDialog Component",
            "description": "Implement the dialog component that allows users to force device values, with support for boolean (switch) and numeric (input) device types.",
            "dependencies": [],
            "details": "Create `src/components/LadderEditor/dialogs/ForceDeviceDialog.tsx` with the following features:\n\n1. Define `ForceDeviceDialogProps` interface with device info, onForce, onRelease, and onClose callbacks\n2. Implement state management for the force value using useState, initialized with device.currentValue\n3. Render conditional input based on device type:\n   - Boolean devices: Use Switch component for ON/OFF toggle\n   - Numeric devices: Use Input with type='number' for word values\n4. Include DialogActions with:\n   - 'Release Force' button calling onRelease(device.address)\n   - 'Force' button calling onForce(device.address, value)\n   - 'Cancel' button calling onClose\n5. Display device address and current value in dialog header\n6. Add input validation for numeric values (range checking based on device type)",
            "status": "pending",
            "testStrategy": "1. Dialog renders correctly with device address in title\n2. Boolean device shows Switch component initialized to current value\n3. Numeric device shows number Input initialized to current value\n4. Toggling Switch updates internal value state\n5. Changing Input updates internal value state\n6. Force button calls onForce with address and new value\n7. Release button calls onRelease with address\n8. Cancel/close button calls onClose",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Store Actions and Tauri Integration",
            "description": "Add forceDevice and releaseForce actions to the ladder store with proper state management and Tauri command invocation.",
            "dependencies": [
              1
            ],
            "details": "Update `src/stores/ladderStore.ts` (or create force-related slice):\n\n1. Ensure `monitoringState` includes `forcedDevices: Set<string>` for tracking forced addresses\n2. Implement `forceDevice(address: string, value: boolean | number)` action:\n   - Guard: Return early if not in monitoring mode\n   - Add address to forcedDevices Set\n   - Update deviceStates Map with forced value\n   - Call `invoke('ladder_force_device', { address, value })` Tauri command\n3. Implement `releaseForce(address: string)` action:\n   - Guard: Return early if not in monitoring mode\n   - Remove address from forcedDevices Set\n   - Call `invoke('ladder_release_force', { address })` Tauri command\n4. Implement `releaseAllForces()` action for releasing all forced devices at once\n5. Add selector `selectForcedDevices` to get current forced devices\n6. Handle Tauri command errors with appropriate error state updates",
            "status": "pending",
            "testStrategy": "1. forceDevice adds address to forcedDevices Set\n2. forceDevice updates deviceStates with forced value\n3. forceDevice invokes ladder_force_device Tauri command\n4. releaseForce removes address from forcedDevices Set\n5. releaseForce invokes ladder_release_force Tauri command\n6. Actions do nothing when not in monitoring mode\n7. releaseAllForces clears all forced devices\n8. Error handling works for failed Tauri commands",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Visual Indication for Forced Elements",
            "description": "Add visual styling to forced elements in the ladder diagram including yellow/orange border rings and force icon overlays.",
            "dependencies": [
              2
            ],
            "details": "Update ladder element rendering components:\n\n1. Modify `LadderCell.tsx` or element components to accept `isForced` prop\n2. Add CSS classes for forced state:\n   - `.forced-element { ring-2 ring-yellow-500 ring-offset-1 }` for border\n   - Position relative container for icon overlay\n3. Create force indicator icon overlay:\n   - Small icon (⚡ or 🔒) positioned at top-right corner\n   - Use absolute positioning within the element\n   - Apply subtle yellow/orange background pill\n4. Connect element rendering to store:\n   - Use `useLadderStore(s => s.monitoringState?.forcedDevices)` selector\n   - Check if element's device address is in forcedDevices Set\n   - Apply forced styling conditionally\n5. Add animation for forced state transition (subtle pulse or glow)\n6. Ensure forced indication is visible but doesn't interfere with element readability",
            "status": "pending",
            "testStrategy": "1. Forced element displays yellow/orange border ring\n2. Force icon (⚡) appears on forced elements\n3. Releasing force removes border and icon\n4. Forced styling applies immediately when device is forced\n5. Multiple forced elements render correctly\n6. Forced indication visible during monitoring mode\n7. Forced styling doesn't break element layout or readability",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Context Menu Force/Release Options",
            "description": "Integrate Force Device and Release Force options into the ladder element context menu, available only in monitoring mode.",
            "dependencies": [
              1,
              2
            ],
            "details": "Update context menu component (likely `LadderContextMenu.tsx` or similar):\n\n1. Add monitoring mode check to conditionally show force options\n2. Add 'Force Device' menu item:\n   - Icon: ⚡ or force-related icon\n   - Only visible in monitoring mode\n   - Only for elements that have a device address\n   - Disabled if device is already forced (or show 'Modify Force')\n   - onClick: Open ForceDeviceDialog with current device info\n3. Add 'Release Force' menu item:\n   - Icon: Unlock icon\n   - Only visible for currently forced devices\n   - onClick: Call releaseForce(address) directly\n4. Add separator between normal menu items and force options\n5. Pass device information (address, currentValue) to ForceDeviceDialog\n6. Handle dialog state (open/close) in context menu or parent component",
            "status": "pending",
            "testStrategy": "1. Force option appears in context menu during monitoring mode\n2. Force option hidden when not in monitoring mode\n3. Clicking Force opens ForceDeviceDialog with correct device\n4. Release Force option appears for forced devices\n5. Release Force option hidden for non-forced devices\n6. Release Force directly releases without dialog\n7. Context menu closes after action selection",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Forced Devices Panel with Safety Confirmations",
            "description": "Implement the ForcedDevicesPanel component showing all forced devices with release buttons, plus safety confirmation dialog for forcing output devices.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create `src/components/LadderEditor/panels/ForcedDevicesPanel.tsx`:\n\n1. Subscribe to `monitoringState?.forcedDevices` and `deviceStates` from store\n2. Render nothing if no forced devices (forcedDevices.size === 0)\n3. Display panel with:\n   - Header: 'Forced Devices' with count badge\n   - Yellow/orange background tint (bg-yellow-900/20)\n   - List of forced devices showing:\n     - Device address\n     - Current forced value\n     - Release button (size='sm')\n4. Add 'Release All' button in panel header when multiple devices forced\n5. Create safety confirmation dialog for output devices:\n   - Trigger when forcing coils (Y, K, M outputs)\n   - Warning message about potential equipment damage\n   - Require explicit confirmation before proceeding\n6. Integrate panel into ladder editor layout (sidebar or status area)\n7. Make panel collapsible for space efficiency",
            "status": "pending",
            "testStrategy": "1. Panel hidden when no devices are forced\n2. Panel appears when first device is forced\n3. Panel lists all forced devices with addresses and values\n4. Individual Release button releases single device\n5. Release All button releases all forced devices\n6. Safety dialog appears when forcing output devices\n7. Declining safety dialog cancels force operation\n8. Panel updates immediately when force state changes",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Add real-time monitoring overlay showing live values from Modbus memory with visual state changes on elements"
      },
      {
        "id": "83",
        "title": "Implement Network Management Features",
        "description": "Add support for multiple networks in a ladder program with insert, delete, reorder, and copy/paste network functionality.",
        "details": "Implement network management features:\n\n1. **Network List Sidebar:**\n```tsx\n// LadderNetworkList.tsx\ninterface NetworkListProps {\n  networks: LadderNetwork[];\n  currentNetworkId: string | null;\n  onSelect: (id: string) => void;\n  onInsert: (afterId?: string) => void;\n  onDelete: (id: string) => void;\n}\n\nconst LadderNetworkList = ({ networks, currentNetworkId, onSelect, onInsert, onDelete }) => (\n  <div className=\"flex flex-col gap-1 p-2\">\n    {networks.map((network, index) => (\n      <NetworkListItem\n        key={network.id}\n        network={network}\n        index={index}\n        isSelected={network.id === currentNetworkId}\n        onSelect={() => onSelect(network.id)}\n        onInsertAfter={() => onInsert(network.id)}\n        onDelete={() => onDelete(network.id)}\n      />\n    ))}\n    <Button onClick={() => onInsert()} className=\"mt-2\">\n      <Plus size={16} /> Add Network\n    </Button>\n  </div>\n);\n```\n\n2. **Network Store Actions:**\n```typescript\naddNetwork: (afterNetworkId?: string) => {\n  const newNetwork: LadderNetwork = {\n    id: generateId(),\n    label: `Network ${get().networks.size + 1}`,\n    elements: new Map(),\n    wires: [],\n  };\n  set(state => {\n    // Insert at correct position\n    const networksArray = [...state.networks.values()];\n    const insertIndex = afterNetworkId\n      ? networksArray.findIndex(n => n.id === afterNetworkId) + 1\n      : networksArray.length;\n    networksArray.splice(insertIndex, 0, newNetwork);\n    state.networks = new Map(networksArray.map(n => [n.id, n]));\n    state.currentNetworkId = newNetwork.id;\n  });\n},\n\ndeleteNetwork: (id: string) => {\n  set(state => {\n    state.networks.delete(id);\n    if (state.currentNetworkId === id) {\n      state.currentNetworkId = state.networks.keys().next().value ?? null;\n    }\n  });\n},\n\nreorderNetwork: (fromIndex: number, toIndex: number) => {\n  set(state => {\n    const networksArray = [...state.networks.values()];\n    const [moved] = networksArray.splice(fromIndex, 1);\n    networksArray.splice(toIndex, 0, moved);\n    state.networks = new Map(networksArray.map(n => [n.id, n]));\n  });\n},\n```\n\n3. **Network Drag and Drop (Reordering):**\n- Use @dnd-kit/sortable for network list reordering\n- Drag handle on left side of network item\n\n4. **Network Label Editing:**\n```tsx\nconst NetworkListItem = ({ network, onRename }) => {\n  const [isEditing, setIsEditing] = useState(false);\n  const [label, setLabel] = useState(network.label);\n\n  return isEditing ? (\n    <input\n      value={label}\n      onChange={e => setLabel(e.target.value)}\n      onBlur={() => { onRename(label); setIsEditing(false); }}\n      onKeyDown={e => e.key === 'Enter' && e.currentTarget.blur()}\n      autoFocus\n    />\n  ) : (\n    <span onDoubleClick={() => setIsEditing(true)}>{network.label}</span>\n  );\n};\n```\n\n5. **Copy/Paste Network:**\n- Ctrl+Shift+C: Copy entire network\n- Ctrl+Shift+V: Paste network as new network\n\n6. **Network Comments:**\n- Add comment field to network\n- Display as header above grid",
        "testStrategy": "1. Adding network creates new empty network\n2. Selecting network switches grid view\n3. Deleting network removes from list\n4. Deleting current network selects next/previous\n5. Reordering networks updates order correctly\n6. Network label can be edited\n7. Copy/paste network duplicates all elements\n8. Network comments display correctly",
        "priority": "medium",
        "dependencies": [
          "71",
          "72",
          "78"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Network Store Actions",
            "description": "Create Zustand store actions for network management including addNetwork, deleteNetwork, reorderNetwork, and updateNetworkLabel with proper state management using immer.",
            "dependencies": [],
            "details": "Implement network store actions in useLadderEditorStore:\n\n1. **addNetwork(afterNetworkId?: string)**:\n   - Create new LadderNetwork with unique id, auto-generated label, empty elements Map, empty wires array\n   - Insert at correct position (after specified network or at end)\n   - Set as currentNetworkId\n\n2. **deleteNetwork(id: string)**:\n   - Remove network from Map\n   - If deleted network was current, select next or previous network\n   - Prevent deleting last network (minimum 1 required)\n\n3. **reorderNetwork(fromIndex: number, toIndex: number)**:\n   - Convert Map to array, reorder, convert back\n   - Maintain selection after reorder\n\n4. **updateNetworkLabel(id: string, label: string)**:\n   - Update network label in place\n\n5. **updateNetworkComment(id: string, comment: string)**:\n   - Add/update comment field on network",
            "status": "pending",
            "testStrategy": "1. Adding network creates new empty network at correct position\n2. Adding after specific network inserts correctly\n3. Deleting network removes from state\n4. Deleting current network selects appropriate alternative\n5. Cannot delete last remaining network\n6. Reorder correctly updates network order\n7. Label update persists correctly",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Network List Sidebar Component",
            "description": "Build LadderNetworkList component with NetworkListItem subcomponent for displaying, selecting, and managing networks in a sidebar panel.",
            "dependencies": [
              1
            ],
            "details": "Create network list UI components:\n\n1. **LadderNetworkList.tsx**:\n   - Display vertical list of networks with selection state\n   - Props: networks, currentNetworkId, onSelect, onInsert, onDelete\n   - 'Add Network' button at bottom\n   - Connect to store for state and actions\n\n2. **NetworkListItem.tsx**:\n   - Show network index and label\n   - Visual indication when selected (highlight background)\n   - Context menu or action buttons for insert after/delete\n   - Drag handle for reordering (prepared for subtask 3)\n\n3. **Integration with LadderEditor**:\n   - Add sidebar panel to left of grid\n   - Responsive layout with collapsible sidebar\n   - Keyboard navigation (up/down arrows)\n\n4. **Styling**:\n   - Use existing design system (Tailwind classes)\n   - Consistent with other sidebars in app",
            "status": "pending",
            "testStrategy": "1. Network list renders all networks\n2. Clicking network selects it and updates grid view\n3. Selected network shows visual highlight\n4. Add Network button creates new network\n5. Delete button removes network (with confirmation for non-empty)\n6. Insert After adds network at correct position\n7. Empty state handled when no networks",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Network Drag and Drop Reordering",
            "description": "Add drag-and-drop functionality to network list using @dnd-kit/sortable for intuitive network reordering with visual feedback.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement drag-and-drop reordering:\n\n1. **Setup @dnd-kit**:\n   - Import DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors\n   - Import SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy\n   - Import useSortable, arrayMove\n\n2. **SortableNetworkItem.tsx**:\n   - Wrap NetworkListItem with useSortable hook\n   - Add drag handle icon on left side (GripVertical from lucide-react)\n   - Apply transform and transition styles from useSortable\n   - Visual feedback during drag (opacity, shadow)\n\n3. **LadderNetworkList integration**:\n   - Wrap list with DndContext and SortableContext\n   - Handle onDragEnd to call reorderNetwork store action\n   - Use restrictToVerticalAxis modifier\n\n4. **Accessibility**:\n   - Keyboard reordering with Space to pick up, arrows to move, Space to drop\n   - Screen reader announcements for drag operations",
            "status": "pending",
            "testStrategy": "1. Drag handle appears on hover\n2. Dragging network shows drag overlay\n3. Dropping at new position reorders list\n4. Animation smooth during drag and drop\n5. Keyboard reordering works (Space, arrows)\n6. Cancel drag with Escape key\n7. Selection maintained after reorder",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Network Label Editing and Comments",
            "description": "Add inline editing for network labels with double-click activation and network comment field displayed as header above the grid.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement label editing and comments:\n\n1. **Inline Label Editing**:\n   - Double-click on label text to enter edit mode\n   - Show input field with current label value\n   - Auto-focus and select all text\n   - Blur or Enter to save changes\n   - Escape to cancel edit\n   - Validate non-empty label\n\n2. **EditableLabel component**:\n   - Reusable component for inline text editing\n   - Props: value, onSave, placeholder\n   - Handle focus management properly\n\n3. **Network Comment Field**:\n   - Add 'comment' optional field to LadderNetwork type\n   - Display comment as header row above grid\n   - Click to edit comment (similar to label editing)\n   - Support multi-line comments with textarea\n   - Placeholder text when no comment\n\n4. **Comment Header UI**:\n   - Styled differently from grid (lighter background, italic text)\n   - Edit icon button to enable editing\n   - Collapsible if comment is long",
            "status": "pending",
            "testStrategy": "1. Double-click label enters edit mode\n2. Enter key saves label change\n3. Escape key cancels edit\n4. Empty label rejected with validation\n5. Blur saves current value\n6. Comment displays above network grid\n7. Comment editing works with multi-line\n8. Empty comment shows placeholder",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Network Copy and Paste",
            "description": "Add copy/paste functionality for entire networks using Ctrl+Shift+C/V keyboard shortcuts with proper element and wire duplication.",
            "dependencies": [
              1
            ],
            "details": "Implement network clipboard operations:\n\n1. **Clipboard State**:\n   - Add copiedNetwork field to store (or use browser clipboard API)\n   - Store serialized network data including all elements and wires\n\n2. **copyNetwork(networkId: string)**:\n   - Deep clone the network object\n   - Serialize elements Map and wires array\n   - Store in clipboard state\n   - Show toast notification 'Network copied'\n\n3. **pasteNetwork(afterNetworkId?: string)**:\n   - Deserialize copied network\n   - Generate new unique IDs for network and all elements\n   - Update wire references to new element IDs\n   - Set label as 'Copy of [original label]'\n   - Insert as new network\n   - Select newly pasted network\n\n4. **Keyboard Shortcuts**:\n   - Register Ctrl+Shift+C for copy current network\n   - Register Ctrl+Shift+V for paste network\n   - Use existing keyboard shortcut system\n\n5. **Edge Cases**:\n   - Paste disabled when clipboard empty\n   - Handle paste into different grid sizes gracefully\n   - Preserve element device addresses",
            "status": "pending",
            "testStrategy": "1. Ctrl+Shift+C copies current network to clipboard\n2. Ctrl+Shift+V pastes network as new network\n3. Pasted network has new unique ID\n4. All elements in pasted network have new IDs\n5. Wire connections preserved with new element IDs\n6. Pasted network label prefixed with 'Copy of'\n7. Paste disabled when nothing copied\n8. Toast notifications shown for copy/paste",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement import/export for ladder programs in JSON and standard formats with OneParser integration"
      },
      {
        "id": "84",
        "title": "Integrate LadderEditor into Main Application",
        "description": "Update LadderEditorPanel to use the new components, connect to existing panel system, and add ladder editor to navigation.",
        "details": "Integrate all ladder editor components into the main application:\n\n1. **Update LadderEditorPanel:**\n```tsx\n// src/components/panels/content/LadderEditorPanel.tsx\nimport { LadderEditor } from '../../LadderEditor/LadderEditor';\n\nexport function LadderEditorPanel() {\n  return (\n    <div className=\"h-full flex flex-col\">\n      <LadderEditor />\n    </div>\n  );\n}\n```\n\n2. **Main LadderEditor Component:**\n```tsx\n// src/components/LadderEditor/LadderEditor.tsx\nimport { DndContext } from '@dnd-kit/core';\nimport { LadderToolbox } from './LadderToolbox';\nimport { LadderGrid } from './LadderGrid';\nimport { LadderPropertiesPanel } from './PropertiesPanel';\nimport { LadderNetworkList } from './LadderNetworkList';\nimport { LadderStatusBar } from './StatusBar';\nimport { useLadderDragDrop } from './hooks/useLadderDragDrop';\nimport { useLadderKeyboardShortcuts } from './hooks/useLadderKeyboardShortcuts';\n\nexport function LadderEditor() {\n  const { handleDragEnd } = useLadderDragDrop();\n  useLadderKeyboardShortcuts();\n\n  return (\n    <DndContext onDragEnd={handleDragEnd}>\n      <div className=\"h-full flex\">\n        {/* Network List - Left sidebar */}\n        <div className=\"w-48 border-r border-neutral-700\">\n          <LadderNetworkList />\n        </div>\n\n        {/* Main Content */}\n        <div className=\"flex-1 flex flex-col\">\n          {/* Toolbar */}\n          <LadderToolbar />\n\n          {/* Grid Area */}\n          <div className=\"flex-1 flex\">\n            {/* Toolbox */}\n            <LadderToolbox className=\"w-48 border-r border-neutral-700\" />\n\n            {/* Grid */}\n            <LadderGrid className=\"flex-1\" />\n\n            {/* Properties Panel */}\n            <LadderPropertiesPanel className=\"w-64 border-l border-neutral-700\" />\n          </div>\n\n          {/* Status Bar */}\n          <LadderStatusBar />\n        </div>\n      </div>\n    </DndContext>\n  );\n}\n```\n\n3. **Status Bar Component:**\n```tsx\n// StatusBar.tsx\nconst LadderStatusBar = () => {\n  const currentNetwork = useLadderStore(s => s.currentNetworkId);\n  const selectedCount = useLadderStore(s => s.selectedElementIds.size);\n  const mode = useLadderStore(s => s.mode);\n\n  return (\n    <div className=\"h-6 px-2 flex items-center justify-between bg-neutral-800 text-xs text-neutral-400\">\n      <span>Network: {currentNetwork}</span>\n      <span>{selectedCount} element(s) selected</span>\n      <span>Mode: {mode}</span>\n    </div>\n  );\n};\n```\n\n4. **Toolbar Component:**\n```tsx\n// LadderToolbar.tsx\nconst LadderToolbar = () => {\n  const { undo, redo, mode, startMonitoring, stopMonitoring } = useLadderStore();\n  const canUndo = useLadderStore(selectCanUndo);\n  const canRedo = useLadderStore(selectCanRedo);\n\n  return (\n    <div className=\"flex items-center gap-2 p-2 border-b border-neutral-700\">\n      <Button disabled={!canUndo} onClick={undo}><Undo2 size={16} /></Button>\n      <Button disabled={!canRedo} onClick={redo}><Redo2 size={16} /></Button>\n      <Separator />\n      {mode === 'edit' ? (\n        <Button onClick={startMonitoring}><Play size={16} /> Monitor</Button>\n      ) : (\n        <Button onClick={stopMonitoring}><Square size={16} /> Stop</Button>\n      )}\n    </div>\n  );\n};\n```\n\n5. **Export Index:**\n```typescript\n// src/components/LadderEditor/index.ts\nexport { LadderEditor } from './LadderEditor';\nexport { LadderGrid } from './LadderGrid';\nexport { LadderToolbox } from './LadderToolbox';\nexport * from './types';\n```",
        "testStrategy": "1. LadderEditorPanel renders without errors\n2. All sub-components render correctly\n3. Drag and drop works from toolbox to grid\n4. Keyboard shortcuts work\n5. Selection works\n6. Properties panel updates on selection\n7. Network list shows and allows switching\n8. Status bar displays correct information\n9. Undo/redo buttons work correctly\n10. Mode toggle works",
        "priority": "high",
        "dependencies": [
          "72",
          "76",
          "77",
          "83"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update LadderEditorPanel to integrate LadderEditor component",
            "description": "Replace the placeholder stub in LadderEditorPanel.tsx with the actual LadderEditor component import and rendering, following the OneCanvasPanel pattern.",
            "dependencies": [],
            "details": "Update src/components/panels/content/LadderEditorPanel.tsx to import and render the main LadderEditor component. Replace the current placeholder content ('Coming in Unit 4') with: 1) Import LadderEditor from '../../LadderEditor/LadderEditor', 2) Return a full-height flex container wrapping <LadderEditor />, 3) Apply consistent styling with other panels (h-full flex flex-col bg-neutral-950). The component should be memoized using React.memo following the OneCanvasPanel pattern.",
            "status": "pending",
            "testStrategy": "Verify LadderEditorPanel renders without errors, check that it displays the LadderEditor component instead of the placeholder, ensure proper styling matches other content panels.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create main LadderEditor component with layout structure",
            "description": "Implement the main LadderEditor.tsx component that orchestrates all sub-components with DndContext wrapper and proper layout structure.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/LadderEditor/LadderEditor.tsx with: 1) DndContext wrapper from @dnd-kit/core for drag-drop support, 2) Flex layout with left sidebar (LadderNetworkList, w-48), main content area with toolbar, toolbox (w-48), grid (flex-1), and properties panel (w-64), 3) StatusBar at the bottom, 4) Import and initialize useLadderDragDrop and useLadderKeyboardShortcuts hooks, 5) Use sensor configuration matching OneCanvasPanel (PointerSensor with distance: 8 constraint), 6) Apply consistent border styling (border-neutral-700).",
            "status": "pending",
            "testStrategy": "Verify DndContext wraps all content, check layout renders correctly with all placeholder sub-components, test that drag-drop hooks are initialized, ensure keyboard shortcuts are registered.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement LadderToolbar with edit and monitor controls",
            "description": "Create the LadderToolbar component with undo/redo, mode toggles (edit/monitor/debug), and simulation controls following existing toolbar patterns.",
            "dependencies": [
              2
            ],
            "details": "Create src/components/LadderEditor/LadderToolbar.tsx following SimulationToolbar and ScenarioToolbar patterns: 1) Import icons from lucide-react (Undo2, Redo2, Play, Square, Pause, ZoomIn, ZoomOut, Bug), 2) Connect to useLadderStore for undo/redo state and actions (selectCanUndo, selectCanRedo), 3) Implement mode toggle buttons (edit, monitor, debug) with active state styling, 4) Add simulation controls (startMonitoring, stopMonitoring) that show/hide based on current mode, 5) Include zoom controls if applicable, 6) Use ToolbarButton pattern with tooltips and ToolbarSeparator for visual grouping, 7) Style with Tailwind: flex items-center gap-2 p-2 border-b border-neutral-700.",
            "status": "pending",
            "testStrategy": "Test undo/redo buttons enable/disable based on history state, verify mode toggle buttons switch correctly, test monitor start/stop controls function, check button styling and hover states.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement LadderStatusBar for editor state display",
            "description": "Create the StatusBar component to display current network, selection count, and editor mode information.",
            "dependencies": [
              2
            ],
            "details": "Create src/components/LadderEditor/StatusBar.tsx (or LadderStatusBar.tsx): 1) Connect to useLadderStore for currentNetworkId, selectedElementIds (use .size for count), and mode state, 2) Create a compact status bar layout (h-6 px-2 flex items-center justify-between), 3) Display three sections: left (Network: {id}), center ({count} element(s) selected), right (Mode: {mode}), 4) Apply styling: bg-neutral-800 text-xs text-neutral-400, 5) Handle edge cases: no network selected, zero elements selected. Export the component from the LadderEditor index file.",
            "status": "pending",
            "testStrategy": "Verify status bar displays correct network ID, test selection count updates on element selection/deselection, confirm mode label updates when mode changes, check styling matches design.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create LadderEditor index exports and verify integration",
            "description": "Create the index.ts barrel export file and verify the complete LadderEditor integration works within the panel system.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create src/components/LadderEditor/index.ts with exports: 1) Export LadderEditor as default and named export, 2) Export LadderGrid, LadderToolbox, LadderToolbar, LadderStatusBar, LadderNetworkList, LadderPropertiesPanel, 3) Re-export all types from './types', 4) Verify the component tree renders correctly: LadderEditorPanel → LadderEditor → (Toolbar, NetworkList, Toolbox, Grid, PropertiesPanel, StatusBar), 5) Ensure panel can be opened via the existing panel system (verify panelContentMap in Panel.tsx maps 'ladder-editor' correctly), 6) Test that the ladder-editor panel type in navigation/menu items opens the integrated LadderEditor.",
            "status": "pending",
            "testStrategy": "Verify all exports are accessible from the index file, test LadderEditorPanel renders the full component hierarchy, confirm panel opens correctly from existing navigation, check no console errors on render, test all sub-components are present in the DOM.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Create toolbar with common actions (undo, redo, zoom, run, stop) and mode toggles (edit, monitor, debug)"
      },
      {
        "id": "85",
        "title": "Add Comparison Block Elements",
        "description": "Implement comparison block elements (EQ, GT, LT, GE, LE, NE) for ladder diagrams with operand configuration.",
        "details": "Create comparison block components:\n\n1. **Comparison Component:**\n```tsx\n// elements/Comparison.tsx\ninterface ComparisonProps {\n  type: 'eq' | 'gt' | 'lt' | 'ge' | 'le' | 'ne';\n  operand1: { type: 'device' | 'constant'; value: string | number };\n  operand2: { type: 'device' | 'constant'; value: string | number };\n  result?: boolean; // monitoring\n}\n\nconst comparisonSymbols = {\n  eq: '=',\n  gt: '>',\n  lt: '<',\n  ge: '>=',\n  le: '<=',\n  ne: '<>',\n};\n\nconst Comparison = ({ type, operand1, operand2, result }) => (\n  <div className={cn(\n    'w-32 h-20 border rounded flex flex-col items-center justify-center',\n    result && 'bg-green-500/30'\n  )}>\n    <div className=\"text-xs font-medium\">CMP</div>\n    <div className=\"flex items-center gap-1\">\n      <span className=\"text-sm\">{formatOperand(operand1)}</span>\n      <span className=\"text-lg font-bold\">{comparisonSymbols[type]}</span>\n      <span className=\"text-sm\">{formatOperand(operand2)}</span>\n    </div>\n  </div>\n);\n```\n\n2. **Operand Types:**\n```typescript\ninterface ComparisonOperand {\n  type: 'device' | 'constant';\n  value: string | number; // device address or constant value\n}\n```\n\n3. **Comparison Properties Panel:**\n```tsx\n// properties/ComparisonProperties.tsx\nconst ComparisonProperties = ({ element }) => (\n  <>\n    <PropertyField label=\"Comparison Type\" value={element.type} options={comparisonTypes} />\n    <OperandField label=\"Operand 1\" value={element.properties.operand1} />\n    <OperandField label=\"Operand 2\" value={element.properties.operand2} />\n  </>\n);\n\nconst OperandField = ({ label, value, onChange }) => (\n  <div>\n    <label>{label}</label>\n    <select value={value.type} onChange={e => onChange({ ...value, type: e.target.value })}>\n      <option value=\"device\">Device</option>\n      <option value=\"constant\">Constant</option>\n    </select>\n    {value.type === 'device' ? (\n      <input type=\"text\" value={value.value} placeholder=\"D0\" />\n    ) : (\n      <input type=\"number\" value={value.value} />\n    )}\n  </div>\n);\n```\n\n4. **Add to Toolbox:**\n```typescript\nconst toolboxItems = [\n  // ... existing items\n  { category: 'Comparison', items: [\n    { type: 'compare_eq', label: '= Equal', icon: '=' },\n    { type: 'compare_gt', label: '> Greater', icon: '>' },\n    { type: 'compare_lt', label: '< Less', icon: '<' },\n    { type: 'compare_ge', label: '>= Greater/Equal', icon: '>=' },\n    { type: 'compare_le', label: '<= Less/Equal', icon: '<=' },\n    { type: 'compare_ne', label: '<> Not Equal', icon: '<>' },\n  ]},\n];\n```\n\n5. **Block Sizing:** Comparison blocks occupy 2 columns width (160px)",
        "testStrategy": "1. All comparison types render with correct symbols\n2. Operands display correctly (device address or constant)\n3. Properties panel shows operand editors\n4. Operand type can be changed between device/constant\n5. Monitoring result shows green when true\n6. Block can be dragged from toolbox\n7. Block sizing is correct (2 columns width)",
        "priority": "low",
        "dependencies": [
          "74"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Comparison Component and Type Definitions",
            "description": "Implement the core Comparison component with visual rendering for all comparison types (EQ, GT, LT, GE, LE, NE) and define TypeScript interfaces.",
            "dependencies": [],
            "details": "Create elements/Comparison.tsx with ComparisonProps interface including type, operand1, operand2, and result properties. Implement the comparisonSymbols mapping object for all 6 operators. Build the Comparison component that renders a styled box with CMP label, operand values, comparison symbol, and conditional green background for true results. Include formatOperand utility function.",
            "status": "pending",
            "testStrategy": "Test all 6 comparison types render with correct symbols (=, >, <, >=, <=, <>). Verify result=true shows green background. Test operand display formatting for both device and constant types.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Operand Type System",
            "description": "Define the ComparisonOperand interface and implement operand handling utilities for device addresses and constant values.",
            "dependencies": [
              1
            ],
            "details": "Define ComparisonOperand interface with type ('device' | 'constant') and value (string | number) properties. Create utility functions for operand validation, serialization, and formatting. Ensure device operands support address formats (e.g., D0, M100) and constant operands handle numeric values correctly. Add to LadderEditor types.",
            "status": "pending",
            "testStrategy": "Test device operand accepts valid PLC addresses. Test constant operand accepts numeric input. Verify operand validation rejects invalid formats. Test serialization/deserialization of operand data.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create ComparisonProperties Panel",
            "description": "Implement the properties panel for editing comparison elements including comparison type selection and operand configuration fields.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create properties/ComparisonProperties.tsx with PropertyField for comparison type selection. Implement OperandField component with type selector (device/constant) and conditional input field - text input for device addresses, number input for constants. Wire onChange handlers to update element properties. Style consistently with existing properties panels.",
            "status": "pending",
            "testStrategy": "Test comparison type dropdown shows all 6 options. Test operand type can be switched between device and constant. Verify device input shows text field with placeholder. Verify constant input shows number field. Test property changes update element state.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Comparison Category to Toolbox",
            "description": "Extend the ladder editor toolbox with a Comparison category containing all 6 comparison element types with icons and labels.",
            "dependencies": [
              1
            ],
            "details": "Add new 'Comparison' category to toolboxItems array with 6 items: compare_eq (=), compare_gt (>), compare_lt (<), compare_ge (>=), compare_le (<=), compare_ne (<>). Each item includes type, label, and icon properties. Configure comparison blocks to occupy 2 columns width (160px) when placed on grid. Update toolbox rendering to display new category.",
            "status": "pending",
            "testStrategy": "Test Comparison category appears in toolbox. Verify all 6 comparison types are listed with correct labels and icons. Test dragging comparison from toolbox creates correct element type. Verify 2-column width is applied on grid placement.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integration Testing and Store Logic",
            "description": "Add comprehensive tests for comparison block operations, grid interactions, and store logic integration with App.tsx routing.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create test suite for comparison elements covering: component rendering, operand editing, toolbox drag-and-drop, grid placement with 2-column span, properties panel integration, and store state management. Verify LadderEditor integration with App.tsx routing. Test monitoring mode shows comparison results. Ensure comparison elements work with existing ladder element interactions.",
            "status": "pending",
            "testStrategy": "Run full integration tests for grid operations with comparison blocks. Test drag-drop from toolbox. Verify properties panel edits persist to store. Test 2-column span doesn't overlap other elements. Confirm App.tsx routing loads LadderEditor correctly.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Integrate LadderEditor with App.tsx routing, add comprehensive tests for grid operations, element interactions, and store logic"
      },
      {
        "id": "86",
        "title": "Define OneSim Core Types and Interfaces",
        "description": "Create comprehensive TypeScript and Rust type definitions for the OneSim simulation engine including device memory types, timer/counter state, scan cycle configuration, and simulation status interfaces.",
        "details": "## TypeScript Types (`src/components/OneSim/types.ts`)\n\n1. **Device Memory Types:**\n```typescript\n// Bit Devices\nexport type BitDeviceType = 'P' | 'M' | 'K' | 'F' | 'T' | 'C';\nexport interface BitDeviceConfig {\n  type: BitDeviceType;\n  size: number; // P:2048, M:8192, K:2048, F:2048, T:2048, C:2048\n  readonly: boolean;\n  description: string;\n}\n\n// Word Devices\nexport type WordDeviceType = 'D' | 'R' | 'Z' | 'N' | 'TD' | 'CD';\nexport interface WordDeviceConfig {\n  type: WordDeviceType;\n  size: number; // D:10000, R:10000, Z:16, N:8192, TD:2048, CD:2048\n  description: string;\n}\n```\n\n2. **Timer/Counter Types:**\n```typescript\nexport type TimerType = 'TON' | 'TOF' | 'TMR';\nexport type CounterType = 'CTU' | 'CTD' | 'CTUD';\nexport type TimeBase = 'ms' | '10ms' | '100ms' | 's';\n\nexport interface TimerState {\n  enabled: boolean;\n  done: boolean;\n  elapsed: number; // ms\n  preset: number;\n  timeBase: TimeBase;\n}\n\nexport interface CounterState {\n  done: boolean;\n  currentValue: number;\n  preset: number;\n  prevUp: boolean; // for edge detection\n  prevDown?: boolean; // for CTUD\n}\n```\n\n3. **Simulation Config & Status:**\n```typescript\nexport interface SimulationConfig {\n  scanTimeMs: number; // default: 10\n  watchdogTimeoutMs: number; // default: 1000\n  syncMode: 'immediate' | 'endOfScan' | 'manual';\n}\n\nexport interface SimulationStatus {\n  state: 'stopped' | 'running' | 'paused' | 'error';\n  scanCount: number;\n  lastScanTimeUs: number;\n  avgScanTimeUs: number;\n  maxScanTimeUs: number;\n  error?: string;\n}\n\nexport interface ScanCycleInfo {\n  cycleCount: number;\n  lastScanTime: number;\n  averageScanTime: number;\n  maxScanTime: number;\n  timestamp: number;\n}\n```\n\n4. **Debugger Types:**\n```typescript\nexport type BreakpointType = 'network' | 'device' | 'condition' | 'scanCount';\n\nexport interface Breakpoint {\n  id: string;\n  type: BreakpointType;\n  enabled: boolean;\n  networkId?: number;\n  deviceAddress?: string;\n  condition?: string;\n  scanCount?: number;\n}\n\nexport interface WatchVariable {\n  address: string;\n  currentValue: number | boolean;\n  previousValue: number | boolean;\n  changeCount: number;\n  lastChangeTime: number;\n  history: Array<{ value: number | boolean; timestamp: number }>;\n}\n```\n\n## Rust Types (`src-tauri/src/sim/types.rs`)\nCreate equivalent Rust structs with serde derive for all TypeScript types, ensuring JSON serialization matches the TypeScript interfaces.",
        "testStrategy": "1. Verify TypeScript compilation passes with `pnpm tsc --noEmit`\n2. Test all interfaces can be instantiated with valid data\n3. Verify Rust types serialize/deserialize to match TypeScript structure\n4. Unit test type guards for device types (isBitDevice, isWordDevice)\n5. Test default values are valid according to type constraints",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TypeScript Device Memory Types (BitDevice and WordDevice)",
            "description": "Define TypeScript types for PLC device memory including BitDeviceType, BitDeviceConfig, WordDeviceType, and WordDeviceConfig with proper size configurations.",
            "dependencies": [],
            "details": "Create `src/components/OneSim/types.ts` with the following types:\n\n1. BitDeviceType union: 'P' | 'M' | 'K' | 'F' | 'T' | 'C'\n2. BitDeviceConfig interface with type, size (P:2048, M:8192, K:2048, F:2048, T:2048, C:2048), readonly flag, and description\n3. WordDeviceType union: 'D' | 'R' | 'Z' | 'N' | 'TD' | 'CD'\n4. WordDeviceConfig interface with type, size (D:10000, R:10000, Z:16, N:8192, TD:2048, CD:2048), and description\n5. Add type guards: isBitDevice(), isWordDevice()\n6. Include default configuration constants for each device type\n\nFollow the existing patterns from src/components/OneCanvas/types.ts for documentation style and structure.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation passes with `pnpm tsc --noEmit`. Test that type guards correctly identify bit vs word devices. Validate default configurations match specified sizes.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create TypeScript Timer/Counter State Types",
            "description": "Define TypeScript types for timer and counter state management including TimerType, CounterType, TimeBase, TimerState, and CounterState interfaces.",
            "dependencies": [
              1
            ],
            "details": "Add to `src/components/OneSim/types.ts`:\n\n1. TimerType union: 'TON' | 'TOF' | 'TMR'\n2. CounterType union: 'CTU' | 'CTD' | 'CTUD'\n3. TimeBase union: 'ms' | '10ms' | '100ms' | 's'\n4. TimerState interface with enabled, done, elapsed (ms), preset, timeBase fields\n5. CounterState interface with done, currentValue, preset, prevUp (for edge detection), prevDown (for CTUD)\n6. Add factory functions: createTimerState(), createCounterState() with sensible defaults\n7. Add validation functions: isValidTimerPreset(), isValidCounterPreset()\n\nEnsure elapsed time handling accounts for different time bases.",
            "status": "pending",
            "testStrategy": "Test timer state initialization with default values. Verify time base calculations are correct. Test counter edge detection state initialization.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create TypeScript Simulation Config and Status Types",
            "description": "Define TypeScript types for simulation configuration, runtime status, and scan cycle information interfaces.",
            "dependencies": [
              1
            ],
            "details": "Add to `src/components/OneSim/types.ts`:\n\n1. SyncMode union: 'immediate' | 'endOfScan' | 'manual'\n2. SimulationConfig interface with scanTimeMs (default: 10), watchdogTimeoutMs (default: 1000), syncMode\n3. SimulationState union: 'stopped' | 'running' | 'paused' | 'error'\n4. SimulationStatus interface with state, scanCount, lastScanTimeUs, avgScanTimeUs, maxScanTimeUs, optional error string\n5. ScanCycleInfo interface with cycleCount, lastScanTime, averageScanTime, maxScanTime, timestamp\n6. Add DEFAULT_SIMULATION_CONFIG constant\n7. Add DEFAULT_SIMULATION_STATUS constant\n\nFollow patterns from scenario.ts for status and state type definitions.",
            "status": "pending",
            "testStrategy": "Verify default configurations produce valid SimulationConfig objects. Test that SimulationStatus state transitions are type-safe. Validate scan time units are consistent (microseconds).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create TypeScript Debugger Types (Breakpoint and WatchVariable)",
            "description": "Define TypeScript types for debugger functionality including BreakpointType, Breakpoint interface, and WatchVariable interface with history tracking.",
            "dependencies": [
              1
            ],
            "details": "Add to `src/components/OneSim/types.ts`:\n\n1. BreakpointType union: 'network' | 'device' | 'condition' | 'scanCount'\n2. Breakpoint interface with id, type, enabled, optional networkId, optional deviceAddress, optional condition string, optional scanCount\n3. WatchVariable interface with address, currentValue (number|boolean), previousValue (number|boolean), changeCount, lastChangeTime, history array of {value, timestamp}\n4. Add type guard: isConditionalBreakpoint()\n5. Add factory functions: createBreakpoint(), createWatchVariable()\n6. Add validation: isValidBreakpointCondition() for parsing condition expressions\n\nEnsure WatchVariable history has a configurable max length to prevent memory issues.",
            "status": "pending",
            "testStrategy": "Test breakpoint creation for all breakpoint types. Verify WatchVariable tracks value changes correctly. Test history array growth and potential truncation.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Rust Equivalent Types with Serde Serialization",
            "description": "Create matching Rust structs in src-tauri/src/sim/types.rs with serde derive macros for JSON serialization compatibility with TypeScript types.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create `src-tauri/src/sim/types.rs` and `src-tauri/src/sim/mod.rs`:\n\n1. Add mod.rs with `pub mod types;`\n2. In types.rs, define Rust equivalents for all TypeScript types:\n   - BitDeviceType and WordDeviceType as enums with #[serde(rename_all = \"UPPERCASE\")]\n   - DeviceConfig structs with appropriate sizes\n   - TimerType, CounterType, TimeBase enums\n   - TimerState, CounterState structs with #[serde(rename_all = \"camelCase\")]\n   - SimulationConfig, SimulationStatus, ScanCycleInfo structs\n   - BreakpointType enum, Breakpoint struct, WatchVariable struct\n3. Implement Default traits for config/state structs\n4. Add the sim module to src-tauri/src/lib.rs\n\nFollow patterns from src-tauri/src/scenario/types.rs for serde attributes and Default implementations.",
            "status": "pending",
            "testStrategy": "Test Rust types serialize/deserialize to match TypeScript interface structure. Verify camelCase field naming matches frontend expectations. Unit test roundtrip JSON serialization for all types.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Define TypeScript and Rust types for OneSim including DeviceMemory, SimulationState, ScanCycleState following existing memory.rs patterns"
      },
      {
        "id": "87",
        "title": "Implement DeviceMemory Rust Module",
        "description": "Create the DeviceMemory module in Rust that manages all PLC device memory areas (P, M, K, F, T, C for bits; D, R, Z, N, TD, CD for words) with thread-safe access using bitvec and parking_lot.",
        "details": "## File: `src-tauri/src/sim/memory.rs`\n\n1. **Device Memory Structure:**\n```rust\nuse bitvec::prelude::*;\nuse parking_lot::RwLock;\nuse std::collections::HashMap;\n\npub struct DeviceMemory {\n    // Bit devices\n    p_relays: RwLock<BitVec<u8, Msb0>>,    // Input Relay: 2048 bits\n    m_relays: RwLock<BitVec<u8, Msb0>>,    // Auxiliary: 8192 bits\n    k_relays: RwLock<BitVec<u8, Msb0>>,    // Keep: 2048 bits (persistent)\n    f_relays: RwLock<BitVec<u8, Msb0>>,    // Special: 2048 bits (readonly)\n    t_contacts: RwLock<BitVec<u8, Msb0>>,  // Timer: 2048 bits\n    c_contacts: RwLock<BitVec<u8, Msb0>>,  // Counter: 2048 bits\n    \n    // Word devices\n    d_registers: RwLock<Vec<u16>>,          // Data: 10000 words\n    r_registers: RwLock<Vec<u16>>,          // File: 10000 words\n    z_registers: RwLock<Vec<u16>>,          // Index: 16 words\n    n_registers: RwLock<Vec<u16>>,          // Link: 8192 words\n    td_values: RwLock<Vec<u16>>,            // Timer current: 2048 words\n    cd_values: RwLock<Vec<u16>>,            // Counter current: 2048 words\n    \n    // Edge detection for P/N contacts\n    previous_bits: RwLock<HashMap<String, bool>>,\n}\n```\n\n2. **Core Methods:**\n```rust\nimpl DeviceMemory {\n    pub fn new() -> Self;\n    \n    // Bit device operations\n    pub fn read_bit(&self, device: BitDeviceType, address: u16) -> Result<bool, SimError>;\n    pub fn write_bit(&self, device: BitDeviceType, address: u16, value: bool) -> Result<(), SimError>;\n    pub fn read_bits(&self, device: BitDeviceType, start: u16, count: u16) -> Result<Vec<bool>, SimError>;\n    \n    // Word device operations\n    pub fn read_word(&self, device: WordDeviceType, address: u16) -> Result<u16, SimError>;\n    pub fn write_word(&self, device: WordDeviceType, address: u16, value: u16) -> Result<(), SimError>;\n    pub fn read_words(&self, device: WordDeviceType, start: u16, count: u16) -> Result<Vec<u16>, SimError>;\n    \n    // Word bit access (D0000.5)\n    pub fn read_word_bit(&self, device: WordDeviceType, address: u16, bit: u8) -> Result<bool, SimError>;\n    pub fn write_word_bit(&self, device: WordDeviceType, address: u16, bit: u8, value: bool) -> Result<(), SimError>;\n    \n    // Edge detection\n    pub fn detect_rising_edge(&self, address: &str, current: bool) -> bool;\n    pub fn detect_falling_edge(&self, address: &str, current: bool) -> bool;\n    pub fn update_previous(&self, address: &str, value: bool);\n    \n    // Snapshot/Clear\n    pub fn get_snapshot(&self) -> MemorySnapshot;\n    pub fn clear(&self);\n    pub fn clear_volatile(&self); // Clear all except K (keep) relays\n}\n```\n\n3. **Address Validation:** Validate address ranges for each device type before read/write operations.",
        "testStrategy": "1. Test read/write for all bit devices (P, M, K, F, T, C) at boundary addresses (0, max-1)\n2. Test read/write for all word devices (D, R, Z, N, TD, CD)\n3. Test word bit access (D0000.0 through D0000.15)\n4. Test rising edge detection: false->true returns true, true->true returns false\n5. Test falling edge detection: true->false returns true, false->false returns false\n6. Test concurrent read/write operations from multiple threads\n7. Test clear_volatile preserves K relay values",
        "priority": "high",
        "dependencies": [
          "86"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define DeviceMemory struct and implement new() constructor",
            "description": "Create the core DeviceMemory struct with all bit devices (P, M, K, F, T, C) using BitVec and word devices (D, R, Z, N, TD, CD) using Vec<u16>, wrapped in RwLock for thread safety.",
            "dependencies": [],
            "details": "Create `src-tauri/src/sim/memory.rs` with the DeviceMemory struct definition. Include all fields: p_relays (2048 bits), m_relays (8192 bits), k_relays (2048 bits), f_relays (2048 bits), t_contacts (2048 bits), c_contacts (2048 bits) using BitVec<u8, Msb0>, and d_registers (10000 words), r_registers (10000 words), z_registers (16 words), n_registers (8192 words), td_values (2048 words), cd_values (2048 words) using Vec<u16>. Add previous_bits HashMap for edge detection. Implement new() to initialize all fields with proper sizes.",
            "status": "pending",
            "testStrategy": "Test that new() creates a DeviceMemory instance with all fields initialized to correct sizes. Verify all RwLock fields can be acquired for reading/writing.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement bit device operations (read_bit, write_bit, read_bits)",
            "description": "Implement thread-safe bit device operations for P, M, K, F, T, C relays with address validation and proper error handling.",
            "dependencies": [
              1
            ],
            "details": "Define BitDeviceType enum with variants P, M, K, F, T, C. Implement read_bit() to acquire read lock and return bit value at address. Implement write_bit() with special handling: F relays should return error (readonly), all others acquire write lock and set bit. Implement read_bits() to read a range of bits. Add address range validation: P(0-2047), M(0-8191), K(0-2047), F(0-2047), T(0-2047), C(0-2047). Return SimError::AddressOutOfRange for invalid addresses.",
            "status": "pending",
            "testStrategy": "Test read/write at boundary addresses (0, max-1) for all bit devices. Test F relay write returns error. Test read_bits returns correct slice. Test out-of-range addresses return proper error.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement word device operations (read_word, write_word, read_words)",
            "description": "Implement thread-safe word device operations for D, R, Z, N, TD, CD registers with address validation and error handling.",
            "dependencies": [
              1
            ],
            "details": "Define WordDeviceType enum with variants D, R, Z, N, TD, CD. Implement read_word() to acquire read lock and return u16 value at address. Implement write_word() to acquire write lock and set u16 value. Implement read_words() to read a contiguous range of words. Add address range validation: D(0-9999), R(0-9999), Z(0-15), N(0-8191), TD(0-2047), CD(0-2047). Return SimError for invalid addresses or indices.",
            "status": "pending",
            "testStrategy": "Test read/write at boundary addresses for all word devices. Test read_words returns correct slice. Test Z register limited range (0-15). Test out-of-range addresses return proper error.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement word bit access and edge detection methods",
            "description": "Implement methods to access individual bits within word devices (D0000.5 style) and edge detection for P/N contacts using previous_bits HashMap.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement read_word_bit(device, address, bit) where bit is 0-15, extracting single bit from word using bitwise operations. Implement write_word_bit() to modify single bit in word without affecting others. Implement detect_rising_edge(address, current) that compares current value with previous_bits to detect false->true transition. Implement detect_falling_edge() for true->false transition. Implement update_previous(address, value) to store current state for next edge detection. Use string-based address keys like 'M0001' in previous_bits HashMap.",
            "status": "pending",
            "testStrategy": "Test read_word_bit for all bit positions (0-15). Test write_word_bit preserves other bits. Test rising edge: false->true returns true, true->true returns false. Test falling edge: true->false returns true, false->false returns false.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement snapshot, clear operations, and define error types",
            "description": "Implement memory snapshot for state capture, clear operations (full and volatile-only), and define SimError enum for comprehensive error handling.",
            "dependencies": [
              2,
              3
            ],
            "details": "Define MemorySnapshot struct to hold serializable copy of all memory areas. Implement get_snapshot() that acquires read locks on all devices and copies their values into MemorySnapshot. Implement clear() to reset all devices to zero/false. Implement clear_volatile() that clears all devices except k_relays (keep relays are persistent across clear). Define SimError enum with variants: AddressOutOfRange { device: String, address: u16, max: u16 }, ReadOnlyDevice { device: String }, BitIndexOutOfRange { index: u8 }. Derive Serialize on MemorySnapshot for Tauri event emission.",
            "status": "pending",
            "testStrategy": "Test get_snapshot captures all device values correctly. Test clear() resets all values to zero. Test clear_volatile() preserves K relay values. Test error types contain correct diagnostic information.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement DeviceMemory in Rust using bitvec and parking_lot patterns from memory.rs with X/Y/D/M/T/C regions"
      },
      {
        "id": "88",
        "title": "Implement Timer and Counter Managers",
        "description": "Create Timer and Counter manager modules that handle runtime state for TON/TOF/TMR timers and CTU/CTD/CTUD counters with proper timing and edge detection.",
        "details": "## File: `src-tauri/src/sim/timer.rs`\n\n1. **Timer Manager:**\n```rust\nuse std::collections::HashMap;\nuse parking_lot::RwLock;\nuse std::time::Instant;\n\npub struct TimerManager {\n    timers: RwLock<HashMap<u16, TimerRuntime>>,\n    last_update: RwLock<Instant>,\n}\n\nstruct TimerRuntime {\n    timer_type: TimerType,\n    preset: u16,\n    time_base: TimeBase,\n    enabled: bool,\n    done: bool,\n    elapsed_ms: u32,\n    last_input: bool,\n}\n\nimpl TimerManager {\n    pub fn new() -> Self;\n    \n    /// Update timer with current input condition\n    /// Returns (contact_state, current_value)\n    pub fn update(&self, address: u16, timer_type: TimerType, input: bool, \n                  preset: u16, time_base: TimeBase, elapsed_ms: u32) -> (bool, u16);\n    \n    /// Update all timers (called each scan with delta time)\n    pub fn tick(&self, delta_ms: u32);\n    \n    /// Get timer state for monitoring\n    pub fn get_state(&self, address: u16) -> Option<TimerState>;\n    \n    /// Reset specific timer\n    pub fn reset(&self, address: u16);\n    \n    /// Clear all timers\n    pub fn clear(&self);\n}\n```\n\n2. **Timer Logic:**\n- **TON (ON Delay):** Start timing when input=true, contact=true after preset reached, reset when input=false\n- **TOF (OFF Delay):** Contact=true immediately when input=true, start timing when input=false, contact=false after preset\n- **TMR (Accumulating):** Accumulate time while input=true, only reset by explicit RST instruction\n\n## File: `src-tauri/src/sim/counter.rs`\n\n3. **Counter Manager:**\n```rust\npub struct CounterManager {\n    counters: RwLock<HashMap<u16, CounterRuntime>>,\n}\n\nstruct CounterRuntime {\n    counter_type: CounterType,\n    preset: u16,\n    current: u16,\n    done: bool,\n    prev_up: bool,\n    prev_down: bool,\n}\n\nimpl CounterManager {\n    pub fn new() -> Self;\n    \n    /// Update counter with current inputs (returns contact_state)\n    pub fn update(&self, address: u16, counter_type: CounterType,\n                  up_input: bool, down_input: Option<bool>, preset: u16) -> bool;\n    \n    /// Get counter state\n    pub fn get_state(&self, address: u16) -> Option<CounterState>;\n    \n    /// Reset counter\n    pub fn reset(&self, address: u16);\n    \n    /// Clear all counters\n    pub fn clear(&self);\n}\n```\n\n4. **Counter Logic:**\n- **CTU:** Increment on rising edge of input, done=true when current >= preset\n- **CTD:** Decrement on rising edge, done=true when current <= 0\n- **CTUD:** Two inputs (up/down), increment on up edge, decrement on down edge",
        "testStrategy": "1. Test TON: verify timing accumulates while input true, resets when false\n2. Test TOF: verify output ON immediately, timing starts when input goes false\n3. Test TMR: verify accumulating timer doesn't reset on input false\n4. Test CTU: verify increment on rising edge only, not on steady true\n5. Test CTD: verify decrement on rising edge, done when reaches 0\n6. Test CTUD: verify both up and down counting\n7. Test time base conversion (ms, 10ms, 100ms, s)\n8. Test timer/counter preset boundary values",
        "priority": "high",
        "dependencies": [
          "86",
          "87"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement TON/TOF/TMR Timer Behavior with Elapsed Time Tracking",
            "description": "Create the TimerManager struct and implement the three timer types (TON, TOF, TMR) with proper timing logic, input condition handling, and elapsed time accumulation.",
            "dependencies": [],
            "details": "Implement timer.rs with:\n1. TimerManager struct with RwLock<HashMap<u16, TimerRuntime>> for thread-safe timer storage\n2. TimerRuntime struct with fields: timer_type, preset, time_base, enabled, done, elapsed_ms, last_input\n3. TON logic: Start timing when input=true, set done=true when elapsed_ms >= preset*time_base_ms, reset elapsed and done when input=false\n4. TOF logic: Set done=true immediately when input=true, start timing when input transitions to false, set done=false after preset reached\n5. TMR (Retentive): Accumulate elapsed_ms while input=true, DO NOT reset when input=false (only reset via explicit reset() call)\n6. tick(delta_ms) method to update all enabled timers by adding delta time\n7. update() method that processes input conditions and returns (contact_state, current_value)",
            "status": "pending",
            "testStrategy": "1. Test TON: verify timing accumulates while input=true, done=true after preset, resets when input=false\n2. Test TOF: verify done=true immediately when input=true, timing starts when input goes false, done=false after preset\n3. Test TMR: verify accumulating timer doesn't reset on input=false, only on explicit reset\n4. Test multiple timers running concurrently with different presets and time bases",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement CTU/CTD/CTUD Counter Logic with Edge Detection",
            "description": "Create the CounterManager struct and implement counter types (CTU, CTD, CTUD) with rising edge detection and preset comparison logic.",
            "dependencies": [
              1
            ],
            "details": "Implement counter.rs with:\n1. CounterManager struct with RwLock<HashMap<u16, CounterRuntime>> for thread-safe counter storage\n2. CounterRuntime struct with fields: counter_type, preset, current, done, prev_up, prev_down\n3. Rising edge detection: compare current input with prev_up/prev_down, trigger only on false->true transition\n4. CTU logic: Increment current on rising edge of up_input, set done=true when current >= preset\n5. CTD logic: Decrement current on rising edge of input, set done=true when current <= 0\n6. CTUD logic: Handle both up_input and down_input separately, increment on up edge, decrement on down edge, done when current >= preset\n7. update() method returns contact_state (done flag) after processing inputs\n8. Ensure counter values stay within bounds (u16::MIN to u16::MAX)",
            "status": "pending",
            "testStrategy": "1. Test CTU: verify increment on rising edge only, not on steady true\n2. Test CTD: verify decrement on rising edge, done when current <= 0\n3. Test CTUD: verify both up and down inputs work independently with proper edge detection\n4. Test preset comparison logic for done flag\n5. Test boundary conditions (counter at 0, counter at u16::MAX)",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Timer/Counter State Query, Persistence, and Reset Functions",
            "description": "Implement state query methods for monitoring, individual and bulk reset functions, and ensure proper state persistence across simulation scans.",
            "dependencies": [
              1,
              2
            ],
            "details": "Complete both managers with state management:\n1. TimerState struct with fields: timer_type, preset, elapsed, done, enabled for external monitoring\n2. CounterState struct with fields: counter_type, preset, current, done for external monitoring\n3. get_state(address) method on both managers returning Option<State> for UI monitoring\n4. reset(address) method to reset individual timer/counter to initial state (elapsed=0, current=0, done=false)\n5. clear() method to remove all timers/counters from the HashMap (for simulation restart)\n6. TimerManager.new() and CounterManager.new() constructors initializing empty HashMaps\n7. Ensure TimerRuntime and CounterRuntime persist between scan cycles (don't recreate on each update call)\n8. Add last_update: RwLock<Instant> to TimerManager for calculating delta time if needed\n9. Export TimerState and CounterState as public types with Serialize derive for Tauri commands",
            "status": "pending",
            "testStrategy": "1. Test get_state returns correct timer/counter values during simulation\n2. Test reset clears individual timer/counter without affecting others\n3. Test clear removes all timers/counters\n4. Test state persistence across multiple scan cycles\n5. Test that managers can be queried from Tauri commands for UI display",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Subtasks: 1) Implement TON/TOF/RTO timer behavior with elapsed time tracking 2) Implement CTU/CTD counter logic with preset handling 3) Add timer/counter state persistence and reset"
      },
      {
        "id": "89",
        "title": "Implement Program Executor for Ladder AST",
        "description": "Create the Program Executor module that evaluates ladder logic AST nodes including contacts, coils, blocks, timers, counters, comparisons, and math operations.",
        "details": "## File: `src-tauri/src/sim/executor.rs`\n\n1. **Executor Structure:**\n```rust\nuse crate::parser::types::{LadderProgram, LadderNetwork, LadderNode};\n\npub struct ProgramExecutor {\n    memory: Arc<DeviceMemory>,\n    timer_mgr: Arc<TimerManager>,\n    counter_mgr: Arc<CounterManager>,\n}\n\nimpl ProgramExecutor {\n    pub fn new(\n        memory: Arc<DeviceMemory>,\n        timer_mgr: Arc<TimerManager>,\n        counter_mgr: Arc<CounterManager>,\n    ) -> Self;\n    \n    /// Execute full program (all networks)\n    pub fn execute_program(&self, program: &LadderProgram) -> ExecutionResult;\n    \n    /// Execute single network\n    pub fn execute_network(&self, network: &LadderNetwork) -> NetworkResult;\n    \n    /// Evaluate node tree (recursive), returns power rail state\n    fn evaluate_node(&self, node: &LadderNode) -> bool;\n    \n    /// Execute output operations (coil, timer, counter, etc.)\n    fn execute_output(&self, node: &LadderNode, input_condition: bool);\n}\n```\n\n2. **Node Evaluation Logic:**\n```rust\nfn evaluate_node(&self, node: &LadderNode) -> bool {\n    match node.node_type {\n        // Contacts - read input condition\n        NodeType::ContactNo => self.read_device_bool(&node.address),\n        NodeType::ContactNc => !self.read_device_bool(&node.address),\n        NodeType::ContactP => self.memory.detect_rising_edge(&node.address, self.read_device_bool(&node.address)),\n        NodeType::ContactN => self.memory.detect_falling_edge(&node.address, self.read_device_bool(&node.address)),\n        \n        // Blocks\n        NodeType::BlockSeries => node.children.iter().all(|c| self.evaluate_node(c)),\n        NodeType::BlockParallel => node.children.iter().any(|c| self.evaluate_node(c)),\n        \n        // Comparisons\n        NodeType::CompareEq => self.compare(node, |a, b| a == b),\n        NodeType::CompareNe => self.compare(node, |a, b| a != b),\n        NodeType::CompareLt => self.compare(node, |a, b| a < b),\n        NodeType::CompareLe => self.compare(node, |a, b| a <= b),\n        NodeType::CompareGt => self.compare(node, |a, b| a > b),\n        NodeType::CompareGe => self.compare(node, |a, b| a >= b),\n        \n        _ => false, // Outputs don't contribute to power rail\n    }\n}\n```\n\n3. **Output Execution Logic:**\n```rust\nfn execute_output(&self, node: &LadderNode, input: bool) {\n    match node.node_type {\n        NodeType::CoilOut => self.write_device_bool(&node.address, input),\n        NodeType::CoilSet => if input { self.write_device_bool(&node.address, true) },\n        NodeType::CoilRst => if input { self.write_device_bool(&node.address, false) },\n        \n        NodeType::Timer(timer_type) => self.execute_timer(node, input),\n        NodeType::Counter(counter_type) => self.execute_counter(node, input),\n        \n        NodeType::Math(op) => if input { self.execute_math(node) },\n        NodeType::Move => if input { self.execute_move(node) },\n        _ => {}\n    }\n}\n```\n\n4. **Execution Result:**\n```rust\npub struct ExecutionResult {\n    pub network_times: Vec<u64>,  // Execution time per network in microseconds\n    pub total_time: u64,\n    pub success: bool,\n    pub error: Option<String>,\n}\n```",
        "testStrategy": "1. Test NO contact reads true when device is true, false otherwise\n2. Test NC contact reads inverse of device value\n3. Test P contact returns true only on rising edge\n4. Test N contact returns true only on falling edge\n5. Test BlockSeries returns true only when ALL children true\n6. Test BlockParallel returns true when ANY child true\n7. Test CoilOut writes input condition to device\n8. Test CoilSet latches true, doesn't reset on false input\n9. Test CoilRst unlatches (sets false) only when input true\n10. Test comparison operations with various operand values\n11. Test math operations (ADD, SUB, MUL, DIV, MOD)\n12. Test nested block structures (series within parallel)",
        "priority": "high",
        "dependencies": [
          "86",
          "87",
          "88"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Power Flow Evaluation for Series/Parallel Networks",
            "description": "Create the core power flow evaluation logic that recursively traverses the ladder AST tree, handling BlockSeries (AND logic) and BlockParallel (OR logic) nodes to determine the power rail state.",
            "dependencies": [],
            "details": "Implement the evaluate_node method with recursive traversal:\n\n1. Create ProgramExecutor struct with Arc references to DeviceMemory, TimerManager, and CounterManager\n2. Implement execute_program() to iterate through all networks and aggregate results\n3. Implement execute_network() to evaluate network nodes and execute outputs\n4. Implement evaluate_node() for BlockSeries (return true only if ALL children evaluate to true using iter().all())\n5. Implement evaluate_node() for BlockParallel (return true if ANY child evaluates to true using iter().any())\n6. Create ExecutionResult struct with network_times, total_time, success, and error fields\n7. Use std::time::Instant for performance measurement of each network execution\n8. Handle empty networks and edge cases gracefully",
            "status": "pending",
            "testStrategy": "1. Test BlockSeries returns true only when ALL children are true\n2. Test BlockSeries returns false if any child is false\n3. Test BlockParallel returns true if ANY child is true\n4. Test BlockParallel returns false only when ALL children are false\n5. Test nested series within parallel blocks\n6. Test nested parallel within series blocks\n7. Test empty network execution\n8. Test execution timing is recorded accurately",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Execute Contact and Coil Instructions",
            "description": "Implement evaluation logic for contact instructions (NO, NC, P, N) that read device states and execution logic for coil instructions (OUT, SET, RST) that write device states.",
            "dependencies": [
              1
            ],
            "details": "Implement contact and coil node types in evaluate_node and execute_output:\n\n1. ContactNo: Read device bool value directly using memory.read_bit()\n2. ContactNc: Return inverse of device value (!value)\n3. ContactP (Rising edge): Use memory.detect_rising_edge() to detect 0→1 transition\n4. ContactN (Falling edge): Use memory.detect_falling_edge() to detect 1→0 transition\n5. Store previous values in DeviceMemory for edge detection\n6. CoilOut: Write input condition directly to output device\n7. CoilSet (Latch): If input is true, set device to true (don't change if input false)\n8. CoilRst (Reset): If input is true, set device to false (don't change if input false)\n9. Add helper methods read_device_bool() and write_device_bool() for address parsing and memory access\n10. Handle M, P, K, F, T, C device types for contacts and M, K, F for coils",
            "status": "pending",
            "testStrategy": "1. Test NO contact reads true when device is true, false otherwise\n2. Test NC contact reads inverse of device value\n3. Test P contact returns true only on rising edge (false→true transition)\n4. Test P contact returns false on second consecutive true\n5. Test N contact returns true only on falling edge (true→false transition)\n6. Test CoilOut writes input condition to output device\n7. Test CoilSet latches true and doesn't change on false input\n8. Test CoilRst resets to false and doesn't change on false input\n9. Test contacts work with different device types (M, P, K)",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Execute Timer and Counter Instructions",
            "description": "Implement execution logic for timer instructions (TON, TOF, TMON, TMOF) and counter instructions (CTU, CTD, CTUD) by delegating to TimerManager and CounterManager.",
            "dependencies": [
              1
            ],
            "details": "Implement timer and counter execution in execute_output:\n\n1. Timer execution:\n   - Parse timer node to extract timer ID, preset value, and time base\n   - Call timer_mgr.update_timer(id, input_condition, preset) to update timer state\n   - Timer types: TON (On-delay), TOF (Off-delay), TMON (Monostable), TMOF (Monostable Off)\n   - Timer output bit (T contacts) is updated by TimerManager\n   - Timer current value accessible via TD devices\n\n2. Counter execution:\n   - Parse counter node to extract counter ID, preset value, and counter type\n   - Call counter_mgr.update_counter(id, input_condition, reset_condition, preset)\n   - CTU (Count Up): Increment on rising edge, output true when CV >= PV\n   - CTD (Count Down): Decrement on rising edge, output true when CV <= 0\n   - CTUD (Up/Down): Both increment and decrement inputs, dual outputs\n   - Counter current value accessible via CD devices\n\n3. Helper methods:\n   - execute_timer(node, input) to handle timer-specific logic\n   - execute_counter(node, input) to handle counter-specific logic\n   - Extract preset values from node parameters",
            "status": "pending",
            "testStrategy": "1. Test TON timer starts timing when input goes true\n2. Test TON timer output goes true after preset time elapsed\n3. Test TON timer resets immediately when input goes false\n4. Test TOF timer output goes true immediately on input\n5. Test TOF timer stays true for preset time after input goes false\n6. Test CTU increments on rising edge of input\n7. Test CTU output true when count >= preset\n8. Test CTD decrements on rising edge and outputs true at 0\n9. Test CTUD handles both up and down inputs\n10. Test counter reset clears current value",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Execute Math and Compare Functions",
            "description": "Implement comparison operations (EQ, NE, LT, LE, GT, GE) for conditional logic and math operations (ADD, SUB, MUL, DIV, MOD, MOV) for data manipulation.",
            "dependencies": [
              1
            ],
            "details": "Implement compare and math operations:\n\n1. Comparison operations in evaluate_node (return bool for power flow):\n   - CompareEq: s1 == s2\n   - CompareNe: s1 != s2\n   - CompareLt: s1 < s2\n   - CompareLe: s1 <= s2\n   - CompareGt: s1 > s2\n   - CompareGe: s1 >= s2\n   - Helper compare(node, op_fn) to read s1, s2 from node params and apply operator\n   - Support both 16-bit (WORD) and 32-bit (DWORD) comparisons based on device type\n\n2. Math operations in execute_output (only execute when input is true):\n   - ADD: d = s1 + s2 (with overflow handling)\n   - SUB: d = s1 - s2 (with underflow handling)\n   - MUL: d = s1 * s2 (handle 32-bit result for 16-bit operands)\n   - DIV: d = s1 / s2 (handle division by zero, store remainder if applicable)\n   - MOD: d = s1 % s2\n   - MOV: d = s (simple data copy)\n   - INC: d = d + 1\n   - DEC: d = d - 1\n\n3. Helper methods:\n   - read_device_word(addr) to read 16-bit values from D, T, C registers\n   - write_device_word(addr, value) to write 16-bit values\n   - execute_math(node) to dispatch to specific math operation\n   - execute_move(node) for data move operations",
            "status": "pending",
            "testStrategy": "1. Test CompareEq returns true when values are equal\n2. Test CompareLt returns true when s1 < s2\n3. Test CompareGe returns true when s1 >= s2\n4. Test comparison with D registers reads correct values\n5. Test ADD correctly sums two values and stores result\n6. Test SUB handles negative results correctly\n7. Test MUL produces correct 32-bit result\n8. Test DIV handles division by zero gracefully (no panic)\n9. Test MOV copies value from source to destination\n10. Test math operations only execute when input condition is true\n11. Test math with constant values as operands",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Subtasks: 1) Implement power flow evaluation 2) Execute contact/coil instructions 3) Execute timer/counter instructions 4) Execute math/compare functions"
      },
      {
        "id": "90",
        "title": "Implement Scan Cycle Engine",
        "description": "Create the main simulation engine that implements the PLC scan cycle with configurable timing, three-phase execution (input scan, program execution, output scan), and watchdog monitoring.",
        "details": "## File: `src-tauri/src/sim/engine.rs`\n\n1. **Engine Structure:**\n```rust\nuse tokio::sync::mpsc;\nuse tokio_util::sync::CancellationToken;\nuse std::sync::atomic::{AtomicU64, AtomicBool, Ordering};\n\npub struct OneSimEngine {\n    // Components\n    memory: Arc<DeviceMemory>,\n    executor: Arc<ProgramExecutor>,\n    timer_mgr: Arc<TimerManager>,\n    counter_mgr: Arc<CounterManager>,\n    \n    // Configuration\n    config: RwLock<SimulationConfig>,\n    \n    // State\n    state: AtomicU8, // stopped=0, running=1, paused=2\n    program: RwLock<Option<LadderProgram>>,\n    \n    // Statistics\n    scan_count: AtomicU64,\n    last_scan_time_us: AtomicU64,\n    avg_scan_time_us: AtomicU64,\n    max_scan_time_us: AtomicU64,\n    \n    // Control\n    cancel_token: RwLock<Option<CancellationToken>>,\n    app_handle: RwLock<Option<tauri::AppHandle>>,\n}\n```\n\n2. **Scan Cycle Implementation:**\n```rust\nimpl OneSimEngine {\n    pub async fn run_scan_loop(&self) {\n        let cancel = self.cancel_token.read().as_ref().unwrap().clone();\n        let scan_time = Duration::from_millis(self.config.read().scan_time_ms as u64);\n        let mut interval = tokio::time::interval(scan_time);\n        \n        while !cancel.is_cancelled() {\n            interval.tick().await;\n            \n            if self.state.load(Ordering::Relaxed) != 1 { // Not running\n                continue;\n            }\n            \n            let start = Instant::now();\n            \n            // Phase 1: Input Scan (sync from ModServer)\n            self.input_scan().await;\n            \n            // Phase 2: Program Execution\n            if let Some(program) = self.program.read().as_ref() {\n                // Update timer tick\n                let delta = scan_time.as_millis() as u32;\n                self.timer_mgr.tick(delta);\n                \n                // Execute all networks\n                let result = self.executor.execute_program(program);\n                if let Some(err) = result.error {\n                    self.handle_error(&err);\n                }\n            }\n            \n            // Phase 3: Output Scan (sync to ModServer)\n            self.output_scan().await;\n            \n            // Update statistics\n            self.update_statistics(start.elapsed());\n            \n            // Emit scan complete event\n            self.emit_scan_complete();\n        }\n    }\n    \n    fn input_scan(&self) { /* Sync from ModServer */ }\n    fn output_scan(&self) { /* Sync to ModServer */ }\n    fn update_statistics(&self, elapsed: Duration);\n    fn check_watchdog(&self) -> bool;\n}\n```\n\n3. **Control Methods:**\n```rust\nimpl OneSimEngine {\n    pub fn start(&self, program: LadderProgram) -> Result<(), SimError>;\n    pub fn stop(&self);\n    pub fn pause(&self);\n    pub fn resume(&self);\n    pub fn get_status(&self) -> SimulationStatus;\n    pub fn get_scan_info(&self) -> ScanCycleInfo;\n    pub fn set_config(&self, config: SimulationConfig);\n}\n```",
        "testStrategy": "1. Test start() begins scan loop execution\n2. Test stop() halts scan loop completely\n3. Test pause()/resume() correctly suspends and resumes\n4. Test scan timing is approximately the configured interval\n5. Test statistics (scan count, avg/max scan time) update correctly\n6. Test watchdog triggers error on timeout\n7. Test multiple start/stop cycles work correctly\n8. Test empty program executes without error\n9. Measure actual scan time meets performance target (<100μs per network)",
        "priority": "high",
        "dependencies": [
          "86",
          "87",
          "88",
          "89"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Input Scan Phase",
            "description": "Create the input scan phase that synchronizes device memory from ModServer (Modbus memory) at the start of each scan cycle, reading discrete inputs to P relays and external holding register writes to D registers.",
            "dependencies": [],
            "details": "Implement the `input_scan()` method in `src-tauri/src/sim/engine.rs`:\n\n1. **Sync Discrete Inputs to P Relays:**\n   - Read Modbus discrete inputs (addresses 0-8191)\n   - Map to P0000-P8191 in DeviceMemory\n   - Handle bulk read for efficiency\n\n2. **Sync External Holding Register Writes:**\n   - Check external_write_flags from ModServerSync\n   - Copy flagged holding registers to D registers\n   - Clear flags after sync\n\n3. **Integration with ModServerSync:**\n   - Use `ModServerSync::sync_inputs()` if available\n   - Or implement direct memory access pattern\n\n4. **Error Handling:**\n   - Log sync failures without stopping scan\n   - Track input sync timing for diagnostics",
            "status": "pending",
            "testStrategy": "1. Test P relay receives value from discrete input\n2. Test D register receives externally written HR value\n3. Test bulk sync performance meets timing requirements\n4. Test sync failure is logged but doesn't stop scan\n5. Test input scan timing is recorded in diagnostics",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Program Execution Phase",
            "description": "Create the program execution phase that updates timers, executes all ladder networks through ProgramExecutor, and handles execution errors appropriately.",
            "dependencies": [
              1
            ],
            "details": "Implement the program execution logic in the scan loop:\n\n1. **Timer Tick Update:**\n   - Calculate delta time from scan_time configuration\n   - Call `timer_mgr.tick(delta)` to advance all timers\n   - Handle timer overflow/underflow conditions\n\n2. **Counter State Management:**\n   - Ensure counter manager state is consistent\n   - Counter operations handled by instruction execution\n\n3. **Program Execution:**\n   - Check if program is loaded via `self.program.read()`\n   - Call `executor.execute_program(program)` to run all networks\n   - Handle ExecutionResult including power flow states\n\n4. **Error Handling:**\n   - Check for execution errors in result\n   - Call `handle_error()` for runtime errors\n   - Optionally pause/stop on critical errors based on config\n\n5. **Network Iteration:**\n   - Execute networks in order (network 0 to N)\n   - Maintain power flow state between rungs\n   - Reset power flow at network boundaries if needed",
            "status": "pending",
            "testStrategy": "1. Test timer tick is called with correct delta\n2. Test all networks execute in sequence\n3. Test execution error triggers handle_error()\n4. Test empty program (None) is handled gracefully\n5. Test power flow resets between networks\n6. Test execution completes within scan time budget",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Output Scan Phase",
            "description": "Create the output scan phase that synchronizes device memory to ModServer (Modbus memory) at the end of each scan cycle, writing coils from M/K relays and holding registers from D registers.",
            "dependencies": [
              2
            ],
            "details": "Implement the `output_scan()` method in `src-tauri/src/sim/engine.rs`:\n\n1. **Sync M Relays to Coils (offset 0):**\n   - Read M0000-M8191 from DeviceMemory\n   - Write to Modbus coils at addresses 0-8191\n   - Use bulk write for efficiency\n\n2. **Sync K Relays to Coils (offset 8192):**\n   - Read K0000-K8191 from DeviceMemory\n   - Write to Modbus coils at addresses 8192-16383\n\n3. **Sync Timer/Counter Contacts:**\n   - T contacts to coils at offset 10240\n   - C contacts to coils at offset 12288\n\n4. **Sync D Registers to Holding Registers:**\n   - Read D0000-Dxxxx from DeviceMemory\n   - Write to Modbus holding registers at offset 0\n   - Exclude externally written addresses (don't overwrite)\n\n5. **Sync Timer/Counter Data:**\n   - TD registers to HR at appropriate offset\n   - CD registers to HR at appropriate offset\n\n6. **Integration:**\n   - Use `ModServerSync::sync_outputs()` if available\n   - Emit state change events for monitoring clients",
            "status": "pending",
            "testStrategy": "1. Test M relay value appears in Modbus coil at offset 0\n2. Test K relay value appears in Modbus coil at offset 8192\n3. Test T contact syncs to coil at offset 10240\n4. Test D register syncs to holding register at offset 0\n5. Test external HR writes are not overwritten\n6. Test output sync timing is recorded in diagnostics",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Cycle Timing, Diagnostics, and Watchdog Monitoring",
            "description": "Implement scan cycle timing measurement, statistics tracking (scan count, avg/max scan time), watchdog monitoring to detect scan overruns, and control methods (start, stop, pause, resume).",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement timing, diagnostics, and control features:\n\n1. **Statistics Tracking (update_statistics):**\n   - Increment `scan_count` atomically\n   - Update `last_scan_time_us` with elapsed.as_micros()\n   - Calculate running average for `avg_scan_time_us`\n   - Update `max_scan_time_us` if elapsed > current max\n\n2. **Watchdog Monitoring (check_watchdog):**\n   - Compare elapsed time vs configured watchdog_ms\n   - Return true if within limit, false if overrun\n   - On overrun: log warning, optionally trigger error state\n   - Emit watchdog event to frontend\n\n3. **Scan Complete Event (emit_scan_complete):**\n   - Emit Tauri event with scan statistics\n   - Include: scan_count, last_scan_time_us, state\n   - Throttle events if needed (e.g., every N scans)\n\n4. **Control Methods:**\n   - `start(program)`: Load program, set state=running, spawn scan loop\n   - `stop()`: Cancel token, set state=stopped, reset statistics\n   - `pause()`: Set state=paused (scan loop skips execution)\n   - `resume()`: Set state=running\n   - `get_status()`: Return current SimulationStatus\n   - `get_scan_info()`: Return ScanCycleInfo with all statistics\n   - `set_config()`: Update simulation config (scan_time_ms, etc.)\n\n5. **Graceful Shutdown:**\n   - Cancel token triggers clean loop exit\n   - Wait for current scan to complete\n   - Clean up resources",
            "status": "pending",
            "testStrategy": "1. Test scan_count increments each cycle\n2. Test avg_scan_time_us calculates correctly over multiple scans\n3. Test max_scan_time_us tracks the maximum\n4. Test watchdog triggers when scan exceeds limit\n5. Test start() begins scan loop execution\n6. Test stop() halts scan loop completely\n7. Test pause()/resume() correctly suspends and resumes\n8. Test get_status() returns accurate state\n9. Test scan complete event emits to frontend",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Subtasks: 1) Implement input scan phase 2) Implement program execution phase 3) Implement output update phase 4) Add cycle timing and diagnostics"
      },
      {
        "id": "91",
        "title": "Implement ModServer Synchronization",
        "description": "Create bidirectional memory synchronization between OneSim DeviceMemory and ModServer (Modbus memory) with configurable sync modes and proper address offset mapping.",
        "details": "## File: `src-tauri/src/sim/modserver_sync.rs`\n\n1. **Sync Module Structure:**\n```rust\nuse crate::modbus::ModbusMemory;\n\npub struct ModServerSync {\n    sim_memory: Arc<DeviceMemory>,\n    modbus_memory: Arc<ModbusMemory>,\n    sync_mode: RwLock<SyncMode>,\n    external_write_flags: RwLock<HashSet<u16>>, // Track external HR writes\n}\n```\n\n2. **Input Sync (ModServer → DeviceMemory):**\n```rust\nimpl ModServerSync {\n    /// Sync discrete inputs to P relays\n    pub fn sync_inputs(&self) -> Result<(), SimError> {\n        // Read Discrete Inputs from ModServer\n        let di_values = self.modbus_memory.read_discrete_inputs(0, 2048)?;\n        \n        // Write to P (Input Relay) in DeviceMemory\n        for (i, value) in di_values.iter().enumerate() {\n            self.sim_memory.write_bit(BitDevice::P, i as u16, *value)?;\n        }\n        \n        // Sync external Holding Register writes to D registers\n        // Check external_write_flags to distinguish from internal writes\n        let external_writes = self.external_write_flags.write();\n        for &address in external_writes.iter() {\n            let value = self.modbus_memory.read_holding_register(address)?;\n            self.sim_memory.write_word(WordDevice::D, address, value)?;\n        }\n        external_writes.clear();\n        \n        Ok(())\n    }\n}\n```\n\n3. **Output Sync (DeviceMemory → ModServer):**\n```rust\nimpl ModServerSync {\n    pub fn sync_outputs(&self) -> Result<(), SimError> {\n        // M (Auxiliary) → Coils (offset: 0)\n        let m_values = self.sim_memory.read_bits(BitDevice::M, 0, 8192)?;\n        self.modbus_memory.write_coils_internal(0, &m_values)?;\n        \n        // K (Keep) → Coils (offset: 8192)\n        let k_values = self.sim_memory.read_bits(BitDevice::K, 0, 2048)?;\n        self.modbus_memory.write_coils_internal(8192, &k_values)?;\n        \n        // T (Timer Contact) → Coils (offset: 10240)\n        let t_values = self.sim_memory.read_bits(BitDevice::T, 0, 2048)?;\n        self.modbus_memory.write_coils_internal(10240, &t_values)?;\n        \n        // C (Counter Contact) → Coils (offset: 12288)\n        let c_values = self.sim_memory.read_bits(BitDevice::C, 0, 2048)?;\n        self.modbus_memory.write_coils_internal(12288, &c_values)?;\n        \n        // D (Data) → Holding Registers (offset: 0)\n        let d_values = self.sim_memory.read_words(WordDevice::D, 0, 10000)?;\n        self.modbus_memory.write_holding_registers_internal(0, &d_values)?;\n        \n        // TD (Timer Current) → Holding Registers (offset: 28208)\n        let td_values = self.sim_memory.read_words(WordDevice::TD, 0, 2048)?;\n        self.modbus_memory.write_holding_registers_internal(28208, &td_values)?;\n        \n        // CD (Counter Current) → Holding Registers (offset: 30256)\n        let cd_values = self.sim_memory.read_words(WordDevice::CD, 0, 2048)?;\n        self.modbus_memory.write_holding_registers_internal(30256, &cd_values)?;\n        \n        Ok(())\n    }\n}\n```\n\n4. **Sync Modes:**\n- **Immediate:** Real-time sync on every memory change\n- **EndOfScan:** Batch sync at end of each scan cycle\n- **Manual:** Only sync when explicitly triggered\n\n5. **Address Mapping Constants:**\n```rust\nconst M_COIL_OFFSET: u16 = 0;\nconst K_COIL_OFFSET: u16 = 8192;\nconst T_COIL_OFFSET: u16 = 10240;\nconst C_COIL_OFFSET: u16 = 12288;\nconst TD_HR_OFFSET: u16 = 28208;\nconst CD_HR_OFFSET: u16 = 30256;\n```",
        "testStrategy": "1. Test P relay syncs from Discrete Input correctly\n2. Test M relay syncs to Coil at offset 0\n3. Test K relay syncs to Coil at offset 8192\n4. Test T contact syncs to Coil at offset 10240\n5. Test C contact syncs to Coil at offset 12288\n6. Test D register syncs to Holding Register at offset 0\n7. Test TD syncs to Holding Register at offset 28208\n8. Test CD syncs to Holding Register at offset 30256\n9. Test external HR write detection (flag set when external client writes)\n10. Test sync modes: immediate vs endOfScan vs manual\n11. Test round-trip: write to Modbus → sync → read from DeviceMemory",
        "priority": "high",
        "dependencies": [
          "86",
          "87",
          "90"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ModServerSync Core Structure and Address Mapping Constants",
            "description": "Define the ModServerSync struct with Arc references to DeviceMemory and ModbusMemory, implement SyncMode enum (Immediate, EndOfScan, Manual), and define all address mapping constants for device type offsets.",
            "dependencies": [],
            "details": "Create `src-tauri/src/sim/modserver_sync.rs` with:\n1. ModServerSync struct containing Arc<DeviceMemory>, Arc<ModbusMemory>, RwLock<SyncMode>, and RwLock<HashSet<u16>> for external_write_flags\n2. SyncMode enum with variants: Immediate, EndOfScan, Manual\n3. Address mapping constants: M_COIL_OFFSET=0, K_COIL_OFFSET=8192, T_COIL_OFFSET=10240, C_COIL_OFFSET=12288, TD_HR_OFFSET=28208, CD_HR_OFFSET=30256\n4. Constructor new() that initializes all fields with default SyncMode::EndOfScan\n5. Methods to get/set sync mode",
            "status": "pending",
            "testStrategy": "1. Test ModServerSync can be constructed with valid memory references\n2. Test SyncMode defaults to EndOfScan\n3. Test sync mode can be changed via setter\n4. Test all address offset constants are correctly defined",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Input Sync (ModServer to DeviceMemory)",
            "description": "Implement sync_inputs() method that reads Discrete Inputs from ModServer and writes to P (Input Relay) in DeviceMemory, plus syncs external Holding Register writes to D registers using the external_write_flags tracking.",
            "dependencies": [
              1
            ],
            "details": "Implement in modserver_sync.rs:\n1. sync_inputs() method that:\n   - Reads 2048 Discrete Inputs from ModbusMemory starting at address 0\n   - Writes each value to corresponding P relay in DeviceMemory\n   - Checks external_write_flags for addresses written by external Modbus clients\n   - For each flagged address, reads HR from ModbusMemory and writes to D register in DeviceMemory\n   - Clears external_write_flags after processing\n2. Add method to mark_external_write(address: u16) to be called when Modbus client writes to HR\n3. Handle errors appropriately with SimError",
            "status": "pending",
            "testStrategy": "1. Test Discrete Input values sync correctly to P relays\n2. Test external HR write at address N syncs to D[N]\n3. Test external_write_flags is cleared after sync\n4. Test multiple external writes are all processed\n5. Test error handling when memory operations fail",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Output Sync (DeviceMemory to ModServer)",
            "description": "Implement sync_outputs() method that reads bit and word devices from DeviceMemory and writes to corresponding Coils and Holding Registers in ModbusMemory with proper address offsets.",
            "dependencies": [
              1
            ],
            "details": "Implement sync_outputs() method in modserver_sync.rs:\n1. Bit device to Coil mappings:\n   - M (Auxiliary, 8192 bits) → Coils at offset 0\n   - K (Keep, 2048 bits) → Coils at offset 8192\n   - T (Timer Contact, 2048 bits) → Coils at offset 10240\n   - C (Counter Contact, 2048 bits) → Coils at offset 12288\n2. Word device to Holding Register mappings:\n   - D (Data, 10000 words) → Holding Registers at offset 0\n   - TD (Timer Current, 2048 words) → Holding Registers at offset 28208\n   - CD (Counter Current, 2048 words) → Holding Registers at offset 30256\n3. Use write_coils_internal and write_holding_registers_internal to bypass external write tracking\n4. Return SimError on failure",
            "status": "pending",
            "testStrategy": "1. Test M relay syncs to Coil at offset 0\n2. Test K relay syncs to Coil at offset 8192\n3. Test T contact syncs to Coil at offset 10240\n4. Test C contact syncs to Coil at offset 12288\n5. Test D register syncs to HR at offset 0\n6. Test TD syncs to HR at offset 28208\n7. Test CD syncs to HR at offset 30256",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Sync Mode Management and Execution Logic",
            "description": "Implement the three sync modes (Immediate, EndOfScan, Manual) with proper triggering logic and a unified sync() method that respects the current mode, including hooks for scan cycle events.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement sync mode execution in modserver_sync.rs:\n1. full_sync() method that calls both sync_inputs() and sync_outputs()\n2. on_memory_change() hook for Immediate mode - triggers sync on any memory write\n3. on_scan_end() hook for EndOfScan mode - triggers sync at end of scan cycle\n4. manual_sync() public method for Manual mode - explicitly triggered by user/command\n5. should_sync_on_change() helper that checks if mode is Immediate\n6. should_sync_on_scan_end() helper that checks if mode is EndOfScan\n7. Integration points with SimEngine for scan cycle events\n8. Thread-safe access to sync operations using appropriate locking",
            "status": "pending",
            "testStrategy": "1. Test Immediate mode syncs on every memory change event\n2. Test EndOfScan mode only syncs when on_scan_end() is called\n3. Test Manual mode does not auto-sync, only on manual_sync() call\n4. Test mode changes take effect immediately\n5. Test concurrent access is handled safely",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Tauri Commands for Simulation Control and Memory Access",
            "description": "Create Tauri commands following scenario.rs patterns for simulation control (start, stop, step, reset) and memory access (read/write devices), integrating with ModServerSync for proper synchronization.",
            "dependencies": [
              4
            ],
            "details": "Create Tauri commands in appropriate module (sim_commands.rs or extend existing):\n1. Simulation control commands:\n   - sim_start(scenario_id) - Start simulation with sync\n   - sim_stop() - Stop simulation\n   - sim_step() - Execute single scan cycle with sync\n   - sim_reset() - Reset simulation state and sync\n2. Memory access commands:\n   - sim_read_device(device_type, address) - Read single device value\n   - sim_write_device(device_type, address, value) - Write device value (triggers sync if Immediate mode)\n   - sim_read_devices_batch(requests) - Batch read multiple devices\n3. Sync control commands:\n   - sim_set_sync_mode(mode) - Change sync mode\n   - sim_trigger_sync() - Manual sync trigger\n4. Follow async patterns from scenario.rs with proper state management\n5. Register commands in Tauri app builder",
            "status": "pending",
            "testStrategy": "1. Test sim_start initializes simulation and performs initial sync\n2. Test sim_stop stops simulation cleanly\n3. Test sim_step executes one scan and syncs\n4. Test sim_reset clears state and syncs\n5. Test memory read/write commands work correctly\n6. Test sync mode change takes effect\n7. Test manual sync trigger works",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Create Tauri commands for simulation control (start, stop, step, reset) and memory access following scenario.rs patterns"
      },
      {
        "id": "92",
        "title": "Implement OneCanvas Integration",
        "description": "Create synchronization between OneSim and OneCanvas circuit simulation, mapping plc_out block states to Coils and plc_in block states to Discrete Inputs.",
        "details": "## File: `src-tauri/src/sim/canvas_sync.rs`\n\n1. **Canvas Sync Module:**\n```rust\nuse tauri::Emitter;\n\npub struct CanvasSync {\n    sim_memory: Arc<DeviceMemory>,\n    app_handle: RwLock<Option<tauri::AppHandle>>,\n    plc_block_mappings: RwLock<Vec<PlcBlockMapping>>,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct PlcBlockMapping {\n    block_id: String,\n    block_type: PlcBlockType,\n    address: DeviceAddress,\n    normally_open: bool,\n    inverted: bool,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub enum PlcBlockType {\n    PlcOut,  // Coil → Circuit switch\n    PlcIn,   // Circuit state → Discrete Input\n}\n```\n\n2. **PlcOut Handling (Coil → OneCanvas):**\n```rust\nimpl CanvasSync {\n    /// Called after each scan cycle to update plc_out blocks\n    pub fn update_plc_outputs(&self) {\n        let mappings = self.plc_block_mappings.read();\n        let mut updates = Vec::new();\n        \n        for mapping in mappings.iter() {\n            if mapping.block_type == PlcBlockType::PlcOut {\n                // Read coil state from DeviceMemory\n                let mut state = self.sim_memory.read_coil(&mapping.address)?;\n                \n                // Apply normally_open and inverted logic\n                if !mapping.normally_open {\n                    state = !state;\n                }\n                if mapping.inverted {\n                    state = !state;\n                }\n                \n                updates.push(PlcOutputUpdate {\n                    block_id: mapping.block_id.clone(),\n                    state,\n                });\n            }\n        }\n        \n        // Emit event to frontend\n        if let Some(handle) = self.app_handle.read().as_ref() {\n            let _ = handle.emit(\"sim:plc-outputs\", updates);\n        }\n    }\n}\n```\n\n3. **PlcIn Handling (OneCanvas → Discrete Input):**\n```rust\nimpl CanvasSync {\n    /// Called from frontend event handler when circuit state changes\n    pub fn handle_plc_input_change(&self, block_id: &str, circuit_state: bool) {\n        let mappings = self.plc_block_mappings.read();\n        \n        if let Some(mapping) = mappings.iter().find(|m| m.block_id == block_id) {\n            if mapping.block_type == PlcBlockType::PlcIn {\n                let mut state = circuit_state;\n                \n                // Apply inverted logic\n                if mapping.inverted {\n                    state = !state;\n                }\n                \n                // Write to Discrete Input in DeviceMemory\n                // Note: This writes to P relay which gets synced from DI\n                self.write_discrete_input(&mapping.address, state);\n            }\n        }\n    }\n    \n    /// Register PLC block mapping when canvas loads\n    pub fn register_mapping(&self, mapping: PlcBlockMapping) {\n        self.plc_block_mappings.write().push(mapping);\n    }\n    \n    /// Clear all mappings (when circuit unloaded)\n    pub fn clear_mappings(&self) {\n        self.plc_block_mappings.write().clear();\n    }\n}\n```\n\n4. **Frontend Integration (TypeScript):**\n```typescript\n// In useSimulation.ts hook\nconst handlePlcOutputs = useCallback((updates: PlcOutputUpdate[]) => {\n  updates.forEach(update => {\n    // Update plc_out block's switch state in canvas store\n    canvasStore.updateBlockState(update.blockId, { switchClosed: update.state });\n  });\n}, []);\n\n// Subscribe to plc-outputs event\nuseEffect(() => {\n  const unlisten = listen('sim:plc-outputs', handlePlcOutputs);\n  return () => { unlisten.then(fn => fn()); };\n}, []);\n```",
        "testStrategy": "1. Test plc_out block mapping correctly reads Coil state\n2. Test normally_open=false inverts the contact behavior\n3. Test inverted=true inverts the output\n4. Test plc_in block writes circuit state to Discrete Input\n5. Test plc_in inverted logic\n6. Test register_mapping adds mapping correctly\n7. Test clear_mappings removes all mappings\n8. Test event emission to frontend contains correct data\n9. Integration test: Set M0001=true → plc_out block with address M0001 reports state=true",
        "priority": "medium",
        "dependencies": [
          "86",
          "87",
          "90",
          "91"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CanvasSync Module Structure and PlcBlockMapping Types",
            "description": "Implement the core CanvasSync struct with PlcBlockMapping, PlcBlockType enum, and basic initialization in src-tauri/src/sim/canvas_sync.rs",
            "dependencies": [],
            "details": "Create the canvas_sync.rs module with:\n1. CanvasSync struct holding Arc<DeviceMemory>, RwLock<Option<tauri::AppHandle>>, and RwLock<Vec<PlcBlockMapping>>\n2. PlcBlockMapping struct with block_id, block_type, address (DeviceAddress), normally_open, and inverted fields\n3. PlcBlockType enum with PlcOut and PlcIn variants\n4. Constructor new() method that initializes empty mappings\n5. set_app_handle() method to set the Tauri app handle\n6. register_mapping() and clear_mappings() methods for managing PLC block mappings\n7. Add proper Serialize/Deserialize derives for frontend communication",
            "status": "pending",
            "testStrategy": "Test CanvasSync initialization with DeviceMemory. Test register_mapping adds mapping to vector. Test clear_mappings empties the vector. Test set_app_handle stores handle correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement PlcOut Synchronization (Coil → OneCanvas)",
            "description": "Create update_plc_outputs() method that reads Coil states from DeviceMemory and emits updates to frontend via Tauri events",
            "dependencies": [
              1
            ],
            "details": "Implement PlcOut handling in CanvasSync:\n1. Create PlcOutputUpdate struct with block_id and state fields for event payload\n2. Implement update_plc_outputs() method that:\n   - Iterates through plc_block_mappings filtering for PlcBlockType::PlcOut\n   - Reads coil state from sim_memory using the mapping's address\n   - Applies normally_open logic (invert if false)\n   - Applies inverted logic (invert if true)\n   - Collects updates into Vec<PlcOutputUpdate>\n3. Emit 'sim:plc-outputs' event via app_handle with collected updates\n4. Add error handling for memory read failures\n5. Consider batching updates for efficiency during scan cycles",
            "status": "pending",
            "testStrategy": "Test coil state is correctly read from DeviceMemory. Test normally_open=false inverts contact behavior. Test inverted=true inverts output. Test event emission with correct payload. Test empty updates when no PlcOut mappings exist.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement PlcIn Synchronization (OneCanvas → Discrete Input)",
            "description": "Create handle_plc_input_change() method that receives circuit state changes from frontend and writes to Discrete Input in DeviceMemory",
            "dependencies": [
              1
            ],
            "details": "Implement PlcIn handling in CanvasSync:\n1. Implement handle_plc_input_change(block_id: &str, circuit_state: bool) method that:\n   - Looks up mapping by block_id in plc_block_mappings\n   - Verifies mapping is PlcBlockType::PlcIn\n   - Applies inverted logic if mapping.inverted is true\n   - Writes final state to Discrete Input (P relay) in DeviceMemory\n2. Implement write_discrete_input() helper method for DeviceMemory write operations\n3. Add Tauri command wrapper for frontend to call handle_plc_input_change\n4. Handle cases where block_id is not found gracefully\n5. Ensure thread-safe access to mappings and memory",
            "status": "pending",
            "testStrategy": "Test plc_in block writes circuit state to Discrete Input. Test inverted logic correctly inverts state. Test unknown block_id is handled gracefully. Test Tauri command invocation works from frontend.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Memory Watch System with Change Detection",
            "description": "Create subscription-based memory watch system that efficiently detects changes and batches updates for frontend notification",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement efficient change detection system:\n1. Add previous_states: RwLock<HashMap<DeviceAddress, bool>> to CanvasSync for tracking last known states\n2. Create WatchSubscription struct for managing watched addresses\n3. Implement detect_changes() method that:\n   - Compares current memory state with previous_states\n   - Returns only changed addresses\n   - Updates previous_states after detection\n4. Modify update_plc_outputs() to use change detection for efficiency\n5. Implement subscription management methods:\n   - subscribe_address(address: DeviceAddress)\n   - unsubscribe_address(address: DeviceAddress)\n   - get_subscribed_addresses()\n6. Add batching logic to collect multiple changes per scan cycle\n7. Consider debouncing for rapid state changes",
            "status": "pending",
            "testStrategy": "Test change detection identifies modified addresses only. Test previous state is correctly updated after detection. Test subscription add/remove works. Test batched updates combine multiple changes. Test no event emitted when no changes detected.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Frontend Integration and Event Handlers",
            "description": "Create TypeScript hooks and event handlers for receiving plc-outputs events and sending circuit state changes to backend",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement frontend integration in TypeScript:\n1. Create useCanvasSync.ts hook with:\n   - handlePlcOutputs callback that processes PlcOutputUpdate[] events\n   - Updates canvas store block states (switchClosed) for each update\n   - useEffect for subscribing to 'sim:plc-outputs' event with cleanup\n2. Create sendCircuitStateChange(blockId: string, state: boolean) function using invoke\n3. Add PlcOutputUpdate TypeScript interface matching Rust struct\n4. Integrate with existing canvas store (canvasStore.updateBlockState)\n5. Add loading/error states for sync operations\n6. Implement reconnection logic if event listener disconnects\n7. Export hook from simulation hooks module for use in OneCanvas components",
            "status": "pending",
            "testStrategy": "Test event listener subscribes on mount and unsubscribes on unmount. Test handlePlcOutputs updates correct block states in canvas store. Test sendCircuitStateChange invokes Tauri command with correct parameters. Test multiple rapid updates are handled without race conditions.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement memory watch system with subscription management, change detection, and efficient frontend updates"
      },
      {
        "id": "93",
        "title": "Implement Debugger Module",
        "description": "Create the debugger module with breakpoint support (network, device, condition, scanCount), watch variables, and step execution capabilities.",
        "details": "## File: `src-tauri/src/sim/debugger.rs`\n\n1. **Debugger Structure:**\n```rust\nuse std::collections::HashMap;\nuse parking_lot::RwLock;\n\npub struct SimDebugger {\n    breakpoints: RwLock<Vec<Breakpoint>>,\n    watches: RwLock<HashMap<String, WatchVariable>>,\n    step_mode: AtomicBool,\n    step_type: RwLock<StepType>, // Network, Scan\n    paused_at: RwLock<Option<BreakpointHit>>,\n}\n\n#[derive(Clone, Serialize)]\npub struct Breakpoint {\n    pub id: String,\n    pub breakpoint_type: BreakpointType,\n    pub enabled: bool,\n    pub network_id: Option<u32>,\n    pub device_address: Option<String>,\n    pub condition: Option<String>,\n    pub scan_count: Option<u64>,\n}\n\n#[derive(Clone, Serialize)]\npub struct WatchVariable {\n    pub address: String,\n    pub current_value: WatchValue,\n    pub previous_value: WatchValue,\n    pub change_count: u32,\n    pub last_change_time: u64,\n    pub history: Vec<ValueHistoryEntry>,\n}\n\n#[derive(Clone, Serialize)]\npub enum WatchValue {\n    Bit(bool),\n    Word(u16),\n}\n```\n\n2. **Breakpoint Checking:**\n```rust\nimpl SimDebugger {\n    /// Check if any breakpoint should trigger before network execution\n    pub fn check_before_network(&self, network_id: u32, scan_count: u64, \n                                 memory: &DeviceMemory) -> Option<BreakpointHit> {\n        let breakpoints = self.breakpoints.read();\n        \n        for bp in breakpoints.iter().filter(|b| b.enabled) {\n            match bp.breakpoint_type {\n                BreakpointType::Network => {\n                    if bp.network_id == Some(network_id) {\n                        return Some(BreakpointHit::Network(bp.id.clone(), network_id));\n                    }\n                }\n                BreakpointType::ScanCount => {\n                    if bp.scan_count == Some(scan_count) {\n                        return Some(BreakpointHit::ScanCount(bp.id.clone(), scan_count));\n                    }\n                }\n                BreakpointType::Condition => {\n                    if let Some(ref cond) = bp.condition {\n                        if self.evaluate_condition(cond, memory) {\n                            return Some(BreakpointHit::Condition(bp.id.clone(), cond.clone()));\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n        \n        None\n    }\n    \n    /// Check device breakpoints after memory write\n    pub fn check_device_change(&self, address: &str, old: WatchValue, new: WatchValue) \n                               -> Option<BreakpointHit> {\n        // Check device breakpoints\n        // Also update watch variables\n    }\n    \n    /// Evaluate condition string (e.g., \"D0001 > 100\")\n    fn evaluate_condition(&self, condition: &str, memory: &DeviceMemory) -> bool {\n        // Parse and evaluate simple conditions\n    }\n}\n```\n\n3. **Watch Variables:**\n```rust\nimpl SimDebugger {\n    pub fn add_watch(&self, address: &str) {\n        let mut watches = self.watches.write();\n        watches.insert(address.to_string(), WatchVariable::new(address));\n    }\n    \n    pub fn remove_watch(&self, address: &str) {\n        self.watches.write().remove(address);\n    }\n    \n    pub fn update_watch(&self, address: &str, memory: &DeviceMemory) {\n        if let Some(watch) = self.watches.write().get_mut(address) {\n            let new_value = self.read_value(address, memory);\n            if new_value != watch.current_value {\n                watch.previous_value = watch.current_value.clone();\n                watch.current_value = new_value;\n                watch.change_count += 1;\n                watch.last_change_time = timestamp_now();\n                watch.history.push(ValueHistoryEntry { value: new_value, time: timestamp_now() });\n            }\n        }\n    }\n    \n    pub fn get_watches(&self) -> Vec<WatchVariable> {\n        self.watches.read().values().cloned().collect()\n    }\n}\n```\n\n4. **Step Execution:**\n```rust\nimpl SimDebugger {\n    pub fn enable_step_mode(&self, step_type: StepType) {\n        self.step_mode.store(true, Ordering::Relaxed);\n        *self.step_type.write() = step_type;\n    }\n    \n    pub fn step(&self) -> StepResult {\n        // Signal engine to execute one network or one scan\n    }\n    \n    pub fn continue_execution(&self) {\n        self.step_mode.store(false, Ordering::Relaxed);\n    }\n}\n```",
        "testStrategy": "1. Test network breakpoint triggers at specified network ID\n2. Test device breakpoint triggers when device value changes\n3. Test condition breakpoint evaluates simple expressions (D0001 > 100)\n4. Test scanCount breakpoint triggers at Nth scan\n5. Test watch variable tracks current, previous, change count\n6. Test watch history records value changes with timestamps\n7. Test step_network executes exactly one network then pauses\n8. Test step_scan executes full scan cycle then pauses\n9. Test continue_execution resumes normal execution\n10. Test disabled breakpoints don't trigger",
        "priority": "medium",
        "dependencies": [
          "86",
          "87",
          "90"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Core Debugger Structure and Types in Rust",
            "description": "Create the foundational Rust types and structures for the debugger module including SimDebugger, Breakpoint, BreakpointType, WatchVariable, WatchValue, StepType, and BreakpointHit enums/structs.",
            "dependencies": [],
            "details": "Create `src-tauri/src/sim/debugger.rs` with all type definitions:\n\n1. Define `BreakpointType` enum with variants: Network, Device, Condition, ScanCount\n2. Define `Breakpoint` struct with fields: id (String), breakpoint_type, enabled (bool), network_id (Option<u32>), device_address (Option<String>), condition (Option<String>), scan_count (Option<u64>)\n3. Define `WatchValue` enum with variants: Bit(bool), Word(u16)\n4. Define `ValueHistoryEntry` struct with value and timestamp\n5. Define `WatchVariable` struct with address, current_value, previous_value, change_count, last_change_time, history\n6. Define `StepType` enum with variants: Network, Scan\n7. Define `BreakpointHit` enum to represent different breakpoint trigger types\n8. Define `SimDebugger` struct with RwLock-wrapped fields: breakpoints, watches, step_mode (AtomicBool), step_type, paused_at\n9. Implement Default/new() constructor for SimDebugger\n10. Add proper derive macros (Clone, Serialize, Debug) as needed for Tauri interop",
            "status": "pending",
            "testStrategy": "1. Unit test that SimDebugger::new() creates empty breakpoints and watches collections\n2. Test Breakpoint serialization to JSON for Tauri frontend\n3. Test WatchVariable can be created and serialized\n4. Verify thread-safe access patterns compile correctly",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Breakpoint Management and Checking System",
            "description": "Implement CRUD operations for breakpoints and the breakpoint checking logic that determines when execution should pause based on network, device, condition, or scan count breakpoints.",
            "dependencies": [
              1
            ],
            "details": "Extend SimDebugger with breakpoint management methods:\n\n1. `add_breakpoint(&self, bp: Breakpoint)` - Add new breakpoint to collection\n2. `remove_breakpoint(&self, id: &str)` - Remove breakpoint by ID\n3. `enable_breakpoint(&self, id: &str, enabled: bool)` - Toggle breakpoint state\n4. `get_breakpoints(&self) -> Vec<Breakpoint>` - Return all breakpoints\n\n5. `check_before_network(&self, network_id: u32, scan_count: u64, memory: &DeviceMemory) -> Option<BreakpointHit>`:\n   - Iterate enabled breakpoints\n   - Check Network type against network_id\n   - Check ScanCount type against scan_count\n   - Check Condition type by evaluating expression\n\n6. `check_device_change(&self, address: &str, old: WatchValue, new: WatchValue) -> Option<BreakpointHit>`:\n   - Check Device breakpoints when value changes\n   - Return BreakpointHit if device matches\n\n7. `evaluate_condition(&self, condition: &str, memory: &DeviceMemory) -> bool`:\n   - Parse simple expressions like 'D0001 > 100', 'M0000 == 1'\n   - Support operators: ==, !=, >, <, >=, <=\n   - Read device values from memory for comparison",
            "status": "pending",
            "testStrategy": "1. Test add/remove/enable breakpoint operations\n2. Test check_before_network triggers on matching network_id\n3. Test check_before_network triggers on matching scan_count\n4. Test condition breakpoint evaluates 'D0001 > 100' correctly when D0001=150\n5. Test condition breakpoint does NOT trigger when D0001=50\n6. Test check_device_change triggers on Device breakpoint when value changes\n7. Test disabled breakpoints are skipped",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Watch Variable Tracking System",
            "description": "Create the watch variable system that tracks device values, maintains history of changes, and provides real-time monitoring of selected memory addresses during simulation.",
            "dependencies": [
              1
            ],
            "details": "Implement watch variable methods in SimDebugger:\n\n1. `add_watch(&self, address: &str)` - Add address to watches HashMap with initialized WatchVariable\n2. `remove_watch(&self, address: &str)` - Remove watch from collection\n3. `get_watches(&self) -> Vec<WatchVariable>` - Return all watch variables with current state\n\n4. `update_watch(&self, address: &str, memory: &DeviceMemory)`:\n   - Read current value from memory using read_value helper\n   - Compare with stored current_value\n   - If changed: update previous_value, current_value, increment change_count, update last_change_time, append to history\n\n5. `read_value(&self, address: &str, memory: &DeviceMemory) -> WatchValue`:\n   - Parse device address (P, M, K, D, etc.)\n   - Read appropriate value type (bit or word) from DeviceMemory\n   - Return WatchValue::Bit or WatchValue::Word\n\n6. `update_all_watches(&self, memory: &DeviceMemory)` - Batch update all watches after each scan\n\n7. Consider history size limit (e.g., last 100 entries) to prevent unbounded growth",
            "status": "pending",
            "testStrategy": "1. Test add_watch creates new WatchVariable with initial values\n2. Test remove_watch removes from collection\n3. Test update_watch detects value change and updates history\n4. Test change_count increments only on actual changes\n5. Test previous_value holds correct value after update\n6. Test history contains chronological entries\n7. Test get_watches returns all current watches",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Step Execution Control System",
            "description": "Create step execution functionality allowing network-level or scan-level stepping through simulation with pause/resume control and proper integration with the simulation engine.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement step execution control in SimDebugger:\n\n1. `enable_step_mode(&self, step_type: StepType)`:\n   - Set step_mode AtomicBool to true\n   - Store step_type (Network or Scan) in RwLock\n\n2. `disable_step_mode(&self)`:\n   - Set step_mode to false\n\n3. `is_step_mode(&self) -> bool` - Check if stepping is enabled\n\n4. `get_step_type(&self) -> StepType` - Return current step type\n\n5. `step(&self) -> StepResult`:\n   - Signal simulation engine to execute one unit (network or scan based on step_type)\n   - Return result indicating what was executed\n\n6. `continue_execution(&self)`:\n   - Disable step mode\n   - Clear paused_at state\n   - Resume normal execution\n\n7. `pause(&self, hit: BreakpointHit)`:\n   - Store BreakpointHit in paused_at\n   - Set step_mode to true to halt execution\n\n8. `get_pause_state(&self) -> Option<BreakpointHit>` - Return current pause reason\n\n9. Implement integration points for SimEngine to check step_mode before each network/scan",
            "status": "pending",
            "testStrategy": "1. Test enable_step_mode sets correct state\n2. Test is_step_mode returns correct boolean\n3. Test continue_execution clears step mode and pause state\n4. Test pause stores BreakpointHit correctly\n5. Test get_pause_state returns stored hit\n6. Test StepType::Network vs StepType::Scan distinction\n7. Integration test with SimEngine stepping through networks",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create React Debugger Control Panel Component",
            "description": "Build the React control panel UI with run/stop/step controls, cycle timing display, simulation status indicators, and integration with Tauri commands for debugger operations.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create `src/components/OneSim/DebuggerPanel.tsx`:\n\n1. **Control Buttons:**\n   - Run button (play icon) - invoke('sim_run')\n   - Stop button (stop icon) - invoke('sim_stop')\n   - Step Network button - invoke('sim_step', { stepType: 'network' })\n   - Step Scan button - invoke('sim_step', { stepType: 'scan' })\n   - Use disabled states based on simulation status\n\n2. **Status Indicators:**\n   - Running/Stopped/Paused status with colored indicator (green/red/yellow)\n   - Current network ID being executed\n   - Scan count display\n   - Breakpoint hit indicator when paused\n\n3. **Timing Display:**\n   - Cycle time (current scan duration in ms)\n   - Average cycle time\n   - Min/Max cycle times\n   - Use Tauri event listener for real-time updates\n\n4. **Tauri Integration:**\n   - Define invoke commands: sim_run, sim_stop, sim_step, get_sim_status\n   - Listen to 'sim-status-update' events\n   - Listen to 'breakpoint-hit' events\n\n5. **Styling:**\n   - Follow existing OneSim component styling patterns\n   - Responsive layout for toolbar placement\n   - Keyboard shortcuts (F5=Run, F6=Stop, F10=Step Network, F11=Step Scan)",
            "status": "pending",
            "testStrategy": "1. Test Run button calls sim_run command\n2. Test Stop button calls sim_stop command\n3. Test Step buttons call sim_step with correct stepType\n4. Test status indicator shows correct color for each state\n5. Test timing display updates on sim-status-update event\n6. Test breakpoint hit shows pause reason\n7. Test keyboard shortcuts trigger correct actions\n8. Test buttons are disabled appropriately based on state",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Create React control panel with run/stop/step controls, cycle timing display, and simulation status indicators"
      },
      {
        "id": "94",
        "title": "Implement Tauri Commands for Simulation Control",
        "description": "Create Tauri command handlers for simulation control (start, stop, pause, resume), memory access, and debugging operations.",
        "details": "## File: `src-tauri/src/sim/commands.rs`\n\n1. **Simulation State Management:**\n```rust\nuse std::sync::Arc;\nuse parking_lot::Mutex;\n\npub struct SimState {\n    engine: Arc<Mutex<Option<OneSimEngine>>>,\n    debugger: Arc<SimDebugger>,\n}\n\nimpl Default for SimState {\n    fn default() -> Self {\n        Self {\n            engine: Arc::new(Mutex::new(None)),\n            debugger: Arc::new(SimDebugger::new()),\n        }\n    }\n}\n```\n\n2. **Simulation Control Commands:**\n```rust\n#[tauri::command]\npub async fn sim_start(\n    state: tauri::State<'_, SimState>,\n    modbus: tauri::State<'_, ModbusState>,\n    program_id: String,\n    config: SimulationConfig,\n) -> Result<(), String> {\n    // Load program from parser\n    // Create engine with ModServer memory reference\n    // Start scan loop\n}\n\n#[tauri::command]\npub fn sim_stop(state: tauri::State<'_, SimState>) -> Result<(), String>;\n\n#[tauri::command]\npub fn sim_pause(state: tauri::State<'_, SimState>) -> Result<(), String>;\n\n#[tauri::command]\npub fn sim_resume(state: tauri::State<'_, SimState>) -> Result<(), String>;\n\n#[tauri::command]\npub fn sim_get_status(state: tauri::State<'_, SimState>) -> Result<SimulationStatus, String>;\n\n#[tauri::command]\npub fn sim_get_scan_info(state: tauri::State<'_, SimState>) -> Result<ScanCycleInfo, String>;\n```\n\n3. **Memory Access Commands:**\n```rust\n#[tauri::command]\npub fn sim_read_device(\n    state: tauri::State<'_, SimState>,\n    address: String,\n) -> Result<DeviceValue, String>;\n\n#[tauri::command]\npub fn sim_write_device(\n    state: tauri::State<'_, SimState>,\n    address: String,\n    value: DeviceValue,\n) -> Result<(), String>;\n\n#[tauri::command]\npub fn sim_read_memory_range(\n    state: tauri::State<'_, SimState>,\n    device_type: String,\n    start: u16,\n    count: u16,\n) -> Result<Vec<DeviceValue>, String>;\n\n#[tauri::command]\npub fn sim_get_memory_snapshot(\n    state: tauri::State<'_, SimState>,\n) -> Result<MemorySnapshot, String>;\n```\n\n4. **Debugging Commands:**\n```rust\n#[tauri::command]\npub fn sim_add_breakpoint(\n    state: tauri::State<'_, SimState>,\n    breakpoint: Breakpoint,\n) -> Result<String, String>;\n\n#[tauri::command]\npub fn sim_remove_breakpoint(\n    state: tauri::State<'_, SimState>,\n    id: String,\n) -> Result<(), String>;\n\n#[tauri::command]\npub fn sim_add_watch(\n    state: tauri::State<'_, SimState>,\n    address: String,\n) -> Result<(), String>;\n\n#[tauri::command]\npub fn sim_get_watches(\n    state: tauri::State<'_, SimState>,\n) -> Result<Vec<WatchVariable>, String>;\n\n#[tauri::command]\npub fn sim_step_network(\n    state: tauri::State<'_, SimState>,\n) -> Result<StepResult, String>;\n\n#[tauri::command]\npub fn sim_step_scan(\n    state: tauri::State<'_, SimState>,\n) -> Result<StepResult, String>;\n```\n\n5. **Event Emission:**\n```rust\n// Events to emit from engine:\n// - sim:scan-complete { scanCount, scanTime, timestamp }\n// - sim:device-change { address, oldValue, newValue }\n// - sim:breakpoint-hit { breakpointId, type, details }\n```\n\n6. **Register Commands in lib.rs:**\n```rust\n.manage(SimState::default())\n.invoke_handler(tauri::generate_handler![\n    sim_start, sim_stop, sim_pause, sim_resume,\n    sim_get_status, sim_get_scan_info,\n    sim_read_device, sim_write_device, sim_read_memory_range, sim_get_memory_snapshot,\n    sim_add_breakpoint, sim_remove_breakpoint,\n    sim_add_watch, sim_get_watches,\n    sim_step_network, sim_step_scan,\n])\n```",
        "testStrategy": "1. Test sim_start creates engine and begins scan loop\n2. Test sim_stop terminates scan loop\n3. Test sim_pause/resume correctly toggles execution\n4. Test sim_get_status returns current state\n5. Test sim_read_device reads correct values for bit and word devices\n6. Test sim_write_device updates memory correctly\n7. Test sim_read_memory_range returns contiguous values\n8. Test breakpoint commands add/remove breakpoints\n9. Test watch commands add watches and return current values\n10. Test step commands work in debug mode\n11. Integration test: Start simulation, write device, verify change event emitted",
        "priority": "high",
        "dependencies": [
          "86",
          "87",
          "88",
          "89",
          "90",
          "91",
          "93"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement SimState Structure and Initialization",
            "description": "Create the SimState structure that manages the simulation engine instance and debugger, implementing Default trait and proper thread-safe state management using Arc and parking_lot::Mutex.",
            "dependencies": [],
            "details": "Create `src-tauri/src/sim/commands.rs` file with:\n1. SimState struct containing `engine: Arc<Mutex<Option<OneSimEngine>>>` and `debugger: Arc<SimDebugger>`\n2. Implement Default trait for SimState with proper initialization\n3. Add necessary imports from std::sync::Arc, parking_lot::Mutex\n4. Import OneSimEngine from engine module and SimDebugger from debugger module\n5. Create module declaration in src-tauri/src/sim/mod.rs if not exists",
            "status": "pending",
            "testStrategy": "Test SimState::default() creates valid state with None engine and initialized debugger. Test thread-safe access to engine mutex from multiple threads.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Simulation Lifecycle Control Commands",
            "description": "Create Tauri commands for simulation lifecycle management: sim_start, sim_stop, sim_pause, sim_resume, sim_get_status, and sim_get_scan_info.",
            "dependencies": [
              1
            ],
            "details": "Implement in `src-tauri/src/sim/commands.rs`:\n1. `sim_start` - async command that loads program from parser, creates engine with ModServer memory reference, starts scan loop\n2. `sim_stop` - stops the scan loop and clears the engine\n3. `sim_pause` - pauses execution without destroying state\n4. `sim_resume` - resumes paused execution\n5. `sim_get_status` - returns current SimulationStatus enum\n6. `sim_get_scan_info` - returns ScanCycleInfo with scan count, time, etc.\nAll commands should access SimState and ModbusState via tauri::State and return Result<T, String>",
            "status": "pending",
            "testStrategy": "Test sim_start creates engine and begins scan loop. Test sim_stop terminates scan loop. Test sim_pause/resume correctly toggles execution. Test sim_get_status returns correct state. Test sim_get_scan_info returns valid timing data.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Memory Access Commands",
            "description": "Create Tauri commands for device memory access: sim_read_device, sim_write_device, sim_read_memory_range, and sim_get_memory_snapshot.",
            "dependencies": [
              1
            ],
            "details": "Implement memory access commands in `src-tauri/src/sim/commands.rs`:\n1. `sim_read_device(address: String)` - Parse address string, read DeviceValue from engine memory\n2. `sim_write_device(address: String, value: DeviceValue)` - Write value to specified device address\n3. `sim_read_memory_range(device_type: String, start: u16, count: u16)` - Read contiguous range of device memory, return Vec<DeviceValue>\n4. `sim_get_memory_snapshot()` - Return complete MemorySnapshot containing all device regions (X/Y/D/M/T/C)\nHandle address parsing, type conversion, and proper error messages for invalid addresses or engine not running",
            "status": "pending",
            "testStrategy": "Test sim_read_device reads correct values for bit and word devices. Test sim_write_device updates memory correctly. Test sim_read_memory_range returns correct slice. Test sim_get_memory_snapshot includes all regions.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Debugging Commands",
            "description": "Create Tauri commands for debugging operations: breakpoint management (add/remove), watch variables (add/get), and step execution (step_network/step_scan).",
            "dependencies": [
              1
            ],
            "details": "Implement debugging commands in `src-tauri/src/sim/commands.rs`:\n1. `sim_add_breakpoint(breakpoint: Breakpoint)` - Add breakpoint (network, device, condition, scanCount types), return breakpoint ID\n2. `sim_remove_breakpoint(id: String)` - Remove breakpoint by ID\n3. `sim_add_watch(address: String)` - Add device address to watch list\n4. `sim_get_watches()` - Return Vec<WatchVariable> with current and previous values\n5. `sim_step_network()` - Execute single network and return StepResult\n6. `sim_step_scan()` - Execute single complete scan cycle and return StepResult\nAll debugging commands interact with SimDebugger through SimState",
            "status": "pending",
            "testStrategy": "Test breakpoint CRUD operations work correctly. Test watch variables track value changes. Test step_network advances one network. Test step_scan completes full cycle. Test StepResult contains correct execution info.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Event Emission and Command Registration",
            "description": "Set up Tauri event emission for simulation events and register all commands in lib.rs with proper state management.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "1. Add event emission helpers in commands.rs for:\n   - `sim:scan-complete` - { scanCount, scanTime, timestamp }\n   - `sim:device-change` - { address, oldValue, newValue }\n   - `sim:breakpoint-hit` - { breakpointId, type, details }\n2. Update `src-tauri/src/lib.rs` to:\n   - Add `.manage(SimState::default())` to Builder\n   - Add all sim commands to invoke_handler with tauri::generate_handler![...]\n   - Import SimState and all command functions from sim::commands module\n3. Ensure proper module exports in sim/mod.rs",
            "status": "pending",
            "testStrategy": "Test events are emitted correctly during scan completion. Test device change events fire when memory updates. Test breakpoint hit events include correct details. Test all commands are accessible from frontend via invoke.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Build memory viewer showing X/Y/D/M/T/C regions with live updates, format toggles (binary, hex, decimal), and search"
      },
      {
        "id": "95",
        "title": "Create OneSim React Components and Hooks",
        "description": "Implement React components for simulation control UI including SimToolbar, SimStatus, ScanCycleMonitor, and DebugPanel with their associated hooks.",
        "details": "## Directory: `src/components/OneSim/`\n\n1. **useSimulation.ts Hook:**\n```typescript\nimport { invoke } from '@tauri-apps/api/core';\nimport { listen } from '@tauri-apps/api/event';\n\nexport function useSimulation() {\n  const [status, setStatus] = useState<SimulationStatus>({\n    state: 'stopped',\n    scanCount: 0,\n    lastScanTimeUs: 0,\n    avgScanTimeUs: 0,\n    maxScanTimeUs: 0,\n  });\n  const [scanInfo, setScanInfo] = useState<ScanCycleInfo | null>(null);\n  \n  // Event listeners\n  useEffect(() => {\n    const unlistenScan = listen<ScanCycleInfo>('sim:scan-complete', (e) => {\n      setScanInfo(e.payload);\n    });\n    \n    const unlistenDevice = listen<DeviceChangeEvent>('sim:device-change', (e) => {\n      // Update local cache or notify subscribers\n    });\n    \n    return () => {\n      unlistenScan.then(fn => fn());\n      unlistenDevice.then(fn => fn());\n    };\n  }, []);\n  \n  const start = async (programId: string, config?: SimulationConfig) => {\n    await invoke('sim_start', { programId, config: config ?? DEFAULT_CONFIG });\n    setStatus(prev => ({ ...prev, state: 'running' }));\n  };\n  \n  const stop = async () => {\n    await invoke('sim_stop');\n    setStatus(prev => ({ ...prev, state: 'stopped' }));\n  };\n  \n  return { status, scanInfo, start, stop, pause, resume, getStatus };\n}\n```\n\n2. **SimToolbar.tsx:**\n```tsx\nexport function SimToolbar() {\n  const { status, start, stop, pause, resume } = useSimulation();\n  \n  return (\n    <div className=\"flex items-center gap-2 p-2 bg-gray-100 border-b\">\n      {status.state === 'stopped' && (\n        <button onClick={() => start(programId)} className=\"btn-primary\">\n          <Play size={16} /> Start\n        </button>\n      )}\n      {status.state === 'running' && (\n        <>\n          <button onClick={pause} className=\"btn-secondary\">\n            <Pause size={16} /> Pause\n          </button>\n          <button onClick={stop} className=\"btn-danger\">\n            <Square size={16} /> Stop\n          </button>\n        </>\n      )}\n      {status.state === 'paused' && (\n        <>\n          <button onClick={resume} className=\"btn-primary\">\n            <Play size={16} /> Resume\n          </button>\n          <button onClick={stop} className=\"btn-danger\">\n            <Square size={16} /> Stop\n          </button>\n        </>\n      )}\n      <SimStatusIndicator state={status.state} />\n    </div>\n  );\n}\n```\n\n3. **SimStatus.tsx:**\n```tsx\nexport function SimStatus() {\n  const { status, scanInfo } = useSimulation();\n  \n  return (\n    <div className=\"flex items-center gap-4 text-sm\">\n      <div className=\"flex items-center gap-1\">\n        <span className=\"text-gray-500\">Scans:</span>\n        <span className=\"font-mono\">{status.scanCount.toLocaleString()}</span>\n      </div>\n      <div className=\"flex items-center gap-1\">\n        <span className=\"text-gray-500\">Last:</span>\n        <span className=\"font-mono\">{status.lastScanTimeUs}μs</span>\n      </div>\n      <div className=\"flex items-center gap-1\">\n        <span className=\"text-gray-500\">Avg:</span>\n        <span className=\"font-mono\">{status.avgScanTimeUs}μs</span>\n      </div>\n      <div className=\"flex items-center gap-1\">\n        <span className=\"text-gray-500\">Max:</span>\n        <span className=\"font-mono\">{status.maxScanTimeUs}μs</span>\n      </div>\n    </div>\n  );\n}\n```\n\n4. **ScanCycleMonitor.tsx:**\n```tsx\nexport function ScanCycleMonitor() {\n  const { scanInfo } = useSimulation();\n  const [history, setHistory] = useState<number[]>([]);\n  \n  useEffect(() => {\n    if (scanInfo) {\n      setHistory(prev => [...prev.slice(-99), scanInfo.lastScanTime]);\n    }\n  }, [scanInfo]);\n  \n  return (\n    <div className=\"p-4 bg-gray-800 rounded\">\n      <h3 className=\"text-white mb-2\">Scan Cycle Monitor</h3>\n      {/* Mini bar chart of scan times */}\n      <div className=\"flex items-end gap-px h-16\">\n        {history.map((time, i) => (\n          <div\n            key={i}\n            className=\"w-1 bg-green-500\"\n            style={{ height: `${Math.min(100, time / 10)}%` }}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n```\n\n5. **DebugPanel.tsx:** (See Task 96 for detailed implementation)",
        "testStrategy": "1. Test useSimulation hook initializes with stopped state\n2. Test start() calls Tauri command and updates state\n3. Test stop() stops simulation and resets state\n4. Test pause/resume toggle correctly\n5. Test event listeners receive and process scan events\n6. Test SimToolbar renders correct buttons for each state\n7. Test SimStatus displays formatted statistics\n8. Test ScanCycleMonitor updates graph on new scan events\n9. Integration test: Click start button, verify simulation starts",
        "priority": "medium",
        "dependencies": [
          "86",
          "94"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement useSimulation Hook and TypeScript Types",
            "description": "Create the core useSimulation hook with state management, Tauri command integration, and event listeners for simulation control.",
            "dependencies": [],
            "details": "Create `src/components/OneSim/useSimulation.ts` with:\n\n1. **TypeScript Types** (in types.ts or inline):\n   - SimulationStatus: { state: 'stopped' | 'running' | 'paused', scanCount, lastScanTimeUs, avgScanTimeUs, maxScanTimeUs }\n   - ScanCycleInfo: { scanNumber, lastScanTime, inputChanges, outputChanges }\n   - DeviceChangeEvent: { address, oldValue, newValue, deviceType }\n   - SimulationConfig: { scanIntervalMs, maxScansPerSecond, enableDebug }\n\n2. **Hook Implementation**:\n   - useState for status (SimulationStatus) and scanInfo (ScanCycleInfo | null)\n   - useEffect for Tauri event listeners: 'sim:scan-complete', 'sim:device-change'\n   - Proper cleanup of event listeners on unmount\n   - Methods: start(programId, config?), stop(), pause(), resume(), getStatus()\n   - Each method calls appropriate Tauri invoke command and updates local state\n\n3. **Error Handling**:\n   - Try-catch around Tauri invocations\n   - Error state for failed operations",
            "status": "pending",
            "testStrategy": "1. Test hook initializes with 'stopped' state and null scanInfo\n2. Test start() invokes 'sim_start' command and updates state to 'running'\n3. Test stop() invokes 'sim_stop' and resets state to 'stopped'\n4. Test pause() changes state from 'running' to 'paused'\n5. Test resume() changes state from 'paused' to 'running'\n6. Test event listeners update scanInfo when 'sim:scan-complete' fires\n7. Test cleanup function unsubscribes from all events\n8. Test error handling when Tauri commands fail",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement SimToolbar and SimStatus Components",
            "description": "Create the simulation control toolbar with playback buttons and status display component showing scan statistics.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/OneSim/SimToolbar.tsx`:\n\n1. **SimToolbar Component**:\n   - Consume useSimulation hook for status and control methods\n   - Conditional rendering based on status.state:\n     - 'stopped': Show Start button (Play icon)\n     - 'running': Show Pause and Stop buttons\n     - 'paused': Show Resume and Stop buttons\n   - Use lucide-react icons: Play, Pause, Square\n   - Styling: flex layout, gap-2, bg-gray-100, border-b, p-2\n   - Include SimStatusIndicator sub-component\n\n2. **SimStatusIndicator Component**:\n   - Visual state indicator (colored dot or badge)\n   - Green for running, yellow for paused, gray for stopped\n\n3. **SimStatus Component** (`SimStatus.tsx`):\n   - Display scan count with toLocaleString() formatting\n   - Display lastScanTimeUs, avgScanTimeUs, maxScanTimeUs with μs suffix\n   - Responsive flex layout with gray-500 labels and font-mono values\n\n4. **Export from index.ts**:\n   - Export all components for easy importing",
            "status": "pending",
            "testStrategy": "1. Test SimToolbar renders Start button when state is 'stopped'\n2. Test SimToolbar renders Pause and Stop when state is 'running'\n3. Test SimToolbar renders Resume and Stop when state is 'paused'\n4. Test button clicks trigger correct hook methods\n5. Test SimStatusIndicator shows correct color for each state\n6. Test SimStatus displays all statistics with proper formatting\n7. Test SimStatus updates when status changes\n8. Test buttons are properly disabled during state transitions",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement ScanCycleMonitor Component",
            "description": "Create the scan cycle visualization component with real-time bar chart showing scan time history.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/OneSim/ScanCycleMonitor.tsx`:\n\n1. **State Management**:\n   - useState for history array (last 100 scan times)\n   - useEffect to append new scan times from scanInfo\n   - Slice history to keep only last 100 entries: [...prev.slice(-99), newTime]\n\n2. **Visual Bar Chart**:\n   - Container: bg-gray-800, rounded, p-4\n   - Title: 'Scan Cycle Monitor' in white text\n   - Bar container: flex, items-end, gap-px, h-16\n   - Individual bars: w-1, bg-green-500\n   - Height calculation: `${Math.min(100, time / targetScanTime * 100)}%`\n   - Color coding: green for normal, yellow for warning, red for over threshold\n\n3. **Thresholds and Warnings**:\n   - Normal: scan time < 10ms (green)\n   - Warning: scan time 10-20ms (yellow)\n   - Critical: scan time > 20ms (red)\n\n4. **Statistics Display**:\n   - Current scan time\n   - Moving average of last 10 scans\n   - Peak indicator for max scan time\n\n5. **Performance Optimization**:\n   - Use useMemo for derived statistics\n   - Avoid unnecessary re-renders with proper dependency arrays",
            "status": "pending",
            "testStrategy": "1. Test component renders with empty history initially\n2. Test history updates when new scanInfo is received\n3. Test history maintains max 100 entries\n4. Test bar heights scale correctly based on scan times\n5. Test color coding changes based on threshold values\n6. Test statistics calculations are accurate\n7. Test performance with rapid scan updates (no memory leaks)\n8. Test component handles null scanInfo gracefully",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Subtasks: 1) Implement breakpoint system on rungs/addresses 2) Create step-through execution mode 3) Add power flow visualization during debug"
      },
      {
        "id": "96",
        "title": "Implement Debug Panel Components",
        "description": "Create the DebugPanel React components including BreakpointList, WatchList, and step execution controls for the OneSim debugger UI.",
        "details": "## Components: `src/components/OneSim/`\n\n1. **useDebugger.ts Hook:**\n```typescript\nexport function useDebugger() {\n  const [breakpoints, setBreakpoints] = useState<Breakpoint[]>([]);\n  const [watches, setWatches] = useState<WatchVariable[]>([]);\n  const [isPaused, setIsPaused] = useState(false);\n  const [pauseReason, setPauseReason] = useState<BreakpointHit | null>(null);\n  \n  useEffect(() => {\n    const unlisten = listen<BreakpointHit>('sim:breakpoint-hit', (e) => {\n      setIsPaused(true);\n      setPauseReason(e.payload);\n    });\n    return () => { unlisten.then(fn => fn()); };\n  }, []);\n  \n  const addBreakpoint = async (bp: Omit<Breakpoint, 'id'>) => {\n    const id = await invoke<string>('sim_add_breakpoint', { breakpoint: bp });\n    setBreakpoints(prev => [...prev, { ...bp, id }]);\n  };\n  \n  const removeBreakpoint = async (id: string) => {\n    await invoke('sim_remove_breakpoint', { id });\n    setBreakpoints(prev => prev.filter(bp => bp.id !== id));\n  };\n  \n  const addWatch = async (address: string) => {\n    await invoke('sim_add_watch', { address });\n    refreshWatches();\n  };\n  \n  const refreshWatches = async () => {\n    const result = await invoke<WatchVariable[]>('sim_get_watches');\n    setWatches(result);\n  };\n  \n  const stepNetwork = async () => {\n    const result = await invoke<StepResult>('sim_step_network');\n    refreshWatches();\n    return result;\n  };\n  \n  const stepScan = async () => {\n    const result = await invoke<StepResult>('sim_step_scan');\n    refreshWatches();\n    return result;\n  };\n  \n  return {\n    breakpoints, watches, isPaused, pauseReason,\n    addBreakpoint, removeBreakpoint, toggleBreakpoint,\n    addWatch, removeWatch, refreshWatches,\n    stepNetwork, stepScan, continueExecution\n  };\n}\n```\n\n2. **BreakpointList.tsx:**\n```tsx\nexport function BreakpointList() {\n  const { breakpoints, addBreakpoint, removeBreakpoint, toggleBreakpoint } = useDebugger();\n  const [showAddDialog, setShowAddDialog] = useState(false);\n  \n  return (\n    <div className=\"p-2\">\n      <div className=\"flex justify-between items-center mb-2\">\n        <h4 className=\"font-semibold\">Breakpoints</h4>\n        <button onClick={() => setShowAddDialog(true)} className=\"btn-icon\">\n          <Plus size={14} />\n        </button>\n      </div>\n      \n      <ul className=\"space-y-1\">\n        {breakpoints.map(bp => (\n          <li key={bp.id} className=\"flex items-center gap-2 text-sm\">\n            <input\n              type=\"checkbox\"\n              checked={bp.enabled}\n              onChange={() => toggleBreakpoint(bp.id)}\n            />\n            <span className={bp.enabled ? '' : 'text-gray-400'}>\n              {formatBreakpoint(bp)}\n            </span>\n            <button onClick={() => removeBreakpoint(bp.id)} className=\"ml-auto\">\n              <X size={12} />\n            </button>\n          </li>\n        ))}\n      </ul>\n      \n      {showAddDialog && (\n        <AddBreakpointDialog\n          onAdd={addBreakpoint}\n          onClose={() => setShowAddDialog(false)}\n        />\n      )}\n    </div>\n  );\n}\n```\n\n3. **WatchList.tsx:**\n```tsx\nexport function WatchList() {\n  const { watches, addWatch, removeWatch, refreshWatches } = useDebugger();\n  const [newAddress, setNewAddress] = useState('');\n  \n  return (\n    <div className=\"p-2\">\n      <div className=\"flex justify-between items-center mb-2\">\n        <h4 className=\"font-semibold\">Watch</h4>\n        <button onClick={refreshWatches} className=\"btn-icon\">\n          <RefreshCw size={14} />\n        </button>\n      </div>\n      \n      <div className=\"flex gap-1 mb-2\">\n        <input\n          value={newAddress}\n          onChange={(e) => setNewAddress(e.target.value)}\n          placeholder=\"Address (e.g., D0001)\"\n          className=\"flex-1 px-2 py-1 border rounded text-sm\"\n        />\n        <button onClick={() => { addWatch(newAddress); setNewAddress(''); }}>\n          <Plus size={14} />\n        </button>\n      </div>\n      \n      <table className=\"w-full text-sm\">\n        <thead>\n          <tr className=\"text-left text-gray-500\">\n            <th>Address</th>\n            <th>Value</th>\n            <th>Prev</th>\n            <th>Changes</th>\n            <th></th>\n          </tr>\n        </thead>\n        <tbody>\n          {watches.map(w => (\n            <tr key={w.address}>\n              <td className=\"font-mono\">{w.address}</td>\n              <td className=\"font-mono\">{formatValue(w.currentValue)}</td>\n              <td className=\"font-mono text-gray-400\">{formatValue(w.previousValue)}</td>\n              <td>{w.changeCount}</td>\n              <td>\n                <button onClick={() => removeWatch(w.address)}>\n                  <X size={12} />\n                </button>\n              </td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n```\n\n4. **DebugPanel.tsx:**\n```tsx\nexport function DebugPanel() {\n  const { isPaused, pauseReason, stepNetwork, stepScan, continueExecution } = useDebugger();\n  \n  return (\n    <div className=\"flex flex-col h-full\">\n      {/* Step controls */}\n      <div className=\"flex items-center gap-2 p-2 border-b\">\n        <button onClick={stepNetwork} disabled={!isPaused} title=\"Step Network\">\n          <SkipForward size={16} />\n        </button>\n        <button onClick={stepScan} disabled={!isPaused} title=\"Step Scan\">\n          <FastForward size={16} />\n        </button>\n        <button onClick={continueExecution} disabled={!isPaused} title=\"Continue\">\n          <Play size={16} />\n        </button>\n        {isPaused && pauseReason && (\n          <span className=\"text-sm text-amber-600\">\n            Paused: {formatPauseReason(pauseReason)}\n          </span>\n        )}\n      </div>\n      \n      {/* Breakpoints and Watches */}\n      <div className=\"flex-1 overflow-auto\">\n        <BreakpointList />\n        <WatchList />\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Test useDebugger hook initializes with empty breakpoints and watches\n2. Test addBreakpoint calls Tauri command and updates local state\n3. Test removeBreakpoint removes from local state\n4. Test addWatch adds watch and refreshes list\n5. Test stepNetwork is disabled when not paused\n6. Test stepNetwork calls command and refreshes watches\n7. Test breakpoint-hit event triggers pause state\n8. Test BreakpointList renders all breakpoints with toggle controls\n9. Test WatchList renders watch variables with values\n10. Integration test: Add breakpoint, run simulation, verify pause on hit",
        "priority": "medium",
        "dependencies": [
          "86",
          "94",
          "95"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement useDebugger Hook with Tauri Integration",
            "description": "Create the useDebugger custom hook that manages debugger state (breakpoints, watches, pause state) and provides Tauri command integration for sim_add_breakpoint, sim_remove_breakpoint, sim_add_watch, sim_get_watches, sim_step_network, and sim_step_scan commands.",
            "dependencies": [],
            "details": "Implement useDebugger.ts in src/components/OneSim/ with:\n1. State management: breakpoints (Breakpoint[]), watches (WatchVariable[]), isPaused (boolean), pauseReason (BreakpointHit | null)\n2. Tauri event listener for 'sim:breakpoint-hit' events using @tauri-apps/api/event listen()\n3. Async functions: addBreakpoint, removeBreakpoint, toggleBreakpoint for breakpoint management\n4. Watch functions: addWatch, removeWatch, refreshWatches using sim_get_watches command\n5. Step execution: stepNetwork, stepScan (both call refreshWatches after), continueExecution\n6. Proper cleanup in useEffect for event listener unsubscribe\n7. Define TypeScript interfaces for Breakpoint, WatchVariable, BreakpointHit, StepResult types",
            "status": "pending",
            "testStrategy": "1. Test hook initializes with empty arrays and false pause state\n2. Test addBreakpoint calls invoke('sim_add_breakpoint') and updates state\n3. Test removeBreakpoint removes from state after successful invoke\n4. Test toggleBreakpoint updates enabled property\n5. Test event listener sets isPaused=true and pauseReason on breakpoint-hit\n6. Test refreshWatches updates watches state from sim_get_watches result\n7. Test stepNetwork/stepScan are async and call refreshWatches",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement BreakpointList and WatchList Components",
            "description": "Create BreakpointList.tsx for displaying and managing breakpoints with add/remove/toggle functionality, and WatchList.tsx for watching device addresses with current value, previous value, and change count display.",
            "dependencies": [
              1
            ],
            "details": "Implement in src/components/OneSim/:\n\n**BreakpointList.tsx:**\n1. Use useDebugger hook for breakpoints array and actions\n2. Header with title and Plus button to open AddBreakpointDialog\n3. List rendering with checkbox for enabled toggle, formatted breakpoint text, X button for remove\n4. Conditional styling for disabled breakpoints (text-gray-400)\n5. Create AddBreakpointDialog sub-component for adding new breakpoints\n6. formatBreakpoint helper function for display\n\n**WatchList.tsx:**\n1. Use useDebugger for watches, addWatch, removeWatch, refreshWatches\n2. Header with RefreshCw button for manual refresh\n3. Input field for new address (placeholder: 'Address (e.g., D0001)')\n4. Table with columns: Address, Value, Prev, Changes, remove button\n5. formatValue helper for displaying values\n6. Monospace font for address and value cells",
            "status": "pending",
            "testStrategy": "1. BreakpointList renders empty state correctly\n2. Adding breakpoint opens dialog and calls addBreakpoint on submit\n3. Checkbox toggle calls toggleBreakpoint with correct ID\n4. Remove button calls removeBreakpoint\n5. WatchList shows input field and add button\n6. Adding watch clears input and calls addWatch\n7. Refresh button calls refreshWatches\n8. Table displays address, currentValue, previousValue, changeCount correctly",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement DebugPanel Container with Step Controls",
            "description": "Create the main DebugPanel.tsx component that integrates step execution controls (Step Network, Step Scan, Continue) with BreakpointList and WatchList, showing pause status and reason when debugger is paused.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement DebugPanel.tsx in src/components/OneSim/:\n1. Use useDebugger for isPaused, pauseReason, stepNetwork, stepScan, continueExecution\n2. Flex column layout with full height (h-full)\n3. Step controls toolbar (border-b, p-2):\n   - SkipForward icon button for stepNetwork (disabled when !isPaused)\n   - FastForward icon button for stepScan (disabled when !isPaused)\n   - Play icon button for continueExecution (disabled when !isPaused)\n   - Title attributes for tooltips\n4. Pause status display: amber-600 text showing formatPauseReason when paused\n5. Scrollable content area (flex-1 overflow-auto) containing:\n   - BreakpointList component\n   - WatchList component\n6. formatPauseReason helper to display human-readable pause reason\n7. Import icons from lucide-react: SkipForward, FastForward, Play",
            "status": "pending",
            "testStrategy": "1. Step buttons are disabled when isPaused is false\n2. Step buttons are enabled when isPaused is true\n3. Clicking stepNetwork calls stepNetwork function\n4. Clicking stepScan calls stepScan function\n5. Clicking continue calls continueExecution\n6. Pause reason displays with amber styling when paused\n7. BreakpointList and WatchList are rendered in scrollable area\n8. Panel takes full height of container",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Subtasks: 1) Integrate OneSim with LadderEditor for live monitoring 2) Add comprehensive unit tests for simulation logic 3) Create integration tests with sample programs"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-29T01:07:08.034Z",
      "taskCount": 96,
      "completedCount": 61,
      "tags": [
        "master"
      ]
    }
  }
}