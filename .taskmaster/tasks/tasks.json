{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Initialize Tauri 2.x Project with Rust Backend",
        "description": "Set up the foundational Tauri 2.x project structure with Rust backend and configure the basic build system.",
        "details": "1. Install Tauri CLI: `npm create tauri-app@latest` or `cargo install tauri-cli`\n2. Initialize new Tauri 2.x project with React/TypeScript template:\n   ```bash\n   npm create tauri-app@latest . -- --template react-ts\n   ```\n3. Configure Cargo.toml with required dependencies:\n   ```toml\n   [dependencies]\n   tauri = { version = \"2\", features = [\"devtools\"] }\n   tokio = { version = \"1\", features = [\"full\"] }\n   serde = { version = \"1\", features = [\"derive\"] }\n   serde_json = \"1\"\n   serde_yaml = \"0.9\"\n   zip = \"0.6\"\n   chrono = { version = \"0.4\", features = [\"serde\"] }\n   tempfile = \"3\"\n   thiserror = \"1\"\n   ```\n4. Create the directory structure:\n   ```\n   src-tauri/src/\n   ├── main.rs\n   ├── lib.rs\n   ├── commands/mod.rs\n   ├── project/mod.rs\n   ```\n5. Configure tauri.conf.json with app identifier, window settings, and build configuration\n6. Set up basic main.rs with Tauri builder initialization",
        "testStrategy": "1. Verify `cargo build` completes without errors\n2. Verify `npm run tauri dev` launches the application window\n3. Check that Tauri DevTools are accessible in development mode\n4. Validate all dependencies resolve correctly",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Tauri CLI and Initialize Project with React-TypeScript Template",
            "description": "Install the Tauri CLI globally and create a new Tauri 2.x project using the React-TypeScript template in the current directory.",
            "dependencies": [],
            "details": "Execute `npm create tauri-app@latest . -- --template react-ts` to initialize the project. This will create the basic project structure including src-tauri/ directory with Rust code, src/ directory with React frontend, package.json, and vite.config.ts. If prompted for package manager, select npm. Ensure Node.js 18+ and Rust 1.70+ are installed before running. The template will create main.rs with basic Tauri initialization and a simple React App.tsx component.",
            "status": "done",
            "testStrategy": "Verify that src-tauri/ and src/ directories are created. Check that package.json contains @tauri-apps/api and @tauri-apps/cli dependencies. Verify Cargo.toml exists in src-tauri/ with tauri dependency.",
            "parentId": "undefined",
            "updatedAt": "2026-01-26T17:00:29.712Z"
          },
          {
            "id": 2,
            "title": "Configure Cargo.toml with Required Rust Dependencies",
            "description": "Update the src-tauri/Cargo.toml file to include all required dependencies for the ModOne application.",
            "dependencies": [
              1
            ],
            "details": "Edit src-tauri/Cargo.toml to add the following dependencies: tauri = { version = \"2\", features = [\"devtools\"] }, tokio = { version = \"1\", features = [\"full\"] }, serde = { version = \"1\", features = [\"derive\"] }, serde_json = \"1\", serde_yaml = \"0.9\", zip = \"0.6\", chrono = { version = \"0.4\", features = [\"serde\"] }, tempfile = \"3\", thiserror = \"1\". These dependencies provide async runtime (tokio), serialization (serde), YAML config support (serde_yaml), ZIP archive handling (zip), timestamp management (chrono), temp file handling (tempfile), and error handling (thiserror).",
            "status": "done",
            "testStrategy": "Run `cargo check` in src-tauri/ directory to verify all dependencies resolve correctly. Ensure no version conflicts or missing features errors.",
            "parentId": "undefined",
            "updatedAt": "2026-01-26T17:01:21.721Z"
          },
          {
            "id": 3,
            "title": "Create Rust Module Directory Structure",
            "description": "Set up the organized Rust module structure with commands/ and project/ directories and their mod.rs files.",
            "dependencies": [
              1
            ],
            "details": "Create the following directory structure under src-tauri/src/: commands/mod.rs (empty module for future Tauri commands), project/mod.rs (empty module for project management logic). Create src-tauri/src/lib.rs to serve as the library entry point that will export public modules. Update main.rs to include `mod commands;` and `mod project;` declarations. The lib.rs file should contain placeholder comments indicating where future module exports will be added. This structure follows Rust conventions for organizing a medium-sized application.",
            "status": "done",
            "testStrategy": "Run `cargo build` to verify the module structure compiles. Check that mod.rs files exist in both commands/ and project/ directories.",
            "parentId": "undefined",
            "updatedAt": "2026-01-26T17:02:03.042Z"
          },
          {
            "id": 4,
            "title": "Configure tauri.conf.json with App Settings",
            "description": "Update the Tauri configuration file with the ModOne application identifier, window settings, and build configuration.",
            "dependencies": [
              1
            ],
            "details": "Edit src-tauri/tauri.conf.json to configure: identifier as \"com.modone.app\", productName as \"ModOne\", window title as \"ModOne\", default window size (width: 1280, height: 800), minimum window size (width: 800, height: 600), enable window decorations, allow resizing. In the build section, configure beforeDevCommand as \"npm run dev\" and beforeBuildCommand as \"npm run build\". Set the devUrl to the Vite dev server URL (http://localhost:1420). Enable devtools in development mode. Configure file associations for .mop files if supported by Tauri 2.x config.",
            "status": "done",
            "testStrategy": "Run `npm run tauri dev` and verify the window opens with the correct title and dimensions. Check that the window is resizable and respects minimum size constraints.",
            "parentId": "undefined",
            "updatedAt": "2026-01-26T17:02:26.482Z"
          },
          {
            "id": 5,
            "title": "Set Up Basic main.rs with Tauri Builder Initialization",
            "description": "Configure the main.rs entry point with proper Tauri builder initialization, state management setup, and invoke handler registration.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Update src-tauri/src/main.rs to: 1) Add #![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")] for Windows builds, 2) Import necessary modules with `mod commands;` and `mod project;`, 3) Configure the Tauri Builder with .setup() hook for initialization logging, 4) Add placeholder .manage() for future state management (ProjectManager wrapped in Mutex), 5) Set up .invoke_handler(tauri::generate_handler![]) ready for command registration, 6) Add basic error handling for the build().run() call. Include comments indicating where future commands and state will be registered.",
            "status": "done",
            "testStrategy": "Run `npm run tauri dev` to verify the application launches without errors. Check console/terminal for setup hook logging. Verify the React frontend loads in the Tauri window. Test that DevTools are accessible in development mode (right-click > Inspect or keyboard shortcut).",
            "parentId": "undefined",
            "updatedAt": "2026-01-26T17:04:08.894Z"
          }
        ],
        "updatedAt": "2026-01-26T17:04:08.894Z"
      },
      {
        "id": "2",
        "title": "Configure Frontend with React 18 and TypeScript",
        "description": "Set up the React 18 frontend with TypeScript, Tailwind CSS for styling, and Zustand for state management.",
        "details": "1. Install frontend dependencies:\n   ```bash\n   npm install react@18 react-dom@18 zustand tailwindcss postcss autoprefixer\n   npm install -D @types/react @types/react-dom typescript @tauri-apps/api\n   ```\n2. Initialize Tailwind CSS:\n   ```bash\n   npx tailwindcss init -p\n   ```\n3. Configure tailwind.config.js with content paths\n4. Create TypeScript configuration (tsconfig.json) with strict mode\n5. Set up src/ directory structure:\n   ```\n   src/\n   ├── App.tsx\n   ├── main.tsx\n   ├── index.css (Tailwind imports)\n   ├── components/\n   ├── hooks/\n   ├── stores/\n   │   └── projectStore.ts\n   └── types/\n       └── project.ts\n   ```\n6. Create base App.tsx component with Tailwind styling\n7. Configure Zustand store for project state management:\n   ```typescript\n   interface ProjectStore {\n     currentProject: ProjectData | null;\n     isModified: boolean;\n     recentProjects: RecentProject[];\n     setProject: (project: ProjectData | null) => void;\n     setModified: (modified: boolean) => void;\n   }\n   ```",
        "testStrategy": "1. Verify `npm run dev` starts the Vite development server\n2. Check Tailwind CSS classes apply correctly to components\n3. Test Zustand store state updates in React DevTools\n4. Validate TypeScript compilation with no type errors",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Additional Frontend Dependencies (Zustand, Tailwind CSS)",
            "description": "Install Zustand for state management and Tailwind CSS with PostCSS/Autoprefixer for styling on top of the React-TypeScript template from Task 1.",
            "dependencies": [],
            "details": "After Task 1 completes, the Tauri React-TypeScript template will have React 18 and basic TypeScript already configured. Run `npm install zustand` to add the state management library. Then install Tailwind CSS and its peer dependencies with `npm install -D tailwindcss postcss autoprefixer`. Verify @tauri-apps/api is already installed from the template; if not, add it with `npm install @tauri-apps/api`. The template should already include @types/react and @types/react-dom as dev dependencies.",
            "status": "done",
            "testStrategy": "Run `npm list zustand tailwindcss postcss autoprefixer` to verify all packages are installed. Check package.json contains the new dependencies with correct versions.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T02:42:58.345Z"
          },
          {
            "id": 2,
            "title": "Initialize and Configure Tailwind CSS",
            "description": "Initialize Tailwind CSS configuration and set up the base styles with proper content paths for the Tauri React project.",
            "dependencies": [
              1
            ],
            "details": "Run `npx tailwindcss init -p` to generate tailwind.config.js and postcss.config.js files. Update tailwind.config.js to include content paths: `content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}']`. Create or update src/index.css with Tailwind directives: `@tailwind base; @tailwind components; @tailwind utilities;`. Ensure main.tsx imports this CSS file. Add custom theme extensions if needed for ModOne branding (colors, fonts). Configure darkMode option as 'class' for future dark mode support.",
            "status": "done",
            "testStrategy": "Start the dev server with `npm run dev` and add a test Tailwind class (e.g., `className=\"bg-blue-500 text-white p-4\"`) to App.tsx. Verify the styles render correctly in the browser.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T02:42:58.353Z"
          },
          {
            "id": 3,
            "title": "Configure TypeScript with Strict Mode and Path Aliases",
            "description": "Update the TypeScript configuration with strict type checking enabled and configure path aliases for cleaner imports.",
            "dependencies": [
              1
            ],
            "details": "The template provides a base tsconfig.json. Update it to enable strict mode: `\"strict\": true, \"noImplicitAny\": true, \"strictNullChecks\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true`. Add path aliases for cleaner imports: `\"paths\": { \"@/*\": [\"./src/*\"], \"@components/*\": [\"./src/components/*\"], \"@hooks/*\": [\"./src/hooks/*\"], \"@stores/*\": [\"./src/stores/*\"], \"@types/*\": [\"./src/types/*\"], \"@services/*\": [\"./src/services/*\"] }`. Update vite.config.ts to resolve these aliases using vite-tsconfig-paths plugin or manual alias configuration.",
            "status": "done",
            "testStrategy": "Run `npx tsc --noEmit` to verify TypeScript compiles without errors. Test a path alias import works correctly. Verify strict mode catches type errors in intentionally incorrect test code.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T02:42:58.358Z"
          },
          {
            "id": 4,
            "title": "Create Frontend Directory Structure and Type Definitions",
            "description": "Set up the organized src/ directory structure with components, hooks, stores, services, and types directories, including base type definitions for the project.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create the directory structure: src/components/ (UI components), src/hooks/ (custom React hooks), src/stores/ (Zustand stores), src/services/ (API/Tauri service layer), src/types/ (TypeScript type definitions). Create src/types/project.ts with core type definitions: `export type PlcManufacturer = 'LS' | 'Mitsubishi' | 'Siemens'; export interface ProjectSettings { name: string; description: string; createdAt: string; updatedAt: string; } export interface PlcSettings { manufacturer: PlcManufacturer; model: string; scanTimeMs: number; } export interface ProjectData { config: ProjectConfig; isModified: boolean; } export interface RecentProject { name: string; path: string; lastOpened: string; }` and additional interfaces matching the Rust types from Task 3.",
            "status": "done",
            "testStrategy": "Verify all directories exist with proper structure. Import types in a test file and verify TypeScript recognizes them. Check path aliases work with the new directories.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T02:42:58.364Z"
          },
          {
            "id": 5,
            "title": "Implement Zustand Project Store and Base App Component",
            "description": "Create the Zustand store for project state management and update the base App.tsx component with Tailwind styling and store integration.",
            "dependencies": [
              4
            ],
            "details": "Create src/stores/projectStore.ts with Zustand: `import { create } from 'zustand'; import type { ProjectData, RecentProject } from '@types/project'; interface ProjectStore { currentProject: ProjectData | null; isModified: boolean; recentProjects: RecentProject[]; isLoading: boolean; error: string | null; setProject: (project: ProjectData | null) => void; setModified: (modified: boolean) => void; setRecentProjects: (projects: RecentProject[]) => void; setLoading: (loading: boolean) => void; setError: (error: string | null) => void; reset: () => void; } export const useProjectStore = create<ProjectStore>((set) => ({ currentProject: null, isModified: false, recentProjects: [], isLoading: false, error: null, setProject: (project) => set({ currentProject: project, isModified: false }), setModified: (modified) => set({ isModified: modified }), setRecentProjects: (projects) => set({ recentProjects: projects }), setLoading: (loading) => set({ isLoading: loading }), setError: (error) => set({ error }), reset: () => set({ currentProject: null, isModified: false, error: null }) }));` Update App.tsx with Tailwind classes and basic layout structure for the ModOne application shell.",
            "status": "done",
            "testStrategy": "Verify the Zustand store initializes correctly by checking initial state values. Test each action updates state properly. Use React DevTools with Zustand devtools to inspect state changes. Verify App.tsx renders with Tailwind styles applied.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T02:42:58.370Z"
          }
        ],
        "updatedAt": "2026-01-27T02:42:58.370Z"
      },
      {
        "id": "3",
        "title": "Define ProjectConfig and YAML Schema Types",
        "description": "Create Rust structs and TypeScript types for the config.yml schema including project settings, PLC configuration, and Modbus parameters.",
        "details": "1. Create Rust types in src-tauri/src/project/config.rs:\n   ```rust\n   use serde::{Deserialize, Serialize};\n   use chrono::{DateTime, Utc};\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub struct ProjectConfig {\n       pub version: String,\n       pub project: ProjectSettings,\n       pub plc: PlcSettings,\n       pub modbus: ModbusSettings,\n       pub memory_map: MemoryMapSettings,\n   }\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub struct ProjectSettings {\n       pub name: String,\n       pub description: String,\n       pub created_at: DateTime<Utc>,\n       pub updated_at: DateTime<Utc>,\n   }\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub struct PlcSettings {\n       pub manufacturer: PlcManufacturer,\n       pub model: String,\n       pub scan_time_ms: u32,\n   }\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub enum PlcManufacturer {\n       LS, Mitsubishi, Siemens\n   }\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub struct ModbusSettings {\n       pub tcp: ModbusTcpSettings,\n       pub rtu: ModbusRtuSettings,\n   }\n   // ... TCP and RTU settings structs\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub struct MemoryMapSettings {\n       pub coil_start: u16,\n       pub coil_count: u16,\n       pub discrete_input_start: u16,\n       pub discrete_input_count: u16,\n       pub holding_register_start: u16,\n       pub holding_register_count: u16,\n       pub input_register_start: u16,\n       pub input_register_count: u16,\n   }\n   ```\n2. Create mirror TypeScript types in src/types/project.ts:\n   ```typescript\n   export interface ProjectConfig {\n     version: string;\n     project: ProjectSettings;\n     plc: PlcSettings;\n     modbus: ModbusSettings;\n     memory_map: MemoryMapSettings;\n   }\n   // ... matching interfaces\n   ```\n3. Implement Default trait for ProjectConfig with sensible defaults\n4. Add validation methods for config values",
        "testStrategy": "1. Unit test YAML serialization/deserialization roundtrip in Rust\n2. Test default config generation produces valid YAML\n3. Test validation catches invalid values (negative ports, invalid enum variants)\n4. Verify TypeScript types match Rust struct serialization output",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Rust config.rs Module with Core ProjectConfig Struct",
            "description": "Create the src-tauri/src/project/config.rs file with the main ProjectConfig struct and its nested ProjectSettings, including serde derives for YAML serialization.",
            "dependencies": [],
            "details": "Create src-tauri/src/project/config.rs with the following structures: 1) Add imports for serde::{Deserialize, Serialize} and chrono::{DateTime, Utc}. 2) Define ProjectConfig struct with fields: version (String), project (ProjectSettings), plc (PlcSettings), modbus (ModbusSettings), memory_map (MemoryMapSettings). 3) Define ProjectSettings struct with fields: name (String), description (String), created_at (DateTime<Utc>), updated_at (DateTime<Utc>). All structs should derive Serialize, Deserialize, Clone, and Debug. Add #[serde(rename_all = \"snake_case\")] where appropriate to match YAML field naming convention from the PRD config.yml schema.",
            "status": "done",
            "testStrategy": "Run `cargo check` to verify the struct definitions compile. Write a simple test that creates a ProjectConfig instance and verifies all fields are accessible.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:16:20.222Z"
          },
          {
            "id": 2,
            "title": "Define PlcSettings Struct and PlcManufacturer Enum",
            "description": "Add the PlcSettings struct and PlcManufacturer enum to config.rs to handle PLC configuration including manufacturer, model, and scan time settings.",
            "dependencies": [
              1
            ],
            "details": "In src-tauri/src/project/config.rs, add: 1) PlcManufacturer enum with variants LS, Mitsubishi, and Siemens - derive Serialize, Deserialize, Clone, Debug, PartialEq. Add #[serde(rename_all = \"PascalCase\")] or explicit rename attributes to match YAML format (\"LS\", \"Mitsubishi\", \"Siemens\"). 2) PlcSettings struct with fields: manufacturer (PlcManufacturer), model (String), scan_time_ms (u32). Include serde attributes for snake_case serialization to match config.yml schema. Consider adding a FromStr implementation for PlcManufacturer to support parsing from string input in Tauri commands.",
            "status": "done",
            "testStrategy": "Write unit tests to verify PlcManufacturer serializes to correct YAML strings. Test deserialization from YAML string representation. Verify scan_time_ms accepts reasonable values.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:16:20.230Z"
          },
          {
            "id": 3,
            "title": "Implement ModbusSettings with TCP and RTU Configuration Structs",
            "description": "Create ModbusSettings struct with nested ModbusTcpSettings and ModbusRtuSettings structs to handle both Modbus communication protocols as defined in the PRD.",
            "dependencies": [
              1
            ],
            "details": "In src-tauri/src/project/config.rs, add: 1) ModbusSettings struct with fields: tcp (ModbusTcpSettings), rtu (ModbusRtuSettings). 2) ModbusTcpSettings struct with fields: enabled (bool), port (u16), unit_id (u8). 3) ModbusRtuSettings struct with fields: enabled (bool), com_port (String), baud_rate (u32), parity (Parity enum or String), stop_bits (u8). 4) Optionally create Parity enum with variants None, Even, Odd for type safety. All structs derive Serialize, Deserialize, Clone, Debug. Use #[serde(rename_all = \"snake_case\")] to match the YAML schema from PRD (tcp.enabled, rtu.com_port, etc.).",
            "status": "done",
            "testStrategy": "Write unit tests to serialize ModbusSettings to YAML and verify output matches PRD schema format. Test deserialization from sample YAML config. Verify port is within valid range 0-65535.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:16:20.236Z"
          },
          {
            "id": 4,
            "title": "Add MemoryMapSettings Struct and Implement Default Trait for ProjectConfig",
            "description": "Create MemoryMapSettings struct for Modbus memory mapping configuration and implement the Default trait for all config structs with sensible production defaults.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "In src-tauri/src/project/config.rs: 1) Create MemoryMapSettings struct with u16 fields: coil_start, coil_count, discrete_input_start, discrete_input_count, holding_register_start, holding_register_count, input_register_start, input_register_count. 2) Implement Default trait for all structs with values matching PRD defaults: version=\"1.0\", scan_time_ms=10, tcp.port=502, tcp.unit_id=1, tcp.enabled=true, rtu.enabled=false, rtu.baud_rate=9600, all memory counts=1000, all starts=0. 3) For ProjectSettings default, use empty strings for name/description and Utc::now() for timestamps. 4) Export config module from project/mod.rs (create mod.rs if needed with `pub mod config;`).",
            "status": "done",
            "testStrategy": "Test that ProjectConfig::default() produces valid configuration. Serialize default config to YAML and verify it matches PRD example. Test that all numeric defaults are within valid ranges.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:16:20.243Z"
          },
          {
            "id": 5,
            "title": "Create TypeScript Mirror Types in src/types/project.ts",
            "description": "Create TypeScript interfaces in the frontend that mirror the Rust structs to ensure type-safe communication between Tauri backend and React frontend.",
            "dependencies": [
              4
            ],
            "details": "Create or update src/types/project.ts with: 1) PlcManufacturer type as union literal: type PlcManufacturer = 'LS' | 'Mitsubishi' | 'Siemens'. 2) ProjectConfig interface with fields: version (string), project (ProjectSettings), plc (PlcSettings), modbus (ModbusSettings), memory_map (MemoryMapSettings). 3) ProjectSettings interface: name (string), description (string), created_at (string - ISO8601), updated_at (string). 4) PlcSettings interface: manufacturer (PlcManufacturer), model (string), scan_time_ms (number). 5) ModbusSettings, ModbusTcpSettings, ModbusRtuSettings interfaces matching Rust structs. 6) MemoryMapSettings interface with all u16 fields as number type. Use snake_case for property names to match Rust serde serialization. Export all types. If the file already exists from Task 2, extend it with these additional interfaces.",
            "status": "done",
            "testStrategy": "Verify TypeScript compiles without errors using `npx tsc --noEmit`. Create a sample object matching ProjectConfig interface and verify it type-checks correctly. Compare field names with Rust struct serialization output to ensure they match.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:16:20.314Z"
          }
        ],
        "updatedAt": "2026-01-27T03:16:20.314Z"
      },
      {
        "id": "4",
        "title": "Implement .mop ZIP Archive Handler",
        "description": "Create the MopFile module to handle ZIP compression/decompression of .mop project files with proper directory structure.",
        "details": "1. Create src-tauri/src/project/mop_file.rs:\n   ```rust\n   use std::path::{Path, PathBuf};\n   use std::fs::{self, File};\n   use std::io::{Read, Write};\n   use zip::{ZipArchive, ZipWriter, write::FileOptions};\n   use tempfile::TempDir;\n   use thiserror::Error;\n\n   #[derive(Error, Debug)]\n   pub enum MopFileError {\n       #[error(\"IO error: {0}\")]\n       Io(#[from] std::io::Error),\n       #[error(\"ZIP error: {0}\")]\n       Zip(#[from] zip::result::ZipError),\n       #[error(\"Invalid .mop structure: {0}\")]\n       InvalidStructure(String),\n       #[error(\"Config parse error: {0}\")]\n       ConfigParse(#[from] serde_yaml::Error),\n   }\n\n   pub struct MopFile {\n       pub temp_dir: TempDir,\n       pub source_path: Option<PathBuf>,\n   }\n\n   impl MopFile {\n       /// Extract .mop file to temporary directory\n       pub fn open(path: &Path) -> Result<Self, MopFileError>;\n\n       /// Create new .mop structure in temporary directory\n       pub fn create_new() -> Result<Self, MopFileError>;\n\n       /// Save to .mop file (ZIP compress)\n       pub fn save(&self, path: &Path) -> Result<(), MopFileError>;\n\n       /// Get path to config.yml\n       pub fn config_path(&self) -> PathBuf;\n\n       /// Get path to plc_csv directory\n       pub fn plc_csv_dir(&self) -> PathBuf;\n\n       /// Validate .mop structure\n       fn validate_structure(&self) -> Result<(), MopFileError>;\n   }\n   ```\n2. Implement recursive ZIP extraction preserving directory structure\n3. Implement recursive ZIP compression of temp directory\n4. Create helper methods for accessing subdirectories:\n   - modone/config.yml\n   - plc_csv/\n   - one_canvas/\n   - mod_server_memory.csv\n   - scenario.csv\n5. Handle file encoding (UTF-8 for text files)\n6. Implement cleanup on Drop for temporary directory",
        "testStrategy": "1. Test creating new .mop file with default structure\n2. Test opening existing .mop file and verifying extracted contents\n3. Test save/load roundtrip preserves all files and directory structure\n4. Test error handling for corrupted ZIP files\n5. Test error handling for missing required files (config.yml)\n6. Verify temporary directory cleanup on MopFile drop",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create mop_file.rs Module with Error Types and MopFile Struct",
            "description": "Create the src-tauri/src/project/mop_file.rs file with MopFileError enum using thiserror and the base MopFile struct with TempDir and source_path fields.",
            "dependencies": [],
            "details": "Create src-tauri/src/project/mop_file.rs with the following: 1) Add imports for std::path::{Path, PathBuf}, std::fs::{self, File}, std::io::{Read, Write, BufReader, BufWriter}, zip::{ZipArchive, ZipWriter, write::SimpleFileOptions}, tempfile::TempDir, and thiserror::Error. 2) Define MopFileError enum with variants: Io(#[from] std::io::Error), Zip(#[from] zip::result::ZipError), InvalidStructure(String), ConfigParse(#[from] serde_yaml::Error). 3) Define MopFile struct with fields: temp_dir (TempDir), source_path (Option<PathBuf>). 4) Add constants for required paths: MODONE_DIR=\"modone\", CONFIG_FILE=\"modone/config.yml\", PLC_CSV_DIR=\"plc_csv\", ONE_CANVAS_DIR=\"one_canvas\", MOD_SERVER_MEMORY_FILE=\"mod_server_memory.csv\", SCENARIO_FILE=\"scenario.csv\". 5) Export this module from project/mod.rs with `pub mod mop_file;`. Note: zip crate version 0.6+ uses SimpleFileOptions instead of FileOptions.",
            "status": "done",
            "testStrategy": "Run `cargo check` in src-tauri/ to verify the struct and error definitions compile. Verify TempDir and PathBuf types are correctly imported. Test that MopFileError variants can be constructed manually.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:31:01.106Z"
          },
          {
            "id": 2,
            "title": "Implement create_new() and Helper Path Methods",
            "description": "Implement the MopFile::create_new() constructor to initialize a new .mop structure in a temporary directory with all required subdirectories and empty files.",
            "dependencies": [
              1
            ],
            "details": "In mop_file.rs, implement: 1) MopFile::create_new() -> Result<Self, MopFileError> that creates a TempDir, then creates the directory structure: modone/, plc_csv/, one_canvas/. Create empty placeholder files: mod_server_memory.csv, scenario.csv with UTF-8 BOM or header if appropriate. Do NOT create config.yml here - it will be created by ProjectManager with actual values. 2) Add helper methods: config_path(&self) -> PathBuf returns temp_dir.path().join(\"modone/config.yml\"), plc_csv_dir(&self) -> PathBuf returns temp_dir.path().join(\"plc_csv\"), one_canvas_dir(&self) -> PathBuf returns temp_dir.path().join(\"one_canvas\"), mod_server_memory_path(&self) -> PathBuf, scenario_path(&self) -> PathBuf. 3) Add root_path(&self) -> &Path helper returning temp_dir.path(). Use fs::create_dir_all for nested directory creation.",
            "status": "done",
            "testStrategy": "Write unit test that calls create_new() and verifies all directories exist using fs::metadata(). Check that helper path methods return correct absolute paths. Verify the TempDir is created in system temp location.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:31:01.114Z"
          },
          {
            "id": 3,
            "title": "Implement open() for ZIP Extraction with Recursive Directory Support",
            "description": "Implement MopFile::open(path) to extract a .mop ZIP file to a temporary directory, preserving the complete directory structure recursively.",
            "dependencies": [
              1
            ],
            "details": "Implement MopFile::open(path: &Path) -> Result<Self, MopFileError>: 1) Create TempDir for extraction target. 2) Open the .mop file using File::open and create ZipArchive::new(BufReader::new(file)). 3) Iterate through all entries with archive.by_index(i): a) For directories (name ends with '/'), create with fs::create_dir_all. b) For files, ensure parent directory exists, then create file and copy contents. c) Preserve UTF-8 encoding by reading as bytes and writing bytes directly. 4) Handle path traversal security by checking that extracted paths don't escape temp_dir using Path::starts_with(). 5) Store source_path as Some(path.to_path_buf()). 6) Call validate_structure() before returning. Important: Handle both forward slash and backslash in ZIP entry names for cross-platform compatibility.",
            "status": "done",
            "testStrategy": "Create a test .mop file manually with known structure, extract it using open(), verify all files and directories exist at expected locations. Test that file contents are preserved byte-for-byte. Test error handling with a corrupted ZIP file.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:31:01.121Z"
          },
          {
            "id": 4,
            "title": "Implement save() for Recursive ZIP Compression",
            "description": "Implement MopFile::save(path) to compress the temporary directory contents into a .mop ZIP archive, preserving the complete directory structure.",
            "dependencies": [
              2
            ],
            "details": "Implement MopFile::save(&self, path: &Path) -> Result<(), MopFileError>: 1) Create output file with File::create and wrap in ZipWriter::new(BufWriter::new(file)). 2) Create a recursive helper function add_directory_to_zip(zip: &mut ZipWriter, base_path: &Path, current_path: &Path) that: a) Uses fs::read_dir to iterate entries. b) For directories, adds them to ZIP with trailing slash and recurses. c) For files, reads contents and adds with correct relative path. 3) Use SimpleFileOptions::default().compression_method(zip::CompressionMethod::Deflated) for compression. 4) Calculate relative paths from temp_dir root for ZIP entry names. 5) Use forward slashes in ZIP paths for cross-platform compatibility. 6) Call zip.finish() to finalize the archive. 7) Update source_path to Some(path.to_path_buf()) after successful save.",
            "status": "done",
            "testStrategy": "Create a MopFile with create_new(), add some test files to its directories, call save(), then open the saved .mop with open() and verify all contents match. Test save/load roundtrip preserves file contents and directory structure exactly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:31:01.129Z"
          },
          {
            "id": 5,
            "title": "Implement validate_structure() and Ensure TempDir Cleanup on Drop",
            "description": "Implement structure validation to check for required files/directories in the .mop archive, and verify that TempDir automatically cleans up when MopFile is dropped.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement validate_structure(&self) -> Result<(), MopFileError>: 1) Check that modone/ directory exists using self.temp_dir.path().join(\"modone\").is_dir(). 2) Optionally check for config.yml existence (may be lenient for new projects). 3) Return Err(MopFileError::InvalidStructure(message)) with descriptive message if validation fails, e.g., \"Missing required directory: modone/\". 4) TempDir from tempfile crate automatically implements Drop to clean up the directory - no manual implementation needed. 5) Add a test to verify cleanup: create MopFile, get temp path, drop MopFile, verify path no longer exists. 6) Consider adding a validate_config() method that attempts to parse config.yml and returns the result. 7) Add #[derive(Debug)] to MopFile for debugging purposes. Note: TempDir's drop behavior is automatic - just ensure temp_dir field is not leaked.",
            "status": "done",
            "testStrategy": "Test validate_structure() catches missing modone/ directory. Test with valid structure passes validation. Create MopFile in a scope, capture temp path, exit scope, verify directory is deleted. Test that opening invalid .mop without modone/ returns appropriate InvalidStructure error.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:31:01.136Z"
          }
        ],
        "updatedAt": "2026-01-27T03:31:01.136Z"
      },
      {
        "id": "5",
        "title": "Implement Project Manager State",
        "description": "Create the ProjectManager struct to maintain the current project state, handle lifecycle events, and coordinate between subsystems.",
        "details": "1. Create src-tauri/src/project/mod.rs with ProjectManager:\n   ```rust\n   use std::sync::{Arc, Mutex};\n   use std::path::PathBuf;\n   use chrono::{DateTime, Utc};\n\n   pub struct ProjectManager {\n       current: Option<LoadedProject>,\n       recent_projects: Vec<RecentProject>,\n       auto_save_enabled: bool,\n       auto_save_interval_secs: u64,\n   }\n\n   pub struct LoadedProject {\n       pub mop_file: MopFile,\n       pub config: ProjectConfig,\n       pub is_modified: bool,\n       pub canvas_data: Option<CanvasData>,\n       pub scenario_data: Option<ScenarioData>,\n       pub memory_snapshot: Option<MemorySnapshot>,\n   }\n\n   #[derive(Serialize, Deserialize, Clone)]\n   pub struct RecentProject {\n       pub name: String,\n       pub path: PathBuf,\n       pub last_opened: DateTime<Utc>,\n   }\n\n   impl ProjectManager {\n       pub fn new() -> Self;\n       pub fn create_project(&mut self, name: String, path: PathBuf, plc: PlcSettings) -> Result<ProjectInfo>;\n       pub fn open_project(&mut self, path: PathBuf) -> Result<ProjectData>;\n       pub fn save_project(&mut self, path: Option<PathBuf>) -> Result<()>;\n       pub fn close_project(&mut self) -> Result<()>;\n       pub fn mark_modified(&mut self);\n       pub fn get_recent_projects(&self) -> Vec<RecentProject>;\n       fn add_to_recent(&mut self, project: &RecentProject);\n       fn persist_recent_projects(&self) -> Result<()>;\n   }\n   ```\n2. Use Arc<Mutex<ProjectManager>> for thread-safe state in Tauri\n3. Store recent projects in app data directory\n4. Implement modified flag tracking for unsaved changes warning\n5. Create placeholder structs for CanvasData, ScenarioData, MemorySnapshot (to be implemented in later units)",
        "testStrategy": "1. Test project creation initializes correct state\n2. Test open/close lifecycle transitions\n3. Test recent projects list updates and persists\n4. Test modified flag behavior\n5. Test concurrent access safety with Arc<Mutex>\n6. Test save with modified data updates timestamp",
        "priority": "high",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Placeholder Data Types and LoadedProject Struct",
            "description": "Define placeholder structs for CanvasData, ScenarioData, and MemorySnapshot that will be implemented in later units, along with the LoadedProject struct that holds the currently open project state.",
            "dependencies": [],
            "details": "In src-tauri/src/project/mod.rs, add the following placeholder types with derive macros: 1) CanvasData struct with a single Option<serde_json::Value> field called 'data' to hold arbitrary canvas state until Unit 5 implements the real structure. 2) ScenarioData struct with Option<serde_json::Value> field for scenario editor data (Unit 6). 3) MemorySnapshot struct with Option<serde_json::Value> field for Modbus memory state (Unit 3). 4) Define LoadedProject struct with fields: mop_file (MopFile from mop_file.rs), config (ProjectConfig from config.rs), is_modified (bool), canvas_data (Option<CanvasData>), scenario_data (Option<ScenarioData>), memory_snapshot (Option<MemorySnapshot>). All structs should derive Debug and Clone where possible. LoadedProject cannot derive Clone due to MopFile containing TempDir. Add comments indicating which unit will fully implement each placeholder.",
            "status": "done",
            "testStrategy": "Run `cargo check` to verify all struct definitions compile. Create a test that instantiates LoadedProject with default/None values for optional fields. Verify the is_modified field can be set and read correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:20:15.160Z"
          },
          {
            "id": 2,
            "title": "Define RecentProject Struct and Persistence Methods",
            "description": "Create the RecentProject struct with serialization support and implement persistence to the application data directory using Tauri's path resolver.",
            "dependencies": [],
            "details": "In src-tauri/src/project/mod.rs, add: 1) RecentProject struct with fields: name (String), path (PathBuf), last_opened (DateTime<Utc>). Derive Serialize, Deserialize, Clone, Debug. 2) Create a private helper function get_recent_projects_path() -> Option<PathBuf> that returns the path to recent_projects.json in the app data directory. For now, use directories::ProjectDirs::from(\"com\", \"modone\", \"ModOne\") to get the config dir (add 'directories' crate to Cargo.toml, or use a hardcoded path as placeholder until Tauri's app_data_dir is available at runtime). 3) Create load_recent_projects() -> Vec<RecentProject> that reads and deserializes from the JSON file, returning empty vec if file doesn't exist. 4) Create save_recent_projects(projects: &[RecentProject]) -> Result<(), std::io::Error> that serializes and writes to the JSON file, creating parent directories if needed. Limit the list to 10 most recent projects.",
            "status": "done",
            "testStrategy": "Write unit tests for serialization roundtrip of RecentProject. Test load_recent_projects returns empty vec when file doesn't exist. Test save_recent_projects creates the file and parent directories. Test that saving more than 10 projects keeps only the 10 most recent.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:20:15.169Z"
          },
          {
            "id": 3,
            "title": "Create ProjectManager Struct with Constructor and Basic Accessors",
            "description": "Define the main ProjectManager struct with all required fields and implement the new() constructor that initializes state and loads recent projects from disk.",
            "dependencies": [
              1,
              2
            ],
            "details": "In src-tauri/src/project/mod.rs, add: 1) ProjectManager struct with fields: current (Option<LoadedProject>), recent_projects (Vec<RecentProject>), auto_save_enabled (bool, default true), auto_save_interval_secs (u64, default 300). 2) Implement ProjectManager::new() -> Self that initializes all fields with defaults and calls load_recent_projects() to populate the recent_projects field. 3) Add getter methods: get_current_project(&self) -> Option<&LoadedProject>, is_project_open(&self) -> bool, get_recent_projects(&self) -> &[RecentProject], is_modified(&self) -> bool (returns current project's is_modified or false if no project open). 4) Add mark_modified(&mut self) method that sets current project's is_modified to true if a project is open. 5) Ensure the module properly exports all public types with `pub use` statements for ProjectManager, LoadedProject, RecentProject, and placeholder types.",
            "status": "done",
            "testStrategy": "Test that ProjectManager::new() returns a manager with no current project. Test is_project_open() returns false initially. Test mark_modified() does nothing when no project is open. Test get_recent_projects() returns whatever was loaded from disk.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:20:15.175Z"
          },
          {
            "id": 4,
            "title": "Implement create_project, open_project, and close_project Methods",
            "description": "Implement the core project lifecycle methods that create new projects, open existing .mop files, and properly close/cleanup the current project.",
            "dependencies": [
              3
            ],
            "details": "Implement the following methods on ProjectManager: 1) create_project(&mut self, name: String, path: PathBuf, plc: PlcSettings) -> Result<ProjectInfo, MopFileError>: Create new MopFile with MopFile::create_new(), create ProjectConfig with provided name and plc settings using Utc::now() for timestamps, write config.yml to mop_file.config_path() using serde_yaml::to_writer, save the .mop file to path, set self.current to new LoadedProject with the mop_file and config, call add_to_recent(), return ProjectInfo with name, path, created_at. 2) open_project(&mut self, path: PathBuf) -> Result<ProjectData, MopFileError>: Call close_project() first if a project is open, open MopFile with MopFile::open(&path), read and parse config.yml using serde_yaml::from_reader, create LoadedProject with parsed config and is_modified=false, set self.current, call add_to_recent(), return ProjectData with config and None for optional data. 3) close_project(&mut self) -> Result<(), MopFileError>: If current is Some and is_modified, return an error indicating unsaved changes (or just clear - design choice). Set self.current to None. The MopFile's TempDir will auto-cleanup on drop. 4) Add private add_to_recent(&mut self, name: String, path: PathBuf) that creates RecentProject with Utc::now(), adds to front of recent_projects, removes duplicates by path, truncates to 10, calls save_recent_projects().",
            "status": "done",
            "testStrategy": "Test create_project creates a valid .mop file at the specified path. Test open_project successfully opens a previously created project. Test open_project with already open project closes the previous one first. Test close_project clears current project. Test recent projects list is updated after create and open operations.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:20:15.180Z"
          },
          {
            "id": 5,
            "title": "Implement save_project and Document Arc<Mutex> Usage Pattern",
            "description": "Implement the save_project method with 'Save As' support and add comprehensive documentation showing how to wrap ProjectManager in Arc<Mutex> for thread-safe Tauri state management.",
            "dependencies": [
              4
            ],
            "details": "1) Implement save_project(&mut self, path: Option<PathBuf>) -> Result<(), MopFileError>: If current is None, return error. If path is Some, use it (Save As), otherwise use current project's mop_file.source_path (must exist for regular Save). Update config.updated_at to Utc::now(). Write config.yml to mop_file.config_path(). Call mop_file.save(&save_path). If Save As, update mop_file.source_path and add_to_recent with new path. Set current.is_modified to false. 2) Add module-level documentation in mod.rs explaining the Arc<Mutex<ProjectManager>> pattern: show example code of how to create the manager, wrap it, and pass to Tauri's .manage(). Include example of acquiring lock in async command handler with map_err for PoisonError. 3) Create a public type alias: `pub type SharedProjectManager = Arc<Mutex<ProjectManager>>;` for convenience. 4) Add a helper constructor: `pub fn new_shared() -> SharedProjectManager { Arc::new(Mutex::new(ProjectManager::new())) }` for easy initialization in main.rs. 5) Update the config module import in mod.rs to properly re-export ProjectConfig and PlcSettings if needed.",
            "status": "done",
            "testStrategy": "Test save_project returns error when no project is open. Test save_project with None path uses original source path. Test save_project with Some path saves to new location (Save As). Test is_modified is set to false after successful save. Test updated_at timestamp is updated. Test concurrent access using Arc<Mutex> wrapper with multiple threads trying to mark_modified simultaneously.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:20:15.186Z"
          }
        ],
        "updatedAt": "2026-01-27T04:20:15.186Z"
      },
      {
        "id": "6",
        "title": "Implement Tauri Commands for Project CRUD",
        "description": "Create Tauri command handlers that expose project operations to the frontend including create, open, save, and close functionality.",
        "details": "1. Create src-tauri/src/commands/project.rs:\n   ```rust\n   use tauri::State;\n   use std::sync::Mutex;\n   use crate::project::{ProjectManager, ProjectInfo, ProjectData, RecentProject};\n\n   #[tauri::command]\n   pub async fn create_project(\n       state: State<'_, Mutex<ProjectManager>>,\n       name: String,\n       path: std::path::PathBuf,\n       plc_manufacturer: String,\n       plc_model: String,\n   ) -> Result<ProjectInfo, String> {\n       let mut manager = state.lock().map_err(|e| e.to_string())?;\n       manager.create_project(name, path, PlcSettings {\n           manufacturer: plc_manufacturer.parse()?,\n           model: plc_model,\n           scan_time_ms: 10,\n       }).map_err(|e| e.to_string())\n   }\n\n   #[tauri::command]\n   pub async fn open_project(\n       state: State<'_, Mutex<ProjectManager>>,\n       path: std::path::PathBuf,\n   ) -> Result<ProjectData, String>;\n\n   #[tauri::command]\n   pub async fn save_project(\n       state: State<'_, Mutex<ProjectManager>>,\n       path: Option<std::path::PathBuf>,\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn close_project(\n       state: State<'_, Mutex<ProjectManager>>,\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn get_recent_projects(\n       state: State<'_, Mutex<ProjectManager>>,\n   ) -> Result<Vec<RecentProject>, String>;\n   ```\n2. Register commands in main.rs:\n   ```rust\n   tauri::Builder::default()\n       .manage(Mutex::new(ProjectManager::new()))\n       .invoke_handler(tauri::generate_handler![\n           create_project,\n           open_project,\n           save_project,\n           close_project,\n           get_recent_projects,\n       ])\n   ```\n3. Create src-tauri/src/commands/mod.rs to export all commands\n4. Add proper error handling with meaningful error messages",
        "testStrategy": "1. Integration test: create_project creates valid .mop file\n2. Integration test: open_project loads and returns correct data\n3. Integration test: save_project persists changes to disk\n4. Integration test: close_project cleans up state\n5. Test error responses for invalid paths, missing files\n6. Test command registration with Tauri builder",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create commands/mod.rs Module Structure and project.rs File",
            "description": "Set up the Tauri commands module structure by creating src-tauri/src/commands/mod.rs and src-tauri/src/commands/project.rs with necessary imports.",
            "dependencies": [],
            "details": "Create src-tauri/src/commands/mod.rs with `pub mod project;` to export the project commands module. Create src-tauri/src/commands/project.rs with imports: `use tauri::State; use std::sync::Mutex; use std::path::PathBuf;` and import types from the project module: `use crate::project::{ProjectManager, ProjectConfig, RecentProject}; use crate::project::config::PlcSettings;`. Ensure main.rs includes `mod commands;` declaration. The file should be prepared for adding Tauri command handlers in subsequent subtasks.",
            "status": "done",
            "testStrategy": "Run `cargo check` in src-tauri/ to verify the module structure compiles without errors. Verify both mod.rs and project.rs files exist in the commands directory.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:22:02.343Z"
          },
          {
            "id": 2,
            "title": "Implement create_project Tauri Command Handler",
            "description": "Create the #[tauri::command] handler for create_project that accepts project parameters and delegates to ProjectManager::create_project.",
            "dependencies": [
              1
            ],
            "details": "In src-tauri/src/commands/project.rs, implement: `#[tauri::command] pub async fn create_project(state: State<'_, Mutex<ProjectManager>>, name: String, path: PathBuf, plc_manufacturer: String, plc_model: String) -> Result<ProjectInfo, String>`. Inside the handler: 1) Acquire the mutex lock with `state.lock().map_err(|e| format!(\"Lock error: {}\", e))?`. 2) Parse plc_manufacturer string into PlcManufacturer enum using FromStr or match statement. 3) Create PlcSettings with manufacturer, model, and default scan_time_ms of 10. 4) Call manager.create_project(name, path, plc_settings) and map_err to String for Tauri serialization. 5) Define or import ProjectInfo struct with fields: name (String), path (PathBuf), created_at (String ISO8601). Return the ProjectInfo on success.",
            "status": "done",
            "testStrategy": "Write unit test that mocks State<Mutex<ProjectManager>> and verifies create_project correctly parses parameters and calls the manager method. Test error handling for invalid plc_manufacturer values.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:22:02.351Z"
          },
          {
            "id": 3,
            "title": "Implement open_project and close_project Tauri Commands",
            "description": "Create the #[tauri::command] handlers for open_project to load existing .mop files and close_project to clean up the current project state.",
            "dependencies": [
              1
            ],
            "details": "In src-tauri/src/commands/project.rs, implement: 1) `#[tauri::command] pub async fn open_project(state: State<'_, Mutex<ProjectManager>>, path: PathBuf) -> Result<ProjectData, String>` - Acquire lock, call manager.open_project(path), map error to String, return ProjectData containing config and optional canvas/scenario/memory data. 2) `#[tauri::command] pub async fn close_project(state: State<'_, Mutex<ProjectManager>>) -> Result<(), String>` - Acquire lock, call manager.close_project(), return Ok(()) on success. Define ProjectData struct with fields: config (ProjectConfig), canvas_data (Option<serde_json::Value>), scenario_data (Option<serde_json::Value>), memory_snapshot (Option<serde_json::Value>), is_modified (bool). Ensure all return types derive Serialize for Tauri IPC.",
            "status": "done",
            "testStrategy": "Test open_project with valid .mop file path returns correctly structured ProjectData. Test close_project clears the current project state. Test error messages are descriptive for invalid paths or missing files.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:22:02.357Z"
          },
          {
            "id": 4,
            "title": "Implement save_project and get_recent_projects Tauri Commands",
            "description": "Create the #[tauri::command] handlers for save_project with Save/Save As support and get_recent_projects to retrieve the recent projects list.",
            "dependencies": [
              1
            ],
            "details": "In src-tauri/src/commands/project.rs, implement: 1) `#[tauri::command] pub async fn save_project(state: State<'_, Mutex<ProjectManager>>, path: Option<PathBuf>) -> Result<(), String>` - Acquire lock, call manager.save_project(path) where None means save to current path and Some(path) means Save As to new path. Map errors to descriptive strings like 'No project open to save' or 'Failed to write file: {reason}'. 2) `#[tauri::command] pub async fn get_recent_projects(state: State<'_, Mutex<ProjectManager>>) -> Result<Vec<RecentProject>, String>` - Acquire lock, call manager.get_recent_projects().to_vec() to clone the list, return it. Ensure RecentProject derives Serialize with fields: name, path, last_opened (all serializable).",
            "status": "done",
            "testStrategy": "Test save_project with None path saves to original location. Test save_project with Some path performs Save As. Test get_recent_projects returns the list in correct order (most recent first). Test error when saving with no project open.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:22:02.364Z"
          },
          {
            "id": 5,
            "title": "Register Commands in main.rs with Tauri Builder",
            "description": "Update src-tauri/src/main.rs to register the ProjectManager state and all project commands with the Tauri builder invoke handler.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Update src-tauri/src/main.rs to: 1) Import commands module with `mod commands;` and bring commands into scope: `use commands::project::{create_project, open_project, save_project, close_project, get_recent_projects};`. 2) Import ProjectManager: `use crate::project::ProjectManager;` and std::sync::Mutex. 3) In the Tauri builder chain, add `.manage(Mutex::new(ProjectManager::new()))` to register the shared state. 4) Update .invoke_handler to: `tauri::generate_handler![create_project, open_project, save_project, close_project, get_recent_projects]`. 5) Ensure the builder chain includes .run() with proper error handling. Add comment indicating commands are ready for frontend invocation via @tauri-apps/api invoke.",
            "status": "done",
            "testStrategy": "Run `cargo build` to verify all commands are correctly registered and compile. Run `npm run tauri dev` to verify the application starts without command registration errors. Test invoking a command from the frontend dev console to verify IPC works.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:22:02.370Z"
          }
        ],
        "updatedAt": "2026-01-27T04:22:02.370Z"
      },
      {
        "id": "7",
        "title": "Create Frontend Project Service and Hooks",
        "description": "Implement TypeScript service layer and React hooks for invoking Tauri commands and managing project state in the frontend.",
        "details": "1. Create src/services/projectService.ts:\n   ```typescript\n   import { invoke } from '@tauri-apps/api/core';\n   import type { ProjectInfo, ProjectData, RecentProject, PlcManufacturer } from '../types/project';\n\n   export const projectService = {\n     async createProject(name: string, path: string, plcManufacturer: PlcManufacturer, plcModel: string): Promise<ProjectInfo> {\n       return invoke('create_project', { name, path, plcManufacturer, plcModel });\n     },\n\n     async openProject(path: string): Promise<ProjectData> {\n       return invoke('open_project', { path });\n     },\n\n     async saveProject(path?: string): Promise<void> {\n       return invoke('save_project', { path });\n     },\n\n     async closeProject(): Promise<void> {\n       return invoke('close_project');\n     },\n\n     async getRecentProjects(): Promise<RecentProject[]> {\n       return invoke('get_recent_projects');\n     },\n   };\n   ```\n2. Create src/hooks/useProject.ts:\n   ```typescript\n   import { useCallback } from 'react';\n   import { useProjectStore } from '../stores/projectStore';\n   import { projectService } from '../services/projectService';\n\n   export function useProject() {\n     const { currentProject, setProject, setModified, recentProjects, setRecentProjects } = useProjectStore();\n\n     const createProject = useCallback(async (...args) => {\n       const info = await projectService.createProject(...args);\n       const data = await projectService.openProject(info.path);\n       setProject(data);\n       return info;\n     }, [setProject]);\n\n     const openProject = useCallback(async (path: string) => {\n       const data = await projectService.openProject(path);\n       setProject(data);\n       await refreshRecentProjects();\n       return data;\n     }, [setProject]);\n\n     // ... save, close, etc.\n\n     return { currentProject, createProject, openProject, saveProject, closeProject, recentProjects };\n   }\n   ```\n3. Update Zustand store with proper actions and state\n4. Add error handling with toast notifications or error boundaries",
        "testStrategy": "1. Mock Tauri invoke for unit testing service layer\n2. Test hook state transitions with React Testing Library\n3. Test error handling surfaces errors to UI\n4. Integration test with actual Tauri backend\n5. Test loading states during async operations",
        "priority": "medium",
        "dependencies": [
          "2",
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create projectService.ts with Tauri Invoke Wrappers",
            "description": "Create the src/services/projectService.ts file that wraps all Tauri backend commands for project CRUD operations using the @tauri-apps/api invoke function.",
            "dependencies": [],
            "details": "Create src/services/projectService.ts with the following implementation: 1) Import invoke from '@tauri-apps/api/core' and import types from '@/types/project': ProjectInfo, ProjectData, RecentProject, PlcManufacturer. 2) Define the projectService object with async methods: createProject(name: string, path: string, plcManufacturer: PlcManufacturer, plcModel: string) calls invoke('create_project', { name, path, plc_manufacturer: plcManufacturer, plc_model: plcModel }) - note snake_case for Rust parameters. openProject(path: string) calls invoke('open_project', { path }). saveProject(path?: string) calls invoke('save_project', { path: path ?? null }). closeProject() calls invoke('close_project'). getRecentProjects() calls invoke('get_recent_projects'). 3) Export the projectService object as named export. Ensure all return types are properly typed with Promise<T> matching the TypeScript types from Task 3.5.",
            "status": "pending",
            "testStrategy": "Create a mock for @tauri-apps/api/core invoke function using vitest or jest. Test each service method calls invoke with correct command name and parameter structure. Verify parameter names use snake_case to match Rust command expectations. Test that return types are correctly inferred.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Extend Zustand projectStore with Additional Actions",
            "description": "Update the existing Zustand projectStore from Task 2.5 to add additional actions needed for the useProject hook including clearError, setCurrentProjectPath, and refreshRecentProjects placeholder.",
            "dependencies": [
              1
            ],
            "details": "Update src/stores/projectStore.ts created in Task 2.5 to add: 1) Add currentProjectPath: string | null field to track the file path of the open project separately from project data. 2) Add setCurrentProjectPath: (path: string | null) => void action. 3) Add clearError: () => void action that sets error to null. 4) Modify the setProject action to also accept an optional path parameter and call setCurrentProjectPath. 5) Add updateConfig: (config: Partial<ProjectConfig>) => void action that merges config changes and sets isModified to true. 6) Consider adding a loadingOperation: string | null field to track which operation is loading (e.g., 'create', 'open', 'save') for more granular loading states. 7) Ensure all new actions are properly typed in the ProjectStore interface. The store should work with the types defined in Task 3.5.",
            "status": "pending",
            "testStrategy": "Test setCurrentProjectPath updates the path correctly. Test clearError resets error to null. Test updateConfig merges partial config and sets isModified to true. Test setProject with path parameter updates both project and path. Verify initial state values for new fields.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement useProject Hook with Core Operations",
            "description": "Create src/hooks/useProject.ts custom React hook that combines projectService calls with Zustand store updates for create, open, save, and close project operations.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create src/hooks/useProject.ts with: 1) Import useCallback from 'react', useProjectStore from '@/stores/projectStore', and projectService from '@/services/projectService'. 2) Export function useProject() that destructures needed state and actions from useProjectStore(). 3) Implement createProject callback: set loading true, call projectService.createProject(), then call projectService.openProject(info.path) to load the created project data, update store with setProject and setCurrentProjectPath, refresh recent projects, set loading false. Wrap in try/catch to setError on failure. 4) Implement openProject callback: set loading, call projectService.openProject(path), update store with project data and path, refresh recent projects, handle errors. 5) Implement saveProject callback: set loading, call projectService.saveProject(path), set isModified to false on success, handle errors. If path provided (Save As), update currentProjectPath. 6) Implement closeProject callback: check isModified first (could return boolean indicating unsaved changes), call projectService.closeProject(), reset store state. 7) Return object with: currentProject, currentProjectPath, isModified, isLoading, error, recentProjects, and all operation callbacks.",
            "status": "pending",
            "testStrategy": "Mock projectService and useProjectStore for unit testing. Test createProject calls service then opens project and updates store. Test openProject updates store with returned data. Test saveProject with and without path parameter. Test closeProject resets store state. Test error handling sets error state and clears loading. Test loading state transitions for each operation.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Recent Projects Management to useProject Hook",
            "description": "Extend the useProject hook with refreshRecentProjects, removeFromRecentProjects functionality and initialize recent projects on hook mount using useEffect.",
            "dependencies": [
              3
            ],
            "details": "In src/hooks/useProject.ts, add: 1) Import useEffect from 'react'. 2) Implement refreshRecentProjects callback that calls projectService.getRecentProjects() and updates store with setRecentProjects. Include error handling that doesn't throw but logs to console. 3) Add useEffect that calls refreshRecentProjects() on component mount (empty dependency array) to populate recent projects when the app starts. 4) Consider adding a removeFromRecentProjects(path: string) callback - this may require a new Tauri command in the backend, so for now create a placeholder that filters the local recentProjects state (note: this won't persist without backend support). 5) Add openRecentProject(recentProject: RecentProject) convenience callback that calls openProject(recentProject.path). 6) Ensure all callbacks use useCallback with proper dependencies to prevent unnecessary re-renders. 7) Export these new functions from the hook's return object.",
            "status": "pending",
            "testStrategy": "Test refreshRecentProjects calls service and updates store. Test useEffect triggers refreshRecentProjects on mount. Test openRecentProject correctly calls openProject with the path. Test error in refreshRecentProjects is caught and logged but doesn't throw. Verify useCallback dependencies are correctly specified.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Error Handling with Toast Notification Support",
            "description": "Add comprehensive error handling to the useProject hook with user-friendly error messages and integrate with a toast notification system for surfacing errors to the UI.",
            "dependencies": [
              3
            ],
            "details": "Enhance src/hooks/useProject.ts with: 1) Create an ErrorHandler type or interface: { message: string, code?: string, recoverable?: boolean }. 2) Create a helper function formatError(error: unknown): string that handles Error objects, string errors, and Tauri command errors (which may have specific structure). Extract meaningful message from Tauri errors which come as strings from Rust. 3) Add optional onError callback parameter to useProject or use a simple toast notification pattern: create useToast hook stub in src/hooks/useToast.ts that exports showError(message: string), showSuccess(message: string) functions (implementations can be placeholder console.logs until a toast library is added in Task 8). 4) Wrap all try/catch blocks in the hook to: a) Call setError with formatted error message, b) Call showError with user-friendly message, c) Set loading to false. 5) Add specific error messages for common cases: 'Failed to create project', 'Failed to open project - file may be corrupted', 'Failed to save project', 'No project is currently open'. 6) Consider adding a retry mechanism for transient errors in saveProject. 7) Export clearError action from the hook for components to dismiss errors.",
            "status": "pending",
            "testStrategy": "Test formatError handles different error types correctly. Test each operation surfaces errors through both setError and toast (when implemented). Test specific error messages appear for known error conditions. Test clearError resets error state. Test loading state is always set to false after error. Mock console.error to verify errors are logged for debugging.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "8",
        "title": "Build Project UI Components",
        "description": "Create React components for project creation dialog, open dialog, recent projects list, and unsaved changes warning.",
        "details": "1. Create src/components/NewProjectDialog.tsx:\n   ```typescript\n   interface NewProjectDialogProps {\n     isOpen: boolean;\n     onClose: () => void;\n     onCreated: (info: ProjectInfo) => void;\n   }\n   // Form fields: project name, save path (with folder picker), PLC manufacturer dropdown, PLC model input\n   // Use @tauri-apps/plugin-dialog for native folder picker\n   ```\n2. Create src/components/OpenProjectDialog.tsx:\n   - Use native file picker filtered to .mop files\n3. Create src/components/RecentProjectsList.tsx:\n   ```typescript\n   // Display recent projects with name, path, last opened date\n   // Click to open, right-click context menu for remove from list\n   ```\n4. Create src/components/UnsavedChangesDialog.tsx:\n   - Modal warning when closing with unsaved changes\n   - Options: Save, Don't Save, Cancel\n5. Create src/components/ProjectHeader.tsx:\n   - Display current project name\n   - Asterisk (*) indicator when modified\n6. Style all components with Tailwind CSS\n7. Add keyboard shortcuts (Ctrl+N, Ctrl+O, Ctrl+S)",
        "testStrategy": "1. Unit test each component renders correctly\n2. Test form validation in NewProjectDialog\n3. Test dialog open/close state management\n4. Test keyboard shortcuts trigger correct actions\n5. E2E test complete new project flow\n6. E2E test open from recent projects",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create NewProjectDialog Component with Form and Native Folder Picker",
            "description": "Build the NewProjectDialog React component with a modal form for creating new projects, including project name input, folder path selection with native picker, PLC manufacturer dropdown, and PLC model input field.",
            "dependencies": [],
            "details": "Create src/components/NewProjectDialog.tsx with the following implementation: 1) Define interface NewProjectDialogProps with isOpen, onClose, onCreated callbacks. 2) Import open from '@tauri-apps/plugin-dialog' for native folder picker. 3) Build form state using useState for: projectName (string), savePath (string), plcManufacturer (PlcManufacturer type: 'LS' | 'Mitsubishi' | 'Siemens'), plcModel (string). 4) Create selectFolder async handler that calls open({ directory: true, title: 'Select Project Folder' }) and updates savePath state. 5) Add form validation: projectName required and non-empty, savePath required, plcManufacturer required. 6) Create handleSubmit that calls useProject().createProject with form values, then calls onCreated callback with the result. 7) Style with Tailwind CSS: modal overlay with backdrop blur, centered dialog box with rounded corners, form layout with labels above inputs, primary/secondary button styling. 8) Include Cancel and Create buttons with proper disabled states during submission. 9) Add loading state with spinner during project creation.",
            "status": "pending",
            "testStrategy": "Unit test component renders with isOpen=true. Test form validation prevents submission with empty fields. Test selectFolder updates savePath state. Mock @tauri-apps/plugin-dialog and verify open is called with correct options. Test onCreated callback receives project info after successful creation. Test onClose is called when Cancel is clicked.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create OpenProjectDialog and UnsavedChangesDialog Components",
            "description": "Build the OpenProjectDialog component using native file picker filtered to .mop files, and the UnsavedChangesDialog modal component that warns users when closing with unsaved changes offering Save, Don't Save, and Cancel options.",
            "dependencies": [
              1
            ],
            "details": "Create two components: 1) src/components/OpenProjectDialog.tsx: Simple wrapper that calls the native file picker immediately when triggered. Import open from '@tauri-apps/plugin-dialog'. Create async openProjectPicker function that calls open({ filters: [{ name: 'ModOne Project', extensions: ['mop'] }], multiple: false, title: 'Open Project' }). If user selects a file, call useProject().openProject(selectedPath). This component may not need visible UI - it can be a hook or trigger function. Consider creating useOpenProjectDialog hook that returns { openPicker: () => Promise<void> }. 2) src/components/UnsavedChangesDialog.tsx: Interface with isOpen, onSave, onDontSave, onCancel props. Modal with warning icon (exclamation triangle), message 'You have unsaved changes. Do you want to save before closing?', and three buttons: 'Save' (primary), 'Don't Save' (secondary/danger), 'Cancel' (tertiary). Style with Tailwind: warning/destructive color scheme, clear button hierarchy. Add isLoading state for Save button during save operation.",
            "status": "pending",
            "testStrategy": "Test OpenProjectDialog triggers native picker with correct .mop filter. Mock dialog plugin and verify file selection calls openProject. Test UnsavedChangesDialog renders all three buttons. Test each button calls its respective callback. Test isOpen false hides the dialog. Test Save button shows loading state during save.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create RecentProjectsList Component with Context Menu",
            "description": "Build the RecentProjectsList component that displays recent projects with name, path, and last opened date, featuring click-to-open functionality and a right-click context menu for removing items from the list.",
            "dependencies": [],
            "details": "Create src/components/RecentProjectsList.tsx: 1) Define interface RecentProjectsListProps with optional onProjectOpen callback. 2) Use useProject() hook to get recentProjects array and openProject function. 3) Create list rendering with each item showing: project name (bold), truncated file path with ellipsis, relative time since last opened (e.g., '2 hours ago', 'Yesterday'). Consider using date-fns formatDistanceToNow or similar. 4) Add onClick handler for each item that calls openProject(project.path). 5) Implement right-click context menu using custom state management: onContextMenu handler sets contextMenuPosition {x, y} and selectedProject, render absolutely positioned menu with 'Open' and 'Remove from list' options. 6) Add click-outside handler to close context menu. 7) Style with Tailwind: list items with hover state (bg-gray-100), selected state for context menu target, context menu with shadow and rounded corners, proper spacing and typography. 8) Show empty state message 'No recent projects' when list is empty. 9) Add subtle animations for list item hover and context menu appearance.",
            "status": "pending",
            "testStrategy": "Test component renders empty state when no recent projects. Test component renders project items with correct information. Test click on item calls openProject with correct path. Test right-click opens context menu at mouse position. Test clicking outside closes context menu. Test Remove from list option triggers removal (or placeholder action). Test relative time display is correct.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create ProjectHeader Component with Modified Indicator",
            "description": "Build the ProjectHeader component that displays the current project name with an asterisk indicator when there are unsaved modifications, styled to fit in the application header area.",
            "dependencies": [],
            "details": "Create src/components/ProjectHeader.tsx: 1) Use useProject() hook or useProjectStore() directly to access currentProject and isModified state. 2) Render project name from currentProject?.config?.project?.name or show 'No Project Open' when null. 3) Conditionally append asterisk (*) after project name when isModified is true: '{projectName}*'. 4) Style with Tailwind: appropriate font size for header (text-lg or text-xl), font weight (font-medium), proper text color contrasting with header background. 5) Consider adding subtle transition/animation when modified state changes. 6) Add optional onClick prop for potential 'project info' action. 7) Add tooltip on hover showing full project path if a project is open. 8) Consider responsive behavior - truncate long project names with ellipsis. 9) Export component with proper TypeScript typing. This component should be simple and focused - it's a display component with minimal logic.",
            "status": "pending",
            "testStrategy": "Test component shows 'No Project Open' when currentProject is null. Test component displays project name when project is open. Test asterisk appears when isModified is true. Test asterisk disappears when isModified is false. Test tooltip shows project path on hover. Test truncation works for long project names.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Global Keyboard Shortcuts for Project Operations",
            "description": "Add global keyboard shortcuts (Ctrl+N for new project, Ctrl+O for open project, Ctrl+S for save project) using React event listeners that trigger the corresponding project operations and dialog openings.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create src/hooks/useKeyboardShortcuts.ts: 1) Import necessary hooks and the useProject hook. 2) Accept configuration object with callbacks: onNewProject, onOpenProject, onSaveProject. 3) Use useEffect to add 'keydown' event listener to document. 4) In handler, check for key combinations: (e.ctrlKey || e.metaKey) && e.key === 'n' for Ctrl+N/Cmd+N, similarly for 'o' and 's'. 5) Call e.preventDefault() to prevent browser default behavior (e.g., Ctrl+S saving page). 6) Call the appropriate callback based on detected shortcut. 7) Return cleanup function that removes event listener. 8) Create src/hooks/useProjectShortcuts.ts that uses useKeyboardShortcuts with project-specific implementations: Ctrl+N opens NewProjectDialog (requires managing dialog state), Ctrl+O triggers openPicker, Ctrl+S calls saveProject if project is open. 9) Alternative: Create a ProjectShortcutsProvider component that wraps the app and provides this functionality via context. 10) Consider adding Ctrl+Shift+S for 'Save As' functionality. 11) Add visual indicator in menus/buttons showing keyboard shortcuts (e.g., 'New Project (Ctrl+N)').",
            "status": "pending",
            "testStrategy": "Test useKeyboardShortcuts hook adds event listener on mount and removes on unmount. Test Ctrl+N fires onNewProject callback. Test Ctrl+O fires onOpenProject callback. Test Ctrl+S fires onSaveProject callback. Test Cmd key works on Mac (metaKey). Test preventDefault is called to stop browser default. Test shortcuts don't fire when input fields are focused (optional - may need refinement). Integration test shortcuts work in the actual app context.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "9",
        "title": "Implement Auto-Save Functionality",
        "description": "Add automatic project saving with configurable interval, backup file creation, and recovery from interrupted saves.",
        "details": "1. Add auto-save configuration to ProjectConfig:\n   ```rust\n   pub struct AutoSaveSettings {\n       pub enabled: bool,\n       pub interval_secs: u64,  // default: 300 (5 minutes)\n       pub backup_count: u32,   // default: 3\n   }\n   ```\n2. Create src-tauri/src/project/auto_save.rs:\n   ```rust\n   use tokio::time::{interval, Duration};\n   use tokio::sync::mpsc;\n\n   pub struct AutoSaveManager {\n       interval: Duration,\n       enabled: bool,\n       cancel_tx: Option<mpsc::Sender<()>>,\n   }\n\n   impl AutoSaveManager {\n       pub fn start(&mut self, project_manager: Arc<Mutex<ProjectManager>>);\n       pub fn stop(&mut self);\n       pub fn update_interval(&mut self, secs: u64);\n       \n       async fn auto_save_loop(\n           manager: Arc<Mutex<ProjectManager>>,\n           interval: Duration,\n           mut cancel_rx: mpsc::Receiver<()>\n       );\n       \n       fn create_backup(path: &Path) -> Result<(), MopFileError>;\n   }\n   ```\n3. Create backup files with naming scheme: `project.mop.bak`, `project.mop.bak.1`, `project.mop.bak.2`\n4. Rotate backup files keeping only configured count\n5. Add Tauri commands for auto-save configuration:\n   ```rust\n   #[tauri::command]\n   async fn set_auto_save_enabled(enabled: bool) -> Result<(), String>;\n   \n   #[tauri::command]\n   async fn set_auto_save_interval(secs: u64) -> Result<(), String>;\n   ```\n6. Integrate with frontend settings UI\n7. Show subtle notification when auto-save occurs",
        "testStrategy": "1. Unit test backup file rotation logic\n2. Test auto-save triggers after configured interval\n3. Test auto-save disabled when no project open\n4. Test backup file recovery scenario\n5. Test stop/start when interval changes\n6. Integration test auto-save creates valid .mop file",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define AutoSaveSettings Struct and Integrate into ProjectConfig",
            "description": "Create the AutoSaveSettings struct in config.rs with enabled, interval_secs, and backup_count fields, and add it to the existing ProjectConfig structure.",
            "dependencies": [],
            "details": "In src-tauri/src/project/config.rs, add the AutoSaveSettings struct: `pub struct AutoSaveSettings { pub enabled: bool, pub interval_secs: u64, pub backup_count: u32 }`. Derive Serialize, Deserialize, Clone, Debug. Implement Default trait with enabled=true, interval_secs=300 (5 minutes), backup_count=3. Add `pub auto_save: AutoSaveSettings` field to ProjectConfig struct. Update ProjectConfig's Default implementation to include AutoSaveSettings::default(). Use #[serde(rename_all = \"snake_case\")] for YAML field naming consistency. Add corresponding TypeScript interface to src/types/project.ts: `interface AutoSaveSettings { enabled: boolean; interval_secs: number; backup_count: number; }`.",
            "status": "done",
            "testStrategy": "Unit test AutoSaveSettings::default() returns correct values (enabled=true, interval_secs=300, backup_count=3). Test YAML serialization/deserialization roundtrip preserves all values. Verify ProjectConfig with auto_save field serializes to valid YAML matching schema. TypeScript compilation should pass without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:33:54.661Z"
          },
          {
            "id": 2,
            "title": "Create AutoSaveManager Struct with Lifecycle Control",
            "description": "Implement src-tauri/src/project/auto_save.rs with AutoSaveManager struct that controls auto-save loop lifecycle using tokio async runtime and mpsc channels for start/stop/update operations.",
            "dependencies": [
              1
            ],
            "details": "Create src-tauri/src/project/auto_save.rs with imports: tokio::time::{interval, Duration}, tokio::sync::mpsc, std::sync::{Arc, Mutex}. Define AutoSaveManager struct with fields: interval (Duration), enabled (bool), cancel_tx (Option<mpsc::Sender<()>>), is_running (bool). Implement: new(settings: &AutoSaveSettings) -> Self constructor initializing from settings. start(&mut self, project_manager: Arc<Mutex<ProjectManager>>) creates mpsc::channel(1), stores sender in cancel_tx, spawns auto_save_loop as tokio::spawn task, sets is_running=true. If already running, call stop() first. stop(&mut self) sends () via cancel_tx if Some, sets is_running=false, clears cancel_tx to None. update_interval(&mut self, secs: u64, manager: Arc<Mutex<ProjectManager>>) updates interval and restarts if running. update_enabled(&mut self, enabled: bool). Export from project/mod.rs with `pub mod auto_save;`.",
            "status": "done",
            "testStrategy": "Test new() creates manager with correct interval from settings. Test start() sets is_running=true and creates cancel channel. Test stop() sends cancel signal and sets is_running=false. Test calling start() when already running stops previous loop. Test update_interval restarts the loop with new duration.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:33:54.668Z"
          },
          {
            "id": 3,
            "title": "Implement Auto-Save Loop and Backup File Rotation Logic",
            "description": "Create the core async auto_save_loop function that periodically saves the project when modified, and implement backup file rotation maintaining configurable number of backup copies with .mop.bak naming scheme.",
            "dependencies": [
              2
            ],
            "details": "In auto_save.rs, implement: async fn auto_save_loop(manager: Arc<Mutex<ProjectManager>>, interval_duration: Duration, mut cancel_rx: mpsc::Receiver<()>, backup_count: u32, app_handle: tauri::AppHandle) using tokio::select! to wait for either interval.tick() or cancel_rx.recv(). On tick: acquire lock, check if project open and is_modified=true, if so get source_path, call create_backup before save, then call save_project(None), emit 'auto-save-completed' event via app_handle. fn create_backup(project_path: &Path, backup_count: u32) -> Result<(), MopFileError>: rotate backups by iterating from backup_count-1 down to 0, renaming .bak.N to .bak.(N+1), then .bak to .bak.1 if exists, finally copy current file to .bak. Delete oldest backup exceeding count using fs::remove_file. Use std::fs::copy and std::fs::rename. Handle missing files gracefully with match on fs::metadata. Log operations for debugging.",
            "status": "done",
            "testStrategy": "Unit test backup rotation: create project.mop and existing .bak files, run create_backup, verify files renamed correctly. Test backup_count=3 keeps only 3 backups. Test auto_save_loop triggers save after interval with modified project. Test loop exits on cancel signal. Test no save when is_modified=false. Test no action when no project open.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:33:54.674Z"
          },
          {
            "id": 4,
            "title": "Add Tauri Commands for Auto-Save Configuration",
            "description": "Create Tauri command handlers for getting and setting auto-save settings (enabled, interval, backup_count), register AutoSaveManager as managed state, and integrate with ProjectManager.",
            "dependencies": [
              3
            ],
            "details": "In src-tauri/src/commands/project.rs add: #[tauri::command] async fn get_auto_save_settings(state: State<'_, Mutex<ProjectManager>>) -> Result<AutoSaveSettings, String> returning current settings from open project config or defaults. #[tauri::command] async fn set_auto_save_enabled(manager_state: State<'_, Mutex<ProjectManager>>, auto_save_state: State<'_, Mutex<AutoSaveManager>>, enabled: bool) -> Result<(), String> updating config and calling update_enabled. #[tauri::command] async fn set_auto_save_interval(manager_state: State<'_, Mutex<ProjectManager>>, auto_save_state: State<'_, Mutex<AutoSaveManager>>, secs: u64) -> Result<(), String> with validation (minimum 30 seconds). #[tauri::command] async fn set_backup_count(state: State<'_, Mutex<ProjectManager>>, count: u32) -> Result<(), String> with validation (1-10 range). Update main.rs: add .manage(Mutex::new(AutoSaveManager::new(&AutoSaveSettings::default()))) and register all commands in invoke_handler. Start auto-save when project opens, stop when closes.",
            "status": "done",
            "testStrategy": "Test get_auto_save_settings returns correct configuration. Test set_auto_save_enabled updates config and manager state. Test set_auto_save_interval rejects values below 30 seconds. Test set_backup_count rejects values outside 1-10 range. Verify commands registered without compilation errors. Test auto-save starts on project open and stops on close.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:33:54.680Z"
          },
          {
            "id": 5,
            "title": "Create Frontend Auto-Save Integration and Notification UI",
            "description": "Implement frontend service methods, useAutoSave hook for settings management, and a subtle toast notification component that displays when auto-save completes successfully.",
            "dependencies": [
              4
            ],
            "details": "Add to src/services/projectService.ts: getAutoSaveSettings(), setAutoSaveEnabled(enabled: boolean), setAutoSaveInterval(secs: number), setBackupCount(count: number) calling invoke with snake_case params. Create src/hooks/useAutoSave.ts exporting useAutoSave() hook that: fetches settings on mount with useEffect, provides updateEnabled/updateInterval/updateBackupCount functions, manages local state synced with backend, subscribes to 'auto-save-completed' event using listen from @tauri-apps/api/event. Create src/components/AutoSaveNotification.tsx: subtle toast positioned bottom-right with 'Project auto-saved' message and timestamp, uses useState for visibility, useEffect with 3-second setTimeout for auto-dismiss, Tailwind styling: bg-green-50 border-green-200 text-green-800, rounded-lg shadow-lg, animate-fade-in-out. Hook triggers notification visibility when event received. Export all for use in settings UI.",
            "status": "done",
            "testStrategy": "Test service methods call correct Tauri commands with proper snake_case parameters. Test useAutoSave hook fetches settings on mount. Test hook subscribes to auto-save-completed event. Test AutoSaveNotification renders when visible=true and auto-hides after 3 seconds. Test notification shows timestamp. Integration test: enable auto-save, modify project, wait for interval, verify notification appears and backup file created.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:34:57.354Z"
          }
        ],
        "updatedAt": "2026-01-27T04:34:57.354Z"
      },
      {
        "id": "10",
        "title": "Add Error Handling and Validation",
        "description": "Implement comprehensive error handling for corrupted files, invalid configurations, and provide user-friendly error messages with recovery options.",
        "details": "1. Create src-tauri/src/error.rs with unified error types:\n   ```rust\n   use thiserror::Error;\n\n   #[derive(Error, Debug, Serialize)]\n   #[serde(tag = \"type\", content = \"message\")]\n   pub enum ModOneError {\n       #[error(\"Project not found: {0}\")]\n       ProjectNotFound(String),\n       \n       #[error(\"Invalid .mop file: {0}\")]\n       InvalidMopFile(String),\n       \n       #[error(\"Configuration error: {0}\")]\n       ConfigError(String),\n       \n       #[error(\"IO error: {0}\")]\n       IoError(String),\n       \n       #[error(\"Project already open, close first\")]\n       ProjectAlreadyOpen,\n       \n       #[error(\"No project open\")]\n       NoProjectOpen,\n   }\n   ```\n2. Add validation to config.yml loading:\n   - Validate port ranges (0-65535)\n   - Validate memory map sizes and ranges\n   - Validate PLC manufacturer/model combinations\n3. Create recovery options for corrupted files:\n   - Attempt to extract readable portions\n   - Offer to open backup file if available\n4. Create src/components/ErrorBoundary.tsx for React error handling\n5. Create src/components/ErrorDialog.tsx for displaying errors:\n   ```typescript\n   interface ErrorDialogProps {\n     error: ModOneError;\n     onRetry?: () => void;\n     onIgnore?: () => void;\n     onClose: () => void;\n   }\n   ```\n6. Add frontend error type definitions matching Rust errors\n7. Implement error logging to file for debugging",
        "testStrategy": "1. Test each error type can be serialized to frontend\n2. Test corrupted ZIP file triggers InvalidMopFile error\n3. Test missing config.yml triggers appropriate error\n4. Test invalid config values caught by validation\n5. Test error dialog displays correct message and options\n6. Test recovery from backup file works\n7. E2E test error handling user flow",
        "priority": "medium",
        "dependencies": [
          "4",
          "6",
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Unified ModOneError Type in error.rs",
            "description": "Create src-tauri/src/error.rs with a comprehensive ModOneError enum using thiserror for error derivation and serde for frontend serialization, covering all project operation failure cases.",
            "dependencies": [],
            "details": "Create the error.rs module with the following implementation:\n\n1. Define ModOneError enum with thiserror and serde derives:\n   - #[derive(Error, Debug, Serialize)] with #[serde(tag = \"type\", content = \"message\")]\n   - ProjectNotFound(String) - when project path doesn't exist\n   - InvalidMopFile(String) - for corrupted/invalid ZIP archives\n   - ConfigError(String) - for YAML parsing failures\n   - ConfigValidationError { field: String, message: String } - for validation failures\n   - IoError(String) - for filesystem operations\n   - ProjectAlreadyOpen - when trying to open without closing current\n   - NoProjectOpen - for save/close without open project\n   - BackupNotFound - when recovery attempted but no backup exists\n   - RecoveryFailed(String) - when backup recovery fails\n\n2. Implement From traits for underlying error types:\n   - impl From<std::io::Error> for ModOneError\n   - impl From<zip::result::ZipError> for ModOneError\n   - impl From<serde_yaml::Error> for ModOneError\n\n3. Create type alias: pub type ModOneResult<T> = Result<T, ModOneError>\n\n4. Export the module in src-tauri/src/lib.rs or main.rs:\n   - pub mod error;\n   - pub use error::{ModOneError, ModOneResult};",
            "status": "pending",
            "testStrategy": "Write unit tests verifying each error variant serializes to correct JSON with type/message structure. Test From implementations convert underlying errors correctly. Verify error messages are user-friendly and descriptive. Test ModOneResult type alias works with all error variants.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Configuration Validation Functions",
            "description": "Add comprehensive validation functions to the config module that validate port ranges, memory map settings, PLC manufacturer/model combinations, and all numeric bounds before accepting configuration values.",
            "dependencies": [
              1
            ],
            "details": "Create validation module and functions in src-tauri/src/project/validation.rs:\n\n1. Define ValidationError type that collects multiple validation issues:\n   - pub struct ValidationResult { errors: Vec<(String, String)> } // (field, message)\n   - impl ValidationResult with is_valid(), add_error(), to_config_error() methods\n\n2. Implement individual validators:\n   - validate_port(port: u16, field: &str) -> Option<String> - ensures 0-65535 range\n   - validate_baud_rate(rate: u32) - accepts standard values: 9600, 19200, 38400, 57600, 115200\n   - validate_memory_range(start: u16, count: u16, field: &str) - checks for overflow (start + count <= 65535)\n   - validate_scan_time(ms: u32) - ensures reasonable range (10-10000ms)\n   - validate_timeout(ms: u32) - ensures reasonable range (100-60000ms)\n\n3. Create composite validator:\n   - pub fn validate_project_config(config: &ProjectConfig) -> ModOneResult<()>\n   - Validates all fields and returns ConfigValidationError with aggregated messages if invalid\n\n4. Integrate validation into config loading:\n   - Call validate_project_config() in ProjectConfig::load() before returning\n   - Return ConfigValidationError on validation failure instead of silently accepting bad values\n\n5. Add validation to MopFile::open() flow to catch invalid configs early",
            "status": "pending",
            "testStrategy": "Unit test each validator with valid boundary values, invalid values, and edge cases. Test validate_port rejects 65536. Test memory_map validates start+count overflow. Test baud_rate accepts all standard values. Test validate_config aggregates errors properly. Integration test that opening project with invalid config returns ConfigValidationError.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Corrupted File Recovery and Backup Detection",
            "description": "Create recovery utilities that detect available backup files, attempt to extract readable portions from corrupted .mop files, and provide options to recover from the most recent valid backup.",
            "dependencies": [
              1
            ],
            "details": "Create src-tauri/src/project/recovery.rs with recovery utilities:\n\n1. Implement backup discovery:\n   - pub fn find_backups(mop_path: &Path) -> Vec<BackupInfo>\n   - BackupInfo { path: PathBuf, timestamp: DateTime<Utc>, size: u64 }\n   - Search for .mop.bak, .mop.bak.1, .mop.bak.2, etc.\n   - Sort by modification time (most recent first)\n\n2. Implement .mop file integrity validation:\n   - pub fn validate_mop_integrity(path: &Path) -> MopIntegrityResult\n   - MopIntegrityResult { is_valid: bool, has_config: bool, has_modone_dir: bool, readable_files: Vec<String>, errors: Vec<String> }\n   - Check ZIP file can be opened\n   - Verify required structure (modone/ directory, config.yml)\n   - List which files are readable vs corrupted\n\n3. Implement partial recovery:\n   - pub fn attempt_partial_recovery(corrupted_path: &Path, output_dir: &Path) -> RecoveryResult\n   - Try to extract as many valid entries as possible from corrupted ZIP\n   - RecoveryResult { recovered_files: Vec<String>, failed_files: Vec<String>, created_default_config: bool }\n   - Create default config.yml if original is corrupted\n\n4. Implement backup recovery:\n   - pub fn recover_from_backup(backup_path: &Path, target_path: &Path) -> ModOneResult<()>\n   - Validate backup integrity before copying\n   - Copy backup to target location\n\n5. Add Tauri commands for recovery operations:\n   - #[tauri::command] get_available_backups(path: String)\n   - #[tauri::command] recover_project_from_backup(backup_path: String, target_path: String)",
            "status": "pending",
            "testStrategy": "Create test .mop files with various corruption types: missing files, invalid ZIP header, valid ZIP but missing config.yml. Test find_backups returns correct files in order. Test partial_recovery extracts what's possible from partially corrupted ZIP. Test recover_from_backup successfully restores from valid backup. Test validate_mop_integrity catches all required structure issues.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create React Error Boundary and ErrorDialog Components",
            "description": "Implement src/components/ErrorBoundary.tsx for catching React render errors and src/components/ErrorDialog.tsx for displaying ModOne-specific errors with retry, ignore, and recovery options.",
            "dependencies": [
              1
            ],
            "details": "Create React error handling components:\n\n1. Create src/types/error.ts with frontend error types:\n   - Mirror Rust ModOneError enum as TypeScript discriminated union\n   - type ModOneError = { type: 'ProjectNotFound', message: string } | { type: 'InvalidMopFile', message: string } | ... etc.\n   - Create helper function isRecoverableError(error: ModOneError): boolean\n   - Create helper function getErrorTitle(error: ModOneError): string\n\n2. Create src/components/ErrorBoundary.tsx:\n   - Class component extending React.Component<Props, State>\n   - Implement getDerivedStateFromError and componentDidCatch\n   - Render fallback UI with error message and 'Reload Application' button\n   - Accept optional onError callback prop for logging\n   - Style with Tailwind for consistent look\n\n3. Create src/components/ErrorDialog.tsx:\n   - Props: { error: ModOneError | null, onRetry?: () => void, onIgnore?: () => void, onClose: () => void, onOpenBackup?: () => void }\n   - Modal dialog using Tailwind styling\n   - Display error type as title, message as content\n   - Show 'Retry' button if onRetry provided\n   - Show 'Ignore' button if onIgnore provided\n   - Show 'Open Backup' button for InvalidMopFile errors when onOpenBackup provided\n   - Always show 'Close' button\n\n4. Create src/hooks/useErrorHandler.ts:\n   - Custom hook managing error dialog state\n   - showError(error: ModOneError), clearError()\n   - Listen for Tauri 'modone-error' events\n   - Return { currentError, showError, clearError, ErrorDialogProps }",
            "status": "pending",
            "testStrategy": "Test ErrorBoundary catches errors thrown by child components. Test fallback UI renders with error message. Test ErrorDialog renders correct buttons based on error type. Test onRetry/onIgnore/onClose callbacks fire when clicked. Test ConfigValidationError shows field name. Test InvalidMopFile error shows 'Open Backup' option.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Error Logging Service and Tauri Event Integration",
            "description": "Create file-based error logging in the Rust backend and integrate error propagation to frontend using Tauri events, enabling persistent debugging logs and real-time error notifications.",
            "dependencies": [
              1,
              4
            ],
            "details": "Create error logging and event system:\n\n1. Create src-tauri/src/logging.rs:\n   - pub fn initialize_logging(app_handle: &AppHandle) -> ModOneResult<()>\n   - Create logs directory in app data path\n   - Configure file-based logging with rotation (keep last 5 log files, max 10MB each)\n   - Use tracing or log crate for structured logging\n\n2. Implement error logging functions:\n   - pub fn log_error(error: &ModOneError, context: &str)\n   - Write JSON-formatted log entries: { timestamp, level, error_type, message, context }\n   - Include stack trace when available\n\n3. Create Tauri error event emission:\n   - Modify Tauri commands to emit 'modone-error' event on failures\n   - Event payload: { error: ModOneError, command: String, timestamp: String }\n   - Use app_handle.emit(\"modone-error\", payload)\n\n4. Add logging commands:\n   - #[tauri::command] get_log_path() -> String\n   - #[tauri::command] get_recent_errors() -> Vec<LogEntry>\n   - #[tauri::command] clear_logs()\n\n5. Update existing Tauri commands to use new error handling:\n   - Wrap all command results with error logging\n   - Emit error events before returning Err\n   - Use context strings to identify which operation failed\n\n6. Frontend integration:\n   - Update useErrorHandler to listen for 'modone-error' events\n   - Automatically display ErrorDialog when error event received\n   - Add 'View Logs' button in ErrorDialog that calls get_log_path and opens in file explorer",
            "status": "pending",
            "testStrategy": "Test initialize_logging creates log directory and file. Test log_error writes properly formatted JSON entries. Test Tauri commands emit error events on failure. Test useErrorHandler receives events and updates state. Test openLogs command returns correct path. Integration test: trigger error, verify logged to file and displayed in UI.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "11",
        "title": "Create Main Application Shell with Menu Bar and Toolbar",
        "description": "Implement VSCode-style main application shell with MenuBar, Toolbar, and StatusBar components providing complete application chrome.",
        "details": "1. Create `src/components/layout/MainLayout.tsx` as the root layout component with CSS Grid structure:\n   ```typescript\n   // Grid layout: activity-bar | sidebar | main-content\n   // With header row for menu/toolbar and footer for status bar\n   ```\n\n2. Implement `src/components/layout/MenuBar.tsx`:\n   - File menu: New Project (Ctrl+N), Open Project (Ctrl+O), Save (Ctrl+S), Save As (Ctrl+Shift+S), Recent Projects submenu, Exit\n   - Edit menu: Undo (Ctrl+Z), Redo (Ctrl+Y), Cut/Copy/Paste, Preferences\n   - View menu: Toggle Sidebar (Ctrl+B), Toggle Panel submenu, Reset Layout, Zoom In/Out\n   - Simulation menu: Start (F5), Stop (Shift+F5), Pause (F6), Step (F10), Reset\n   - Modbus menu: Server Settings, Start Server, Stop Server, Connection Status\n   - Help menu: Documentation, About\n   - Use React state for menu open/close state\n   - Keyboard shortcut handling integration with useKeyboardShortcuts from Task 8\n\n3. Implement `src/components/layout/Toolbar.tsx`:\n   - Project group: New, Open, Save icons with tooltips\n   - Simulation group: Play, Pause, Stop, Step icons with disabled states\n   - View group: Panel toggle buttons for each panel type\n   - Use icon library (lucide-react or similar)\n   - Tailwind styling with hover/active states\n\n4. Implement `src/components/layout/StatusBar.tsx`:\n   - Left section: Simulation status indicator (Running/Stopped/Paused) with colored dot\n   - Center section: Scan time display (e.g., '10ms')\n   - Right section: Modbus connection status (TCP:502 Connected/Disconnected)\n   - Right section: Memory usage indicator (percentage or MB)\n   - Fixed height (24px), border-top separator\n\n5. Create `src/stores/layoutStore.ts` with Zustand:\n   ```typescript\n   interface LayoutStore {\n     menuOpen: string | null; // Currently open menu\n     simulationStatus: 'running' | 'stopped' | 'paused';\n     scanTime: number;\n     modbusConnected: boolean;\n     setMenuOpen: (menu: string | null) => void;\n     // ... other actions\n   }\n   ```",
        "testStrategy": "1. Unit test MenuBar renders all menu items with correct labels\n2. Test keyboard shortcuts trigger correct menu actions (mock handlers)\n3. Test StatusBar updates simulation status indicator color based on state\n4. Test Toolbar buttons have correct disabled states based on project/simulation state\n5. E2E test menu navigation: click File > New Project opens dialog\n6. Test menu closes when clicking outside",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create MainLayout Component with CSS Grid Structure",
            "description": "Implement the root layout component src/components/layout/MainLayout.tsx using CSS Grid to define the application shell structure with header, activity-bar, sidebar, main-content, and footer areas.",
            "dependencies": [],
            "details": "Create src/components/layout/MainLayout.tsx with a CSS Grid layout that defines the full application structure. The grid should have: 1) Grid template rows: auto (menu/toolbar header), 1fr (main content area), auto (status bar footer). 2) Grid template columns: auto (activity bar ~48px), auto (sidebar ~250px resizable), 1fr (main content). 3) Use Tailwind CSS classes for styling: h-screen, w-screen, overflow-hidden for the root container. 4) Define grid-template-areas for named regions: 'header header header' / 'activity sidebar main' / 'footer footer footer'. 5) Create placeholder div elements for each grid area with appropriate grid-area assignments. 6) Accept children prop for main content area. 7) Import and render MenuBar in header row, StatusBar in footer row. 8) Export MainLayout as the primary layout wrapper for the application. 9) Add dark mode support with bg-gray-900 for dark and bg-white for light themes. 10) Ensure the layout fills the viewport completely without scrolling on the main container.",
            "status": "done",
            "testStrategy": "Verify MainLayout renders without errors. Test that CSS Grid creates the expected structure by checking computed styles. Test that children are rendered in the main content area. Verify the layout fills the viewport (h-screen, w-screen). Test with React Testing Library that all grid areas are present and accessible.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:27:22.666Z"
          },
          {
            "id": 2,
            "title": "Implement MenuBar Component with Dropdown Menus and Keyboard Shortcuts",
            "description": "Create src/components/layout/MenuBar.tsx implementing a VSCode-style menu bar with File, Edit, View, Simulation, Modbus, and Help menus, including dropdown functionality and keyboard shortcut display.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/layout/MenuBar.tsx with: 1) Define menu structure as data: menus array with label, items (each item has label, shortcut?, action?, submenu?, separator?, disabled?). 2) File menu items: New Project (Ctrl+N), Open Project (Ctrl+O), separator, Save (Ctrl+S), Save As (Ctrl+Shift+S), separator, Recent Projects (submenu), separator, Exit. 3) Edit menu: Undo (Ctrl+Z), Redo (Ctrl+Y), separator, Cut (Ctrl+X), Copy (Ctrl+C), Paste (Ctrl+V), separator, Preferences. 4) View menu: Toggle Sidebar (Ctrl+B), Toggle Panel (submenu with Output, Problems, Terminal), separator, Reset Layout, separator, Zoom In (Ctrl++), Zoom Out (Ctrl+-). 5) Simulation menu: Start (F5), Stop (Shift+F5), Pause (F6), Step (F10), separator, Reset. 6) Modbus menu: Server Settings, separator, Start Server, Stop Server, separator, Connection Status. 7) Help menu: Documentation, separator, About. 8) Use useState for openMenu tracking which menu is open. 9) Implement click-to-open, click-outside-to-close using useEffect with document event listener. 10) Style with Tailwind: h-8 fixed header bar, hover states on menu items, dropdown with shadow-lg and border. 11) Display keyboard shortcuts right-aligned in menu items with text-gray-500. 12) Use layoutStore.setMenuOpen for state management integration.",
            "status": "done",
            "testStrategy": "Test that MenuBar renders all top-level menu labels (File, Edit, View, etc.). Test clicking a menu item opens the dropdown. Test clicking outside closes the dropdown. Test that keyboard shortcuts are displayed correctly. Test that menu items have correct disabled states based on project state. Test submenu rendering for Recent Projects and Toggle Panel.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:27:22.675Z"
          },
          {
            "id": 3,
            "title": "Implement Toolbar Component with Icon Button Groups",
            "description": "Create src/components/layout/Toolbar.tsx with grouped icon buttons for project operations, simulation controls, and view toggles using lucide-react icons with tooltips and proper disabled states.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/layout/Toolbar.tsx: 1) Install lucide-react for icons: npm install lucide-react. 2) Import icons: FileIcon, FolderOpen, Save, Play, Pause, Square, StepForward, PanelLeft, PanelBottom, PanelRight from lucide-react. 3) Create ToolbarButton component: button with icon, tooltip on hover (using title attribute or custom tooltip component), disabled prop styling (opacity-50, cursor-not-allowed), hover state (bg-gray-200 dark:bg-gray-700), consistent size (w-8 h-8), flex center alignment. 4) Create ToolbarSeparator component: vertical divider (h-6 w-px bg-gray-300 mx-1). 5) Group buttons with ToolbarSeparators: Project group (New, Open, Save), Simulation group (Play, Pause, Stop, Step), View group (toggle panels). 6) Project buttons disabled when appropriate (Save disabled if !isModified). 7) Simulation buttons disabled based on simulationStatus from layoutStore (Play disabled when running, Stop disabled when stopped, etc.). 8) Use Zustand store to read simulation status and toggle panel visibility. 9) Style toolbar: h-10, border-b, flex items-center, px-2, gap-1. 10) Add tooltips showing button name and keyboard shortcut.",
            "status": "done",
            "testStrategy": "Test Toolbar renders all button groups. Test ToolbarButton hover and disabled states apply correct CSS classes. Test clicking enabled buttons triggers onClick handlers. Test disabled buttons do not trigger onClick. Test tooltips appear on hover (if custom tooltip). Test icon rendering from lucide-react. Test simulation button disabled states match simulationStatus store value.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:27:22.681Z"
          },
          {
            "id": 4,
            "title": "Implement StatusBar Component with Real-Time Status Indicators",
            "description": "Create src/components/layout/StatusBar.tsx displaying simulation status with colored indicator, scan time, Modbus connection status, and memory usage in a fixed-height footer bar.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/layout/StatusBar.tsx: 1) Create StatusIndicator sub-component that shows a colored dot (w-2 h-2 rounded-full) with label - green for running, yellow for paused, red/gray for stopped. 2) Left section: Simulation status indicator using StatusIndicator with text label ('Running', 'Paused', 'Stopped'). 3) Center section: Scan time display showing current scan cycle time (e.g., '10ms'). Use flex-1 with text-center for centering. 4) Right section (flex with gap-4): a) Modbus TCP status showing 'TCP:502' with Connected/Disconnected indicator, b) Memory usage showing percentage or MB value (placeholder until real implementation). 5) Read all values from layoutStore: simulationStatus, scanTime, modbusConnected, memoryUsage. 6) Style: fixed height h-6 (24px), border-t separator, bg-gray-100 dark:bg-gray-800, text-xs font-mono, flex items-center justify-between, px-4. 7) Use appropriate icons from lucide-react: Wifi/WifiOff for connection, Activity for simulation, Cpu for memory. 8) Ensure status updates reactively when store changes. 9) Add hover tooltips for detailed status information.",
            "status": "done",
            "testStrategy": "Test StatusBar renders with default values. Test simulation status indicator shows correct color for each status (running=green, paused=yellow, stopped=gray). Test scan time displays formatted value with 'ms' suffix. Test Modbus connection shows correct Connected/Disconnected state. Test memory usage displays placeholder value. Test store changes cause re-render with updated values. Test accessibility with proper ARIA labels for status indicators.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:27:22.687Z"
          },
          {
            "id": 5,
            "title": "Create layoutStore with Zustand for Application Chrome State",
            "description": "Implement src/stores/layoutStore.ts using Zustand to manage menu state, simulation status, scan time, Modbus connection status, memory usage, and panel visibility for the application shell.",
            "dependencies": [],
            "details": "Create src/stores/layoutStore.ts with Zustand: 1) Import create from 'zustand'. 2) Define SimulationStatus type: 'running' | 'stopped' | 'paused'. 3) Define LayoutStore interface with state: menuOpen (string | null for currently open menu name), simulationStatus (SimulationStatus), scanTime (number in ms), modbusConnected (boolean), modbusPort (number, default 502), memoryUsageMb (number), sidebarVisible (boolean), panelVisible (boolean), panelType ('output' | 'problems' | 'terminal'). 4) Define actions: setMenuOpen(menu: string | null), setSimulationStatus(status: SimulationStatus), setScanTime(time: number), setModbusConnected(connected: boolean), setModbusPort(port: number), setMemoryUsage(mb: number), toggleSidebar(), togglePanel(), setPanelType(type: string), resetLayout(). 5) Create store with create<LayoutStore>((set) => ({...})). 6) Set sensible defaults: menuOpen=null, simulationStatus='stopped', scanTime=10, modbusConnected=false, modbusPort=502, memoryUsageMb=0, sidebarVisible=true, panelVisible=false, panelType='output'. 7) resetLayout action should restore all layout state to defaults. 8) Export useLayoutStore hook for component usage. 9) Add devtools middleware for debugging in development.",
            "status": "done",
            "testStrategy": "Test initial state values match expected defaults. Test each action updates the correct state field. Test setMenuOpen with string sets menuOpen, with null clears it. Test setSimulationStatus only accepts valid SimulationStatus values. Test toggleSidebar flips sidebarVisible boolean. Test resetLayout restores all values to initial state. Test store can be used in multiple components and updates propagate correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-26T23:32:06.212Z"
          }
        ],
        "updatedAt": "2026-01-27T00:27:22.687Z"
      },
      {
        "id": "12",
        "title": "Implement Sidebar with Activity Bar Navigation",
        "description": "Build VSCode Activity Bar-style sidebar with collapsible navigation, Explorer/Search/Modbus/Settings panels, and resizable width.",
        "details": "1. Create `src/components/layout/Sidebar.tsx`:\n   - Collapsible sidebar with configurable width (default: 250px, min: 150px, max: 400px)\n   - CSS transition for smooth show/hide animation (transform or width)\n   - Horizontal resize handle on right edge\n   - Flex layout: ActivityBar (fixed 48px) | Panel content (flexible)\n\n2. Create `src/components/layout/ActivityBar.tsx`:\n   - Vertical icon bar (48px width) positioned on left edge\n   - Icons using lucide-react: FolderTree (Explorer), Search, Server (Modbus), Settings\n   - Active tab indicator: left border highlight or background color change\n   - Tooltip on hover showing tab name using title attribute or custom tooltip\n   - Click handler switches active panel\n\n3. Create sidebar panel components in `src/components/sidebar/`:\n   - `ExplorerPanel.tsx`: Project file tree view with expandable folders\n     - Display .mop file contents structure (config.yml, plc_csv/, one_canvas/)\n     - Use recursive Tree component with expand/collapse icons\n     - Click on files to open/edit in panels\n   - `SearchPanel.tsx`: Global search input with results list\n     - Search input with debounced onChange\n     - Results grouped by file with line preview\n   - `ModbusPanel.tsx`: Server status display, memory overview\n     - Connection status indicator\n     - Quick start/stop server buttons\n     - Memory usage summary (coils, registers count)\n   - `SettingsPanel.tsx`: Quick settings shortcuts\n     - Links to open full settings dialog\n     - Quick toggles for common settings\n\n4. Create `src/stores/sidebarStore.ts` with Zustand:\n   ```typescript\n   interface SidebarStore {\n     activePanel: 'explorer' | 'search' | 'modbus' | 'settings';\n     isVisible: boolean;\n     width: number;\n     setActivePanel: (panel: string) => void;\n     toggleVisibility: () => void;\n     setWidth: (width: number) => void;\n   }\n   ```\n\n5. Implement resize handle with mouse drag:\n   - onMouseDown starts resize mode\n   - onMouseMove updates width (clamped to min/max)\n   - onMouseUp ends resize mode\n   - Cursor change to col-resize during drag",
        "testStrategy": "1. Test sidebar visibility toggle with Ctrl+B shortcut\n2. Test clicking ActivityBar icons switches panel content\n3. Test resize handle adjusts width within min/max bounds\n4. Test file tree in ExplorerPanel displays correct project structure\n5. Test active tab indicator highlights correct icon\n6. Test sidebar remembers width after toggle hide/show",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Zustand Sidebar Store for State Management",
            "description": "Implement the sidebarStore using Zustand to manage sidebar visibility, active panel selection, and width state with persistence support.",
            "dependencies": [],
            "details": "Create `src/stores/sidebarStore.ts` with Zustand store implementing: activePanel state with union type 'explorer' | 'search' | 'modbus' | 'settings', isVisible boolean defaulting to true, width number defaulting to 250px. Include actions: setActivePanel(panel) to switch panels, toggleVisibility() to show/hide sidebar, setWidth(width) with clamping between MIN_WIDTH=150 and MAX_WIDTH=400. Add persist middleware to save state to localStorage. Export typed hooks (useSidebarStore, useSidebarActions) for component consumption. This store must be created first as Sidebar and ActivityBar components depend on it.",
            "status": "done",
            "testStrategy": "Unit test store initialization with correct default values. Test setActivePanel updates activePanel correctly. Test toggleVisibility flips isVisible. Test setWidth clamps values within 150-400px range. Test persistence by verifying localStorage is updated on state changes.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:32:04.670Z"
          },
          {
            "id": 2,
            "title": "Implement ActivityBar Component with Panel Icons",
            "description": "Build the vertical ActivityBar component (48px width) with lucide-react icons for Explorer, Search, Modbus, and Settings panels with active state indication.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/layout/ActivityBar.tsx` as a vertical flex container with fixed 48px width and full height. Import lucide-react icons: FolderTree (Explorer), Search, Server (Modbus), Settings. Each icon button should: call sidebarStore.setActivePanel on click, show active indicator via left border (3px solid accent color) or background highlight when matching activePanel state, display tooltip on hover using title attribute showing panel name. Style with dark background (#252526 for dark theme), icon size 24px, vertical spacing 8px between icons. Include keyboard support for icon focus and activation.",
            "status": "done",
            "testStrategy": "Test clicking each icon calls setActivePanel with correct panel type. Verify active indicator appears only on the active panel icon. Test tooltip appears on hover with correct panel name. Test keyboard navigation (Tab to focus, Enter to activate).",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:32:04.677Z"
          },
          {
            "id": 3,
            "title": "Build Sidebar Container with Resize Handle",
            "description": "Create the main Sidebar component with collapsible functionality, resize handle for width adjustment, and CSS transitions for smooth animations.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/components/layout/Sidebar.tsx` with flex layout containing ActivityBar (fixed 48px) and panel content area (flexible). Implement resize handle on right edge: onMouseDown captures initial width and position, document mousemove calculates delta and calls setWidth with clamped value, mouseup removes listeners. Add CSS transition on width property for smooth collapse animation. When isVisible is false, use transform: translateX(-100%) or width: 48px (ActivityBar only) with transition. Include useEffect to add/remove global mousemove/mouseup listeners during resize. Set cursor to col-resize during active drag using body style manipulation.",
            "status": "done",
            "testStrategy": "Test sidebar renders with default 250px width. Test resize handle drag updates width within bounds. Test collapse animation triggers when isVisible toggles. Test cursor changes to col-resize during drag. Test keyboard shortcut Ctrl+B triggers toggleVisibility.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:32:04.683Z"
          },
          {
            "id": 4,
            "title": "Create Explorer and Search Sidebar Panels",
            "description": "Implement ExplorerPanel with recursive file tree component and SearchPanel with debounced search input and results display.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/sidebar/ExplorerPanel.tsx`: Build recursive Tree component displaying .mop project structure (config.yml, plc_csv/, one_canvas/). Each TreeNode has expand/collapse icon (ChevronRight/ChevronDown), file/folder icon, and label. Store expanded state locally or in store. Handle click on files to trigger file open action. Create `src/components/sidebar/SearchPanel.tsx`: Search input at top with magnifying glass icon, debounced onChange (300ms delay using useCallback + setTimeout). Display results grouped by filename with matching line preview and line number. Highlight search term in results. Empty state when no results or no search query.",
            "status": "done",
            "testStrategy": "ExplorerPanel: Test tree renders correct hierarchy. Test expand/collapse toggles visibility of children. Test file click emits open event. SearchPanel: Test debounce delays search execution. Test results display matches grouped by file. Test empty state shows appropriate message.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:32:04.688Z"
          },
          {
            "id": 5,
            "title": "Create Modbus and Settings Sidebar Panels",
            "description": "Implement ModbusPanel showing server status with quick controls and SettingsPanel with quick setting shortcuts and toggle controls.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/sidebar/ModbusPanel.tsx`: Display connection status indicator (colored dot: green=connected, gray=disconnected, yellow=connecting). Show quick Start/Stop server buttons using Play/Square icons. Display memory overview section with counts for coils, discrete inputs, holding registers, input registers. Use placeholder data initially, will connect to Modbus store later (Task 21-24 dependency). Create `src/components/sidebar/SettingsPanel.tsx`: Quick access links to open full settings dialog sections (General, Simulation, Modbus, Appearance). Include common toggle switches for dark mode, auto-save, show tooltips. Style as card-like sections with section headers.",
            "status": "done",
            "testStrategy": "ModbusPanel: Test status indicator shows correct color based on state. Test Start/Stop buttons trigger appropriate actions. Test memory counts display correctly. SettingsPanel: Test clicking links opens settings dialog at correct section. Test toggle switches update corresponding settings.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:32:04.751Z"
          }
        ],
        "updatedAt": "2026-01-27T00:32:04.751Z"
      },
      {
        "id": "13",
        "title": "Build Panel System with CSS Grid Layout",
        "description": "Implement CSS Grid-based flexible panel system supporting multiple panels with resize handles, minimize/maximize controls, and dynamic grid configuration.",
        "details": "1. Create `src/components/panels/PanelContainer.tsx`:\n   - CSS Grid layout with dynamic grid-template-columns and grid-template-rows\n   - Grid configuration from panelStore: { columns: ['1fr', '1fr'], rows: ['1fr', '1fr'] }\n   - Gap between panels (4px) for resize handles\n   - Full height/width within available space\n\n2. Create `src/components/panels/Panel.tsx`:\n   ```typescript\n   interface PanelProps {\n     id: string;\n     type: PanelType;\n     title: string;\n     isActive: boolean;\n     gridArea?: string; // e.g., '1 / 1 / 2 / 2'\n     onClose: () => void;\n     onMinimize: () => void;\n     onMaximize: () => void;\n     onActivate: () => void;\n   }\n   ```\n   - Header with title, minimize (-), maximize (□), close (×) buttons\n   - Content area rendering panel-specific component\n   - Active/inactive border styling (active: blue border)\n   - Click anywhere activates panel\n\n3. Create `src/components/panels/ResizeHandle.tsx`:\n   - Horizontal handle: between rows, full width, 4px height\n   - Vertical handle: between columns, full height, 4px width\n   - Visual feedback: cursor change, highlight on hover/drag\n   - Drag logic updates grid template values in store\n   - Minimum panel size constraint: 150px\n\n4. Define panel types in `src/types/panel.ts`:\n   ```typescript\n   type PanelType = 'ladder-editor' | 'memory-visualizer' | 'one-canvas' |\n                    'scenario-editor' | 'console' | 'properties';\n   interface PanelState {\n     id: string;\n     type: PanelType;\n     title: string;\n     gridArea: string;\n     isMinimized: boolean;\n   }\n   ```\n\n5. Create `src/stores/panelStore.ts` with Zustand:\n   ```typescript\n   interface PanelStore {\n     panels: PanelState[];\n     gridConfig: { columns: string[], rows: string[] };\n     activePanel: string | null;\n     addPanel: (type: PanelType, area: string) => void;\n     removePanel: (id: string) => void;\n     updateGridConfig: (config: GridConfig) => void;\n     setActivePanel: (id: string | null) => void;\n   }\n   ```\n\n6. Create placeholder panel content components:\n   - `LadderEditorPanel.tsx`: Placeholder 'Ladder Editor - Coming in Unit 4'\n   - `MemoryVisualizerPanel.tsx`: Placeholder, will integrate with Unit 3\n   - `OneCanvasPanel.tsx`: Placeholder 'One Canvas - Coming in Unit 5'\n   - `ScenarioEditorPanel.tsx`: Placeholder 'Scenario Editor - Coming in Unit 6'\n   - `ConsolePanel.tsx`: Simple log output display with timestamp\n   - `PropertiesPanel.tsx`: Selected element properties editor",
        "testStrategy": "1. Test grid layout renders panels in correct positions based on gridArea\n2. Test resize handle drag updates gridConfig columns/rows\n3. Test minimum size constraint prevents panels smaller than 150px\n4. Test panel close removes from grid and updates layout\n5. Test panel maximize expands to full grid area\n6. Test clicking panel sets it as active with visual indicator",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Panel Types and Interfaces in TypeScript",
            "description": "Create the foundational type definitions for the panel system including PanelType enum, PanelState interface, and GridConfig types that will be used throughout the panel system.",
            "dependencies": [],
            "details": "Create `src/types/panel.ts` with the following type definitions:\n\n1. Define `PanelType` as a union type: 'ladder-editor' | 'memory-visualizer' | 'one-canvas' | 'scenario-editor' | 'console' | 'properties'\n\n2. Define `PanelState` interface:\n   - id: string (unique identifier)\n   - type: PanelType\n   - title: string\n   - gridArea: string (CSS grid-area value, e.g., '1 / 1 / 2 / 2')\n   - isMinimized: boolean\n\n3. Define `GridConfig` interface:\n   - columns: string[] (array of grid-template-columns values, e.g., ['1fr', '1fr'])\n   - rows: string[] (array of grid-template-rows values)\n\n4. Define `PanelProps` interface for the Panel component:\n   - id: string\n   - type: PanelType\n   - title: string\n   - isActive: boolean\n   - gridArea?: string\n   - onClose: () => void\n   - onMinimize: () => void\n   - onMaximize: () => void\n   - onActivate: () => void\n\n5. Export all types for use in other modules.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation succeeds with no errors. Test that all types can be imported and used correctly in consumer files. Ensure type inference works correctly when creating PanelState objects.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:37:03.668Z"
          },
          {
            "id": 2,
            "title": "Create Zustand Panel Store for State Management",
            "description": "Implement a Zustand store to manage panel state including panel list, grid configuration, active panel tracking, and actions for adding/removing/updating panels.",
            "dependencies": [
              1
            ],
            "details": "Create `src/stores/panelStore.ts` with Zustand:\n\n1. Install zustand if not present: `npm install zustand`\n\n2. Define `PanelStore` interface:\n   - panels: PanelState[] (array of all panels)\n   - gridConfig: GridConfig (current grid layout)\n   - activePanel: string | null (ID of currently focused panel)\n\n3. Implement actions:\n   - addPanel(type: PanelType, area: string): void - creates new panel with unique ID\n   - removePanel(id: string): void - removes panel and updates layout\n   - updateGridConfig(config: GridConfig): void - updates grid template values\n   - setActivePanel(id: string | null): void - sets the active panel\n   - minimizePanel(id: string): void - toggles panel minimized state\n   - maximizePanel(id: string): void - expands panel to full grid area\n\n4. Set default state with 2x2 grid layout:\n   - gridConfig: { columns: ['1fr', '1fr'], rows: ['1fr', '1fr'] }\n   - panels: empty array initially\n   - activePanel: null\n\n5. Use immer middleware for immutable state updates if complex nested updates needed.",
            "status": "done",
            "testStrategy": "Unit test each store action: verify addPanel creates panel with correct properties, removePanel removes correct panel, updateGridConfig changes grid values, setActivePanel updates activePanel. Test that state updates trigger re-renders in subscribed components.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:37:03.676Z"
          },
          {
            "id": 3,
            "title": "Build PanelContainer Component with CSS Grid Layout",
            "description": "Create the main PanelContainer component that renders a CSS Grid-based layout, positioning child panels according to the grid configuration from the panel store.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/components/panels/PanelContainer.tsx`:\n\n1. Import hooks from panelStore to access gridConfig and panels\n\n2. Render a container div with CSS Grid:\n   - display: grid\n   - grid-template-columns: dynamic from store (e.g., '1fr 1fr')\n   - grid-template-rows: dynamic from store\n   - gap: 4px (space for resize handles)\n   - height: 100% and width: 100% to fill available space\n   - overflow: hidden\n\n3. Map over panels array and render Panel components:\n   - Pass panel props (id, type, title, gridArea)\n   - Apply style={{ gridArea: panel.gridArea }} to position each panel\n   - Handle isMinimized panels (collapse to header only or hide)\n\n4. Implement CSS styles:\n   - Create panel-container class with proper flexbox parent integration\n   - Ensure container takes full available space from parent layout\n   - Add CSS custom properties for theming (--panel-gap, --panel-border-radius)\n\n5. Add resize handle overlay areas between grid cells for future resize functionality.\n\n6. Export component as default.",
            "status": "done",
            "testStrategy": "Test grid layout renders panels in correct positions based on gridArea values. Verify gridConfig changes dynamically update the grid-template-columns and grid-template-rows. Test container fills available space correctly. Verify panels are positioned correctly with different grid configurations.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:37:03.681Z"
          },
          {
            "id": 4,
            "title": "Build Panel Component with Header and Controls",
            "description": "Create the Panel component with a header bar containing title, minimize/maximize/close buttons, content area for panel-specific components, and active/inactive visual states.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create `src/components/panels/Panel.tsx`:\n\n1. Accept PanelProps interface defined in types/panel.ts\n\n2. Structure the component:\n   - Outer container with border and rounded corners\n   - Header section (24-32px height):\n     * Title text (truncated with ellipsis if too long)\n     * Control buttons container (right-aligned):\n       - Minimize button (-) calls onMinimize\n       - Maximize button (□) calls onMaximize\n       - Close button (×) calls onClose\n   - Content area taking remaining space (overflow: auto)\n\n3. Implement visual states:\n   - Active panel: 2px blue/accent border\n   - Inactive panel: 1px gray border\n   - Header background color differentiation (active vs inactive)\n   - Button hover effects\n\n4. Handle click events:\n   - Clicking anywhere on panel calls onActivate\n   - Use event.stopPropagation on header buttons to prevent activation\n\n5. Render panel content based on type:\n   - Create switch/map to render correct panel content component\n   - Pass through any necessary props to content component\n\n6. Style with Tailwind CSS or CSS modules:\n   - flex flex-col for layout\n   - Panel header: flex justify-between items-center\n   - Control buttons: small icons with hover states",
            "status": "done",
            "testStrategy": "Test clicking panel calls onActivate callback. Test minimize/maximize/close buttons call correct callbacks. Test active panel has blue border styling. Test inactive panel has gray border. Test panel content area renders correct component based on type prop. Test header title truncates properly with ellipsis.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:37:03.687Z"
          },
          {
            "id": 5,
            "title": "Build ResizeHandle and Placeholder Panel Content Components",
            "description": "Create the ResizeHandle component for resizing panel grid areas and implement all six placeholder panel content components with basic UI indicating future functionality.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create `src/components/panels/ResizeHandle.tsx`:\n\n1. Accept props: orientation ('horizontal' | 'vertical'), index (which gap), onResize callback\n\n2. Render resize handle element:\n   - Horizontal: full width, 4px height, positioned between rows\n   - Vertical: full height, 4px width, positioned between columns\n   - cursor: col-resize (vertical) or row-resize (horizontal)\n   - background: transparent, changes to accent color on hover\n\n3. Implement drag logic:\n   - onMouseDown: start tracking, capture initial position\n   - onMouseMove (document): calculate delta, call onResize with new grid values\n   - onMouseUp: stop tracking, release event listeners\n   - Enforce minimum panel size: 150px constraint\n\n4. Update panelStore.updateGridConfig with new column/row values\n\nCreate placeholder panel content components in `src/components/panels/content/`:\n\n5. LadderEditorPanel.tsx:\n   - Display centered text: 'Ladder Editor - Coming in Unit 4'\n   - Basic placeholder styling with icon\n\n6. MemoryVisualizerPanel.tsx:\n   - Display: 'Memory Visualizer - Will integrate with Unit 3'\n   - Placeholder for memory display\n\n7. OneCanvasPanel.tsx:\n   - Display: 'One Canvas - Coming in Unit 5'\n   - Placeholder circuit canvas area\n\n8. ScenarioEditorPanel.tsx:\n   - Display: 'Scenario Editor - Coming in Unit 6'\n   - Placeholder for scenario UI\n\n9. ConsolePanel.tsx:\n   - Simple scrollable log output area with timestamps\n   - Basic log array display with useConsoleStore or local state\n\n10. PropertiesPanel.tsx:\n    - Display: 'Properties - Select an element'\n    - Placeholder for property editor form",
            "status": "done",
            "testStrategy": "Test resize handle drag updates gridConfig columns/rows in store. Test minimum size constraint prevents panels smaller than 150px. Test cursor changes to resize cursor on hover. Test all placeholder panels render their placeholder text correctly. Test ConsolePanel displays log entries with timestamps. Test resize handles appear between grid cells.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:37:03.692Z"
          }
        ],
        "updatedAt": "2026-01-27T00:37:03.692Z"
      },
      {
        "id": "14",
        "title": "Implement Tab System for Panel Content",
        "description": "Create tab bar system within panels supporting multiple tabs, reordering via drag, close with unsaved indicator, and context menu actions.",
        "details": "1. Create `src/components/panels/TabBar.tsx`:\n   - Horizontal scrollable tab list within panel header area\n   - Active tab indicator: bottom border or background highlight\n   - Tab overflow handling: horizontal scroll with scroll buttons or CSS overflow-x: auto\n   - Integrated into Panel component header section\n\n2. Create `src/components/panels/Tab.tsx`:\n   ```typescript\n   interface TabProps {\n     id: string;\n     icon?: React.ReactNode;\n     title: string;\n     isActive: boolean;\n     isModified: boolean; // Shows dot indicator\n     onActivate: () => void;\n     onClose: () => void;\n   }\n   ```\n   - Icon (optional) + title + close button layout\n   - Modified indicator: colored dot before title when isModified=true\n   - Close button (×) appears on hover or always visible\n   - Draggable for reordering using HTML5 drag API or @dnd-kit/core\n\n3. Create `src/components/panels/TabContent.tsx`:\n   - Content area switching based on active tab\n   - Lazy loading: only render active tab content, use React.memo for others\n   - Smooth transition between tabs (optional fade)\n\n4. Implement tab context menu:\n   - Right-click on tab shows context menu\n   - Options: 'Close', 'Close Others', 'Close All', 'Close to the Right'\n   - Use custom context menu component or react-contextmenu\n\n5. Update Panel component to support tabs:\n   - Panel can contain single content OR multiple tabs\n   - TabBar renders when panel has tabs array\n   - Each tab has its own PanelType and content\n\n6. Extend panelStore for tab management:\n   ```typescript\n   interface TabState {\n     id: string;\n     panelType: PanelType;\n     title: string;\n     isModified: boolean;\n     data?: any; // Tab-specific data\n   }\n   // In PanelState:\n   tabs?: TabState[];\n   activeTabId?: string;\n   // Actions:\n   addTab: (panelId: string, tab: TabState) => void;\n   removeTab: (panelId: string, tabId: string) => void;\n   setActiveTab: (panelId: string, tabId: string) => void;\n   reorderTabs: (panelId: string, fromIndex: number, toIndex: number) => void;\n   ```\n\n7. Implement tab drag reordering:\n   - onDragStart sets dragged tab data\n   - onDragOver allows drop on tab bar\n   - onDrop reorders tabs array",
        "testStrategy": "1. Test tab switching changes visible content to correct tab\n2. Test tab close removes tab from array and switches to adjacent\n3. Test tab reorder via drag updates tab order in store\n4. Test modified indicator (dot) appears when isModified=true\n5. Test context menu 'Close Others' closes all except right-clicked tab\n6. Test overflow scroll appears when many tabs exceed width",
        "priority": "medium",
        "dependencies": [
          "13"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Tab Types and Extend Panel Store with Tab State",
            "description": "Create TypeScript interfaces for TabState and TabBarProps, then extend the existing panelStore (from Task 13) with tab-related state properties and actions.",
            "dependencies": [],
            "details": "Create `src/types/tab.ts` with TabState interface including id, panelType, title, isModified, and optional data properties. Extend the PanelState interface in the panel store to include optional `tabs?: TabState[]` and `activeTabId?: string` properties. Add store actions: `addTab(panelId: string, tab: TabState)`, `removeTab(panelId: string, tabId: string)`, `setActiveTab(panelId: string, tabId: string)`, `reorderTabs(panelId: string, fromIndex: number, toIndex: number)`, and `updateTabModified(panelId: string, tabId: string, isModified: boolean)`. Ensure proper TypeScript typing with generics for tab data.",
            "status": "done",
            "testStrategy": "Unit test each store action: verify addTab creates tab with correct properties and sets it as active if first tab, removeTab removes correct tab and switches activeTab to adjacent if removed was active, setActiveTab updates activeTabId, reorderTabs correctly reorders the tabs array, updateTabModified toggles the isModified flag.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:38:51.142Z"
          },
          {
            "id": 2,
            "title": "Create Tab Component with Modified Indicator and Close Button",
            "description": "Build the individual Tab component with icon, title, modified indicator (dot), close button on hover, and support for drag handle integration.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/panels/Tab.tsx` implementing TabProps interface: { id: string, icon?: React.ReactNode, title: string, isActive: boolean, isModified: boolean, onActivate: () => void, onClose: () => void, onContextMenu: (e: React.MouseEvent) => void }. Style with Tailwind CSS: active tab has bottom border or background highlight, inactive tabs are muted. Display colored dot indicator before title when isModified=true. Close button (×) appears on hover or always visible for active tab. Add draggable attribute and data-tab-id for drag-and-drop support. Handle click for activation and prevent close button click from bubbling to tab click.",
            "status": "done",
            "testStrategy": "Test tab click calls onActivate, close button click calls onClose without triggering onActivate, modified indicator dot appears when isModified=true, active state applies correct visual styling (border/background), right-click triggers onContextMenu callback.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:39:32.610Z"
          },
          {
            "id": 3,
            "title": "Build TabBar Component with Horizontal Scrolling and Overflow Handling",
            "description": "Create the TabBar container component that renders tabs horizontally with scroll support, active tab indicator, and integration with the panel header area.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/components/panels/TabBar.tsx` that maps over panel's tabs array from store and renders Tab components. Implement horizontal scrollable container using CSS `overflow-x: auto` with hidden scrollbar styling or custom scroll buttons for overflow. Track activeTabId from store and pass isActive prop to each Tab. Wire up onActivate to call setActiveTab action, onClose to call removeTab action. Handle empty tabs state gracefully. Add drop zone for tab drag reordering using HTML5 drag events (onDragOver, onDrop). Calculate drop position based on mouse position relative to tab elements.",
            "status": "done",
            "testStrategy": "Test TabBar renders all tabs from panel state, clicking tab triggers setActiveTab store action, closing tab triggers removeTab action, horizontal scroll appears when tabs exceed container width, active tab is visually distinct, tab reorder drop zone accepts dragged tabs.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:40:47.487Z"
          },
          {
            "id": 4,
            "title": "Implement Tab Context Menu with Close Actions",
            "description": "Create a context menu component for tabs with options like Close, Close Others, Close All, and Close to the Right.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create `src/components/panels/TabContextMenu.tsx` as a custom context menu (positioned dropdown) or integrate with a context menu library. Menu options: 'Close' (closes the right-clicked tab), 'Close Others' (closes all tabs except the right-clicked one), 'Close All' (closes all tabs in the panel), 'Close to the Right' (closes all tabs after the right-clicked tab). Each action dispatches appropriate removeTab calls to the store. Position menu at mouse coordinates on right-click. Close menu on click outside or Escape key. Disable 'Close Others' and 'Close to the Right' when only one tab exists.",
            "status": "done",
            "testStrategy": "Test context menu appears at correct position on right-click, 'Close' removes only the clicked tab, 'Close Others' removes all except clicked tab and makes it active, 'Close All' removes all tabs from panel, 'Close to the Right' removes tabs after clicked index, menu closes on outside click and Escape key.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:41:22.519Z"
          },
          {
            "id": 5,
            "title": "Integrate TabBar and TabContent into Panel Component",
            "description": "Update the Panel component from Task 13 to conditionally render TabBar when tabs exist, implement TabContent area with lazy loading, and wire up tab drag reordering logic.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Modify `src/components/panels/Panel.tsx` to check if panel has tabs array. If tabs exist, render TabBar in the header section below or replacing the title. Create `src/components/panels/TabContent.tsx` that switches content based on activeTabId, rendering the appropriate PanelType component for the active tab. Implement lazy loading: only mount active tab content, use React.memo for performance. Add optional smooth fade transition between tabs using CSS or framer-motion. Implement full drag reordering: onDragStart sets dragged tab info in dataTransfer, onDragOver on TabBar allows drop, onDrop calculates new position and calls reorderTabs action. Handle edge case of single-tab panels (show tab or just title).",
            "status": "done",
            "testStrategy": "Test Panel with tabs renders TabBar in header, Panel without tabs renders single content area, tab switching changes TabContent to correct panel type component, lazy loading only renders active tab content, tab drag reordering updates tabs array order in store, context menu integration works from Tab through TabBar to Panel.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:22:42.826Z"
          }
        ],
        "updatedAt": "2026-01-27T05:22:42.826Z"
      },
      {
        "id": "15",
        "title": "Add Panel Drag-and-Drop for Layout Customization",
        "description": "Enable panel drag-and-drop to rearrange layout, split panels by dropping on edges, merge panels as tabs by dropping in center, with visual guides and animations.",
        "details": "1. Install @dnd-kit/core and @dnd-kit/sortable:\n   ```bash\n   npm install @dnd-kit/core @dnd-kit/sortable\n   ```\n\n2. Create `src/components/panels/DraggablePanel.tsx`:\n   - Wrap Panel component with DnD context\n   - Drag handle in panel header (grip icon or entire header)\n   - Visual feedback during drag: reduced opacity (0.5), shadow\n   - useDraggable hook from @dnd-kit/core\n\n3. Create `src/components/panels/DropZone.tsx`:\n   - Overlay component rendered during drag operations\n   - Position indicators: top, bottom, left, right edges + center\n   - Highlight zone when panel dragged over (blue overlay)\n   - Different visual for edge drop (split) vs center drop (merge)\n\n4. Implement panel split functionality:\n   - Detect drop position (top/bottom for horizontal split, left/right for vertical)\n   - Dropping on edge splits the target area:\n     - Top edge: new row above, target moves down\n     - Left edge: new column left, target moves right\n   - Update gridConfig to add new row/column\n   - Assign new gridArea to dropped panel\n\n5. Implement panel merge functionality:\n   - Dropping in center of panel adds as new tab\n   - Convert target panel to tabbed panel if not already\n   - Add dragged panel content as new tab\n   - Remove original panel from grid\n\n6. Create `src/components/panels/DragOverlay.tsx`:\n   - Ghost preview of panel at cursor during drag\n   - Shows panel title and type icon\n   - Animated snap to drop zone on approach\n\n7. Add visual guides during drag:\n   - Grid lines showing potential split positions\n   - Animated transitions when layout rearranges\n   - Use CSS transitions for smooth panel size changes\n\n8. Create DnD context provider:\n   ```typescript\n   // src/providers/PanelDndProvider.tsx\n   export function PanelDndProvider({ children }) {\n     return (\n       <DndContext onDragStart onDragOver onDragEnd sensors modifiers>\n         {children}\n         <DragOverlay>{/* Active item preview */}</DragOverlay>\n       </DndContext>\n     );\n   }\n   ```",
        "testStrategy": "1. Test panel drag shows visual feedback (opacity, cursor)\n2. Test drop on edge creates split layout with new grid cell\n3. Test drop in center merges panels as tabs\n4. Test drop zone highlights correctly when dragged over\n5. Test layout persists after drag operations (check panelStore)\n6. E2E test complex rearrangement: drag panel A to right of B, then drag C to bottom",
        "priority": "medium",
        "dependencies": [
          "14"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install @dnd-kit Dependencies and Create PanelDndProvider Context",
            "description": "Set up the drag-and-drop infrastructure by installing @dnd-kit packages and creating the DnD context provider that wraps the panel system.",
            "dependencies": [],
            "details": "1. Install required packages: `npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities`\n\n2. Create `src/providers/PanelDndProvider.tsx`:\n   - Import DndContext, DragOverlay, useSensors, useSensor, PointerSensor, KeyboardSensor from @dnd-kit/core\n   - Configure sensors with activation constraints (distance: 10px) to prevent accidental drags\n   - Set up collision detection strategy (closestCenter or rectIntersection)\n   - Implement onDragStart, onDragOver, and onDragEnd event handlers\n   - Track active dragging panel ID in local state\n   - Export context for accessing drag state from child components\n\n3. Create `src/types/dnd.ts` for DnD-specific type definitions:\n   - DropPosition type: 'top' | 'bottom' | 'left' | 'right' | 'center'\n   - DragData interface with panelId, panelType, sourceGridArea\n   - DropResult interface with targetPanelId, dropPosition, targetGridArea\n\n4. Integrate PanelDndProvider into app component tree, wrapping PanelContainer",
            "status": "done",
            "testStrategy": "Test DndContext renders children correctly. Test sensors are configured with correct activation constraints. Test drag events fire onDragStart/onDragEnd handlers. Verify PanelDndProvider exports context value accessible by child components.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:24:25.709Z"
          },
          {
            "id": 2,
            "title": "Create DraggablePanel Component with Drag Handle and Visual Feedback",
            "description": "Implement the DraggablePanel wrapper component that makes panels draggable with a drag handle in the header and visual feedback during drag operations.",
            "dependencies": [
              1
            ],
            "details": "1. Create `src/components/panels/DraggablePanel.tsx`:\n   - Import useDraggable hook from @dnd-kit/core\n   - Wrap existing Panel component with draggable functionality\n   - Pass panel ID and type as draggable data\n\n2. Implement drag handle in panel header:\n   - Add grip icon (6-dot pattern or similar) to left side of panel header\n   - Use CSS cursor: grab (cursor: grabbing when active)\n   - Apply drag handle ref from useDraggable to grip element\n   - Alternative: make entire header draggable (configurable via prop)\n\n3. Add visual feedback during drag:\n   - Reduce opacity to 0.5 when isDragging is true\n   - Add box-shadow for elevation effect\n   - Apply CSS transform from useDraggable for smooth positioning\n   - Add transition for opacity changes\n\n4. Update Panel component to accept draggable props:\n   - Add isDragging prop to conditionally apply drag styles\n   - Ensure panel header renders drag handle slot\n\n5. Add keyboard accessibility: support Enter/Space to initiate drag",
            "status": "done",
            "testStrategy": "Test drag handle renders with correct cursor style. Test useDraggable hook provides correct attributes and listeners. Test opacity reduces to 0.5 when isDragging=true. Test drag data contains correct panelId and panelType. Test keyboard activation works with Enter key.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:26:23.132Z"
          },
          {
            "id": 3,
            "title": "Create DropZone Overlay and DragOverlay Preview Components",
            "description": "Implement the DropZone component showing position indicators during drag and DragOverlay component displaying a ghost preview of the dragged panel.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Create `src/components/panels/DropZone.tsx`:\n   - Import useDroppable hook from @dnd-kit/core\n   - Create overlay component that renders on top of target panels during drag\n   - Implement 5 drop zones per panel: top, bottom, left, right (edges), center\n   - Each zone occupies ~25% of edge area, center takes remaining area\n   - Use isOver and active from useDroppable to detect hover state\n\n2. Implement visual indicators:\n   - Edge zones (split): semi-transparent blue overlay on hovered edge\n   - Center zone (merge): different visual - dashed border or tab icon overlay\n   - Show split preview line when hovering edge zones\n   - Animate highlight transitions with CSS transitions (opacity, background-color)\n\n3. Create `src/components/panels/DragOverlay.tsx`:\n   - Render ghost preview following cursor during drag\n   - Show panel title, type icon, and miniature panel appearance\n   - Apply slight scale (0.9) and rotation (2deg) for lifted effect\n   - Add subtle shadow for depth\n   - Animate snap-to-drop-zone when approaching valid target\n\n4. Integrate DragOverlay into PanelDndProvider:\n   - Render DragOverlay component with active panel content\n   - Pass dragged panel metadata for preview rendering\n\n5. Implement conditional rendering: only show DropZone overlays when drag is active",
            "status": "done",
            "testStrategy": "Test DropZone renders 5 distinct drop regions (top, bottom, left, right, center). Test hover highlight appears on correct zone when dragged over. Test edge zones show split visual vs center shows merge visual. Test DragOverlay follows cursor position during drag. Test DragOverlay displays correct panel title and icon.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:26:23.140Z"
          },
          {
            "id": 4,
            "title": "Implement Panel Split Functionality for Edge Drop Operations",
            "description": "Implement the logic to split panels when dropping on edges, updating the CSS Grid configuration to create new rows or columns.",
            "dependencies": [
              2,
              3
            ],
            "details": "1. Create `src/utils/gridUtils.ts` for grid manipulation functions:\n   - calculateDropPosition(event, targetRect): determines which edge/center was targeted\n   - splitGridColumn(gridConfig, targetArea, position): adds new column left/right\n   - splitGridRow(gridConfig, targetArea, position): adds new row above/below\n   - generateNewGridArea(existingAreas): creates unique grid area name\n\n2. Implement split logic in onDragEnd handler:\n   - Top edge drop: insert new row above target, move target down\n   - Bottom edge drop: insert new row below target\n   - Left edge drop: insert new column left, move target right\n   - Right edge drop: insert new column right of target\n\n3. Update panel store with split actions:\n   - splitPanelHorizontal(targetPanelId, droppedPanelId, position: 'top'|'bottom')\n   - splitPanelVertical(targetPanelId, droppedPanelId, position: 'left'|'right')\n   - Each action updates gridConfig.columns/rows and reassigns gridArea values\n\n4. Handle grid area name updates:\n   - Assign new gridArea to dropped panel\n   - Update grid-template-areas in gridConfig\n   - Ensure unique naming convention (e.g., 'panel-{id}')\n\n5. Add CSS transitions to PanelContainer:\n   - Animate grid-template-columns and grid-template-rows changes\n   - Use transition duration of 200-300ms for smooth resize\n\n6. Edge case handling: prevent splitting to create panels smaller than minimum size",
            "status": "done",
            "testStrategy": "Test drop on top edge creates new row above and positions dragged panel there. Test drop on left edge creates new column left of target. Test gridConfig updates correctly with new column/row values. Test CSS transitions animate panel size changes. Test minimum size constraint prevents invalid splits.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:29:42.954Z"
          },
          {
            "id": 5,
            "title": "Implement Panel Merge as Tabs and Add Visual Guides with Animations",
            "description": "Implement center drop merging panels as tabs, add grid line visual guides during drag, and ensure layout persistence after drag operations.",
            "dependencies": [
              3,
              4
            ],
            "details": "1. Implement merge functionality in onDragEnd handler:\n   - Detect center drop via calculateDropPosition\n   - If target panel has no tabs: convert to tabbed panel, add dragged panel as second tab\n   - If target already tabbed: append dragged panel as new tab\n   - Remove dragged panel from its original grid position\n   - Update panel store's tabs array for target panel\n\n2. Create merge store actions:\n   - mergePanelAsTabs(targetPanelId, sourcePanelId): converts/adds to tabs\n   - removePanelFromGrid(panelId): removes panel and collapses empty grid areas\n   - collapseEmptyGridAreas(gridConfig): removes unused rows/columns after panel removal\n\n3. Add visual guides during drag in `src/components/panels/DragGuides.tsx`:\n   - Render grid lines showing potential split positions\n   - Display dashed lines at 50% marks of each panel\n   - Show animated guides that pulse when hovering valid drop zones\n   - Use CSS position: absolute overlay on PanelContainer\n\n4. Implement smooth animations:\n   - CSS transitions for panel size changes (width, height): 250ms ease-out\n   - Animate tab bar expansion when merging panels\n   - Fade-out animation for removed panel grid area\n   - Use requestAnimationFrame for smooth guide line rendering\n\n5. Ensure layout persistence:\n   - Call panelStore.persistLayout() after any drag operation completes\n   - Verify gridConfig and panel positions saved to storage\n   - Add debounced auto-save after layout changes\n\n6. Add undo support: store previous layout state for Ctrl+Z reversal",
            "status": "done",
            "testStrategy": "Test drop in center converts target to tabbed panel with dragged panel as new tab. Test already tabbed panel receives new tab on center drop. Test original panel removed from grid after merge. Test visual grid guides appear during active drag. Test layout persists to panelStore after drag operations complete. E2E test: drag panel A to right of B, then drag C to center of A creating tabs.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:29:42.961Z"
          }
        ],
        "updatedAt": "2026-01-27T05:29:42.961Z"
      },
      {
        "id": "16",
        "title": "Create Settings Dialog with Configuration Panels",
        "description": "Implement modal settings dialog with sidebar navigation for General, Simulation, Modbus, and Appearance settings with save/cancel/apply actions.",
        "details": "1. Create `src/components/settings/SettingsDialog.tsx`:\n   - Modal dialog with 80% viewport width/height, max 800x600\n   - Two-column layout: category sidebar (200px) | settings content\n   - Search bar at top to filter settings by keyword\n   - Footer with Save, Cancel, Apply buttons\n   - ESC key closes dialog with unsaved changes warning\n\n2. Create `src/components/settings/GeneralSettings.tsx`:\n   - Language selection dropdown: 한국어, English, 日本語\n   - Auto-save interval: number input with 'seconds' label (min 30)\n   - Start with last project: checkbox\n   - Telemetry opt-in/out: checkbox with explanation text\n\n3. Create `src/components/settings/SimulationSettings.tsx`:\n   - Default scan time (ms): number input with range 1-1000\n   - Timer precision: dropdown (Low, Medium, High)\n   - Simulation speed multiplier: radio buttons (0.5x, 1x, 2x, 4x)\n   - Step execution mode: dropdown options\n\n4. Create `src/components/settings/ModbusSettings.tsx`:\n   - Default TCP port: number input (range 1-65535, default 502)\n   - Default RTU serial settings:\n     - COM port: dropdown (populated from available ports)\n     - Baud rate: dropdown (9600, 19200, 38400, 57600, 115200)\n     - Parity: dropdown (None, Odd, Even)\n     - Stop bits: dropdown (1, 2)\n   - Connection timeout (ms): number input\n   - Auto-reconnect: checkbox\n\n5. Create `src/components/settings/AppearanceSettings.tsx`:\n   - Theme selection: radio buttons (Light, Dark, System)\n   - Font size adjustment: slider (12px to 20px)\n   - Grid display toggle: checkbox\n   - Animation enable/disable: checkbox\n\n6. Create `src/stores/settingsStore.ts` with Zustand:\n   ```typescript\n   interface AppSettings {\n     language: 'ko' | 'en' | 'ja';\n     theme: 'light' | 'dark' | 'system';\n     autoSaveInterval: number;\n     // ... all settings\n   }\n   interface SettingsStore {\n     settings: AppSettings;\n     pendingChanges: Partial<AppSettings>;\n     loadSettings: () => Promise<void>;\n     saveSettings: () => Promise<void>;\n     updatePending: (key: string, value: any) => void;\n     applyPending: () => void;\n     discardPending: () => void;\n   }\n   ```\n\n7. Add Tauri commands for settings persistence:\n   - In `src-tauri/src/commands/settings.rs`:\n     - `#[tauri::command] get_app_settings() -> Result<AppSettings, String>`\n     - `#[tauri::command] save_app_settings(settings: AppSettings) -> Result<(), String>`\n   - Store in app data directory as `settings.json`\n   - Register commands in main.rs",
        "testStrategy": "1. Test settings dialog opens with current values populated\n2. Test changes are held as pending until Save/Apply clicked\n3. Test Cancel discards pendingChanges and closes dialog\n4. Test Apply saves but keeps dialog open\n5. Test settings persist after app restart (mock Tauri invoke)\n6. Test theme change applies immediately on Apply",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Zustand Settings Store with AppSettings Interface and Pending Changes Logic",
            "description": "Implement the settingsStore.ts with Zustand including the AppSettings interface, pending changes management, and methods for loading, saving, updating, applying, and discarding settings changes.",
            "dependencies": [],
            "details": "Create src/stores/settingsStore.ts with Zustand. Define AppSettings interface with all settings fields: language ('ko' | 'en' | 'ja'), theme ('light' | 'dark' | 'system'), autoSaveInterval (number), startWithLastProject (boolean), telemetryEnabled (boolean), defaultScanTimeMs (number, 1-1000), timerPrecision ('low' | 'medium' | 'high'), simulationSpeedMultiplier (0.5 | 1 | 2 | 4), stepExecutionMode (string), defaultTcpPort (number, 1-65535), rtuComPort (string), rtuBaudRate (9600 | 19200 | 38400 | 57600 | 115200), rtuParity ('none' | 'odd' | 'even'), rtuStopBits (1 | 2), connectionTimeoutMs (number), autoReconnect (boolean), fontSize (number, 12-20), gridDisplay (boolean), animationEnabled (boolean). Define SettingsStore interface with: settings (AppSettings), pendingChanges (Partial<AppSettings>), isLoading (boolean), loadSettings (async function using invoke('get_app_settings')), saveSettings (async function using invoke('save_app_settings')), updatePending (key, value => adds to pendingChanges), applyPending (merges pendingChanges into settings and calls saveSettings), discardPending (clears pendingChanges). Use create<SettingsStore> from zustand with sensible defaults for all settings.",
            "status": "done",
            "testStrategy": "Test store initializes with correct default values. Test updatePending adds changes to pendingChanges without modifying settings. Test applyPending merges changes and resets pendingChanges. Test discardPending clears all pendingChanges. Mock invoke for loadSettings and saveSettings testing.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:22:56.055Z"
          },
          {
            "id": 2,
            "title": "Implement Tauri Commands for Settings Persistence in Rust Backend",
            "description": "Create the settings.rs module with get_app_settings and save_app_settings Tauri commands that persist settings as JSON in the app data directory.",
            "dependencies": [
              1
            ],
            "details": "Create src-tauri/src/commands/settings.rs. Define AppSettings struct matching the TypeScript interface with serde derives for JSON serialization. Implement #[tauri::command] pub async fn get_app_settings(app_handle: tauri::AppHandle) -> Result<AppSettings, String> that reads from app_data_dir/settings.json using tauri::Manager to get app_handle.path().app_data_dir(). Return default AppSettings if file doesn't exist. Implement #[tauri::command] pub async fn save_app_settings(app_handle: tauri::AppHandle, settings: AppSettings) -> Result<(), String> that creates the app data directory if needed and writes settings as JSON. Add pub mod settings to src-tauri/src/commands/mod.rs. Register both commands in main.rs invoke_handler with tauri::generate_handler![commands::settings::get_app_settings, commands::settings::save_app_settings]. Create src/types/settings.ts with TypeScript AppSettings interface matching the Rust struct for type safety.",
            "status": "done",
            "testStrategy": "Test get_app_settings returns defaults when settings.json doesn't exist. Test save_app_settings creates settings.json with correct content. Test roundtrip: save then load returns identical settings. Test error handling for filesystem permission issues. Integration test invoke from frontend.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:23:57.157Z"
          },
          {
            "id": 3,
            "title": "Create SettingsDialog Modal Component with Sidebar Navigation and Footer Actions",
            "description": "Implement the main SettingsDialog.tsx component as a modal with category sidebar, content area, search functionality, and Save/Cancel/Apply action buttons.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/settings/SettingsDialog.tsx. Accept props: isOpen (boolean), onClose (callback). Use a modal overlay with 80% viewport width/height, max 800x600px. Two-column layout: left sidebar (200px width) with category buttons (General, Simulation, Modbus, Appearance) styled with active indicator; right content area rendering the active settings panel. Add search input at top that filters settings by keyword (pass search term to child panels). Footer with three buttons: Cancel (calls discardPending and onClose), Apply (calls applyPending but keeps dialog open), Save (calls applyPending and onClose). Implement ESC key handler that checks for pending changes and shows unsaved warning confirmation before closing. Use Tailwind CSS for styling with dark mode support classes. Import and conditionally render GeneralSettings, SimulationSettings, ModbusSettings, AppearanceSettings based on activeCategory state. Export as named export for use in menu/toolbar triggers.",
            "status": "done",
            "testStrategy": "Test dialog renders when isOpen is true. Test clicking Cancel discards changes and closes. Test clicking Apply saves but keeps dialog open. Test clicking Save saves and closes. Test ESC key triggers unsaved changes warning when pendingChanges exists. Test sidebar navigation switches between panels. Test search input passes filter to child panels.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:28:36.309Z"
          },
          {
            "id": 4,
            "title": "Implement GeneralSettings and SimulationSettings Panel Components",
            "description": "Create the GeneralSettings panel with language, auto-save, startup, and telemetry options, and SimulationSettings panel with scan time, precision, speed, and step mode options.",
            "dependencies": [
              1,
              3
            ],
            "details": "Create src/components/settings/GeneralSettings.tsx with props: searchFilter (string optional). Render settings controls: Language selection dropdown with options 한국어/English/日本語 mapped to 'ko'/'en'/'ja'; Auto-save interval number input with 'seconds' label (min 30, step 10); Start with last project checkbox; Telemetry opt-in/out checkbox with explanation text. Each control calls updatePending from settingsStore on change. Display current value from settings merged with pendingChanges. Filter visibility based on searchFilter matching labels. Create src/components/settings/SimulationSettings.tsx similarly: Default scan time number input (ms) with range 1-1000; Timer precision dropdown (Low/Medium/High); Simulation speed multiplier radio buttons (0.5x/1x/2x/4x); Step execution mode dropdown (options: single-step, until-breakpoint, continuous). Use consistent styling with labels, descriptions, and Tailwind classes including dark mode variants.",
            "status": "done",
            "testStrategy": "Test GeneralSettings renders all four setting controls. Test language dropdown updates pendingChanges.language. Test auto-save input validates minimum value of 30. Test checkbox toggles update boolean settings. Test SimulationSettings renders all controls with correct options. Test search filter hides non-matching settings. Test current values display correctly from store.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:28:36.316Z"
          },
          {
            "id": 5,
            "title": "Implement ModbusSettings and AppearanceSettings Panel Components",
            "description": "Create the ModbusSettings panel with TCP/RTU configuration options and AppearanceSettings panel with theme, font size, grid, and animation toggles.",
            "dependencies": [
              1,
              3
            ],
            "details": "Create src/components/settings/ModbusSettings.tsx with: Default TCP port number input (range 1-65535, default 502); RTU serial settings section with: COM port dropdown (populated via invoke('list_serial_ports') or placeholder for manual entry), Baud rate dropdown (9600/19200/38400/57600/115200), Parity dropdown (None/Odd/Even), Stop bits dropdown (1/2); Connection timeout number input (ms, default 3000); Auto-reconnect checkbox. Group RTU settings visually with a fieldset or bordered section. Create src/components/settings/AppearanceSettings.tsx with: Theme selection as three radio buttons (Light/Dark/System) with icons; Font size slider input ranging 12px to 20px with current value display; Grid display toggle checkbox; Animation enable/disable checkbox. For theme, apply immediately on change for preview (using document.documentElement.classList.toggle('dark')). Style consistently with other panels, support dark mode, and implement searchFilter prop for filtering.",
            "status": "done",
            "testStrategy": "Test ModbusSettings renders TCP and RTU configuration sections. Test port input validates range 1-65535. Test RTU dropdowns have correct options. Test AppearanceSettings renders theme radios with correct values. Test font size slider respects 12-20 range. Test theme change applies immediately for preview. Test search filter works across both panels. Test all controls update pendingChanges correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T04:28:36.322Z"
          }
        ],
        "updatedAt": "2026-01-27T04:28:36.322Z"
      },
      {
        "id": "17",
        "title": "Implement Theme System with Dark Mode Support",
        "description": "Create theme provider supporting Light/Dark/System themes with Tailwind CSS dark mode class strategy and system preference detection.",
        "details": "1. Create `src/providers/ThemeProvider.tsx`:\n   ```typescript\n   type Theme = 'light' | 'dark' | 'system';\n   interface ThemeContextValue {\n     theme: Theme;\n     resolvedTheme: 'light' | 'dark'; // Actual applied theme\n     setTheme: (theme: Theme) => void;\n   }\n   const ThemeContext = createContext<ThemeContextValue>(...);\n   ```\n   - System theme detection: window.matchMedia('(prefers-color-scheme: dark)')\n   - Listen to matchMedia change event for auto-switch\n   - Apply 'dark' class to document.documentElement based on resolvedTheme\n\n2. Create `src/hooks/useTheme.ts`:\n   ```typescript\n   export function useTheme() {\n     const { theme, resolvedTheme, setTheme } = useContext(ThemeContext);\n     const isDark = resolvedTheme === 'dark';\n     return { theme, setTheme, isDark };\n   }\n   ```\n\n3. Configure Tailwind CSS for dark mode in `tailwind.config.js`:\n   ```javascript\n   module.exports = {\n     darkMode: 'class',\n     theme: {\n       extend: {\n         colors: {\n           // Custom semantic colors if needed\n         }\n       }\n     }\n   }\n   ```\n\n4. Create CSS custom properties for theme colors in `src/index.css`:\n   ```css\n   :root {\n     --color-bg-primary: theme('colors.white');\n     --color-text-primary: theme('colors.gray.900');\n     --color-border: theme('colors.gray.200');\n   }\n   .dark {\n     --color-bg-primary: theme('colors.gray.900');\n     --color-text-primary: theme('colors.gray.100');\n     --color-border: theme('colors.gray.700');\n   }\n   ```\n\n5. Update all existing components with dark mode variants:\n   - Background: `bg-white dark:bg-gray-900`\n   - Text: `text-gray-900 dark:text-gray-100`\n   - Borders: `border-gray-200 dark:border-gray-700`\n   - Hover states: `hover:bg-gray-100 dark:hover:bg-gray-800`\n   - Focus rings: adjust for visibility on dark backgrounds\n\n6. Add theme toggle locations:\n   - AppearanceSettings in settings dialog (primary)\n   - StatusBar quick toggle (moon/sun icon button)\n   - Activity bar settings icon tooltip menu (optional)\n\n7. Persist theme preference:\n   - Save to settingsStore.settings.theme\n   - Load on app start via ThemeProvider initialization\n   - Sync with Tauri settings persistence",
        "testStrategy": "1. Test theme toggle switches between light/dark visual appearance\n2. Test 'system' theme follows OS preference (mock matchMedia)\n3. Test theme persists after page reload (check localStorage or Tauri store)\n4. Test all components have proper dark mode styles (visual inspection)\n5. Test system preference change updates theme when 'system' selected\n6. Test quick toggle in StatusBar changes theme",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ThemeProvider Context and Provider Component",
            "description": "Implement the ThemeProvider.tsx component with React Context for theme management, supporting Light/Dark/System theme options with system preference detection.",
            "dependencies": [],
            "details": "Create src/providers/ThemeProvider.tsx with the following implementation:\n1. Define Theme type as 'light' | 'dark' | 'system'\n2. Define ThemeContextValue interface with theme (user selection), resolvedTheme ('light' | 'dark' actual applied), and setTheme function\n3. Create ThemeContext using React.createContext with default values\n4. Implement ThemeProvider component that:\n   - Uses useState for theme state (default: 'system')\n   - Uses useState for resolvedTheme state\n   - Implements getSystemTheme() using window.matchMedia('(prefers-color-scheme: dark)')\n   - Sets up useEffect to listen to matchMedia 'change' event for auto-switching when theme is 'system'\n   - Sets up useEffect to apply/remove 'dark' class on document.documentElement based on resolvedTheme\n   - Provides context value to children\n5. Export ThemeContext and ThemeProvider",
            "status": "done",
            "testStrategy": "Test ThemeProvider renders children correctly. Test context provides default values. Test setTheme updates theme state. Test resolvedTheme correctly reflects 'dark' when theme='dark' and 'light' when theme='light'. Mock window.matchMedia to test system theme detection returns correct value.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:31:57.473Z"
          },
          {
            "id": 2,
            "title": "Implement useTheme Custom Hook and Settings Store Integration",
            "description": "Create the useTheme hook for consuming theme context and integrate theme persistence with the existing settingsStore from Task 16.",
            "dependencies": [
              1
            ],
            "details": "1. Create src/hooks/useTheme.ts:\n   - Import ThemeContext from ThemeProvider\n   - Export useTheme hook that calls useContext(ThemeContext)\n   - Add convenience computed property isDark: resolvedTheme === 'dark'\n   - Return { theme, setTheme, resolvedTheme, isDark }\n   - Throw error if used outside ThemeProvider\n\n2. Integrate with settingsStore (from Task 16):\n   - Ensure AppSettings interface in settingsStore includes theme: 'light' | 'dark' | 'system'\n   - Update ThemeProvider to:\n     a. Read initial theme from settingsStore.settings.theme on mount\n     b. Call settingsStore.updatePending({ theme }) when setTheme is called\n   - Add effect to sync theme changes from settingsStore back to ThemeProvider\n\n3. Ensure theme persists via Tauri settings persistence (leveraging Task 16's save_app_settings command)",
            "status": "done",
            "testStrategy": "Test useTheme returns correct context values. Test useTheme throws when used outside provider. Test isDark computed property returns true when resolvedTheme is 'dark'. Test theme changes are synced to settingsStore.pendingChanges. Test initial theme is loaded from settingsStore on mount. Test theme persists after simulated page reload.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:32:03.596Z"
          },
          {
            "id": 3,
            "title": "Configure Tailwind CSS Dark Mode and CSS Custom Properties",
            "description": "Set up Tailwind CSS dark mode with class strategy and define CSS custom properties for semantic theme colors in the global stylesheet.",
            "dependencies": [],
            "details": "1. Update tailwind.config.js (create if not exists):\n   ```javascript\n   module.exports = {\n     darkMode: 'class',\n     content: ['./src/**/*.{js,ts,jsx,tsx}', './index.html'],\n     theme: {\n       extend: {\n         colors: {\n           // Optional semantic color aliases\n         }\n       }\n     },\n     plugins: []\n   }\n   ```\n\n2. Create/Update src/index.css with CSS custom properties:\n   ```css\n   @tailwind base;\n   @tailwind components;\n   @tailwind utilities;\n\n   :root {\n     --color-bg-primary: theme('colors.white');\n     --color-bg-secondary: theme('colors.gray.50');\n     --color-text-primary: theme('colors.gray.900');\n     --color-text-secondary: theme('colors.gray.600');\n     --color-border: theme('colors.gray.200');\n     --color-accent: theme('colors.blue.600');\n   }\n\n   .dark {\n     --color-bg-primary: theme('colors.gray.900');\n     --color-bg-secondary: theme('colors.gray.800');\n     --color-text-primary: theme('colors.gray.100');\n     --color-text-secondary: theme('colors.gray.400');\n     --color-border: theme('colors.gray.700');\n     --color-accent: theme('colors.blue.400');\n   }\n   ```",
            "status": "done",
            "testStrategy": "Test Tailwind dark: variants work by adding dark class to html element. Test CSS custom properties change values when .dark class is present on root. Verify tailwind.config.js has darkMode: 'class' setting. Visual inspection that colors transition correctly between modes.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:31:57.549Z"
          },
          {
            "id": 4,
            "title": "Create AppearanceSettings Panel with Theme Toggle",
            "description": "Implement the AppearanceSettings panel component for the Settings Dialog (Task 16) with theme selection dropdown, font size controls, and visual preference options.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create src/components/settings/AppearanceSettings.tsx:\n1. Import useTheme hook and useSettingsStore\n2. Create AppearanceSettingsProps interface with searchFilter?: string prop\n3. Implement theme selection using a dropdown/select:\n   - Options: 'Light', 'Dark', 'System (Auto)'\n   - Values: 'light', 'dark', 'system'\n   - onChange calls updatePending({ theme: selectedValue })\n   - Display current theme from pendingChanges.theme ?? settings.theme\n\n4. Add additional appearance settings (as per PRD):\n   - Font size slider/input (12-20px range)\n   - Grid display toggle checkbox\n   - Animation enable/disable checkbox\n\n5. Group settings with labels and implement search filtering:\n   - Each setting group has a label that can be filtered\n   - Hide settings that don't match searchFilter\n\n6. Style with Tailwind dark mode variants:\n   - bg-white dark:bg-gray-800 for containers\n   - text-gray-900 dark:text-gray-100 for text\n   - border-gray-200 dark:border-gray-700 for borders\n\n7. Register AppearanceSettings in SettingsDialog sidebar navigation",
            "status": "done",
            "testStrategy": "Test theme dropdown renders with three options. Test selecting theme calls updatePending with correct value. Test current theme displays from store. Test search filter hides non-matching settings. Test all controls render with correct dark mode styling. Test font size validates within range.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:32:03.602Z"
          },
          {
            "id": 5,
            "title": "Add Theme Quick Toggle to StatusBar and Update Existing Components",
            "description": "Add a theme quick toggle button to the StatusBar component and update all existing layout components with proper dark mode Tailwind variants.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "1. Update StatusBar component (src/components/layout/StatusBar.tsx):\n   - Import useTheme hook\n   - Add theme toggle button (sun/moon icon):\n     - Show SunIcon when isDark is true (click switches to light)\n     - Show MoonIcon when isDark is false (click switches to dark)\n     - Quick toggle cycles: light → dark → light (not system)\n     - Tooltip shows current theme and 'Click to toggle'\n   - Style toggle button: hover:bg-gray-100 dark:hover:bg-gray-800\n\n2. Update all existing layout components with dark mode variants:\n   - MainLayout.tsx: bg-gray-100 dark:bg-gray-900\n   - MenuBar.tsx: bg-white dark:bg-gray-800, text colors, borders\n   - Toolbar.tsx: icon colors, hover states\n   - Sidebar.tsx: bg-gray-50 dark:bg-gray-900, item hover states\n   - Panel.tsx: header bg, content bg, border colors\n   - TabBar.tsx: active/inactive tab styling\n   - ResizeHandle.tsx: handle colors for visibility\n\n3. Update common components:\n   - Button.tsx: primary, secondary, ghost variants with dark mode\n   - Tooltip.tsx: bg-gray-900 dark:bg-gray-100, inverted text\n\n4. Add focus ring adjustments for dark mode visibility:\n   - focus:ring-blue-500 dark:focus:ring-blue-400\n   - focus:ring-offset-white dark:focus:ring-offset-gray-900",
            "status": "done",
            "testStrategy": "Test StatusBar renders theme toggle button. Test clicking toggle switches between light and dark themes. Test toggle icon changes based on current theme. Test all layout components have proper dark mode classes applied. Visual inspection of all components in both light and dark modes. Test focus states are visible in both modes. Test hover states provide adequate contrast.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:33:10.693Z"
          }
        ],
        "updatedAt": "2026-01-27T05:33:10.693Z"
      },
      {
        "id": "18",
        "title": "Add Internationalization (i18n) Support",
        "description": "Implement multi-language support for Korean, English, and Japanese using react-i18next with translation files and language detection.",
        "details": "1. Install i18n dependencies:\n   ```bash\n   npm install react-i18next i18next i18next-browser-languagedetector\n   ```\n\n2. Create `src/i18n/index.ts`:\n   ```typescript\n   import i18n from 'i18next';\n   import { initReactI18next } from 'react-i18next';\n   import LanguageDetector from 'i18next-browser-languagedetector';\n   import en from './locales/en.json';\n   import ko from './locales/ko.json';\n   import ja from './locales/ja.json';\n\n   i18n\n     .use(LanguageDetector)\n     .use(initReactI18next)\n     .init({\n       resources: { en: { translation: en }, ko: { translation: ko }, ja: { translation: ja } },\n       fallbackLng: 'en',\n       interpolation: { escapeValue: false },\n       detection: { order: ['localStorage', 'navigator'] }\n     });\n   export default i18n;\n   ```\n\n3. Create translation files structure:\n   - `src/i18n/locales/en.json`:\n     ```json\n     {\n       \"menu\": {\n         \"file\": { \"label\": \"File\", \"new\": \"New Project\", \"open\": \"Open Project\", \"save\": \"Save\", ... },\n         \"edit\": { \"label\": \"Edit\", \"undo\": \"Undo\", \"redo\": \"Redo\", ... },\n         ...\n       },\n       \"dialog\": { \"newProject\": { \"title\": \"New Project\", \"name\": \"Project Name\", ... } },\n       \"status\": { \"running\": \"Running\", \"stopped\": \"Stopped\", \"paused\": \"Paused\" },\n       \"settings\": { ... },\n       \"errors\": { \"projectNotFound\": \"Project not found: {{path}}\", ... }\n     }\n     ```\n   - `src/i18n/locales/ko.json`: Korean translations\n   - `src/i18n/locales/ja.json`: Japanese translations\n\n4. Create type-safe translation hook in `src/hooks/useTranslation.ts`:\n   ```typescript\n   import { useTranslation as useI18nTranslation } from 'react-i18next';\n   // Re-export with app-specific typing if needed\n   export function useTranslation() {\n     return useI18nTranslation();\n   }\n   ```\n\n5. Update all UI components to use translations:\n   - Import useTranslation hook\n   - Replace hardcoded strings: `t('menu.file.new')` instead of 'New Project'\n   - Use Trans component for complex translations with JSX\n   - Example: `<span>{t('status.running')}</span>`\n\n6. Add language selector to Settings:\n   - Dropdown in GeneralSettings with options\n   - onChange calls i18n.changeLanguage(lng)\n   - Immediate UI update on change\n\n7. Persist language preference:\n   - Save to settingsStore.settings.language\n   - Apply on app initialization\n   - Sync with i18n instance",
        "testStrategy": "1. Test language switch updates all visible text immediately\n2. Test fallback to English for missing translation keys\n3. Test language persists after page reload\n4. Test interpolation works (e.g., error messages with {{path}})\n5. Test language detector picks up browser preference initially\n6. Test all major UI areas have translation coverage",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install i18n Dependencies and Create Core Configuration",
            "description": "Install react-i18next, i18next, and i18next-browser-languagedetector packages. Create the i18n initialization module at src/i18n/index.ts with language detection, fallback, and resource loading setup.",
            "dependencies": [],
            "details": "1. Run npm install to add dependencies:\n   - react-i18next (React bindings for i18next)\n   - i18next (core internationalization framework)\n   - i18next-browser-languagedetector (automatic language detection)\n\n2. Create src/i18n/index.ts with:\n   - Import i18n from 'i18next'\n   - Import initReactI18next from 'react-i18next'\n   - Import LanguageDetector from 'i18next-browser-languagedetector'\n   - Configure detection order: ['localStorage', 'navigator']\n   - Set fallbackLng to 'en'\n   - Set interpolation.escapeValue to false (React handles escaping)\n   - Import and register translation resources for en, ko, ja\n   - Export configured i18n instance\n\n3. Import i18n in main entry point (src/main.tsx or App.tsx) to initialize before app renders",
            "status": "done",
            "testStrategy": "Verify all 3 npm packages install successfully. Test i18n initializes without errors on app startup. Test browser language detection picks up system locale correctly. Test fallback to English when unsupported language detected.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:36:52.672Z"
          },
          {
            "id": 2,
            "title": "Create Translation JSON Files with Comprehensive UI Text Structure",
            "description": "Create locale JSON files for English, Korean, and Japanese at src/i18n/locales/ with organized namespace structure covering menus, dialogs, status messages, settings, and error messages.",
            "dependencies": [
              1
            ],
            "details": "1. Create directory structure: src/i18n/locales/\n\n2. Create src/i18n/locales/en.json with namespaced structure:\n   - menu: { file: { label, new, open, save, saveAs, recent, exit }, edit: { label, undo, redo, cut, copy, paste }, view: { label, toggleSidebar, resetLayout }, simulation: { label, start, stop, pause, step, reset }, modbus: { label, serverSettings, startServer, stopServer }, help: { label, documentation, about } }\n   - dialog: { newProject: { title, name, description, path }, openProject: { title }, settings: { title, save, cancel, apply } }\n   - status: { running, stopped, paused, connected, disconnected }\n   - settings: { general: { language, autoSave, startup }, simulation: { scanTime, precision }, modbus: { tcpPort, rtuPort }, appearance: { theme, fontSize } }\n   - errors: { projectNotFound, saveError, loadError, invalidPath } with {{variable}} interpolation\n   - common: { ok, cancel, save, delete, create, close }\n\n3. Create src/i18n/locales/ko.json with Korean translations matching the same structure\n\n4. Create src/i18n/locales/ja.json with Japanese translations matching the same structure\n\n5. Ensure all keys exist in all 3 files for consistency",
            "status": "done",
            "testStrategy": "Validate JSON syntax is correct for all 3 files. Verify key structure is identical across all locales. Test interpolation variables like {{path}} render correctly. Test special characters (Korean hangul, Japanese kanji/hiragana) display properly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:36:52.679Z"
          },
          {
            "id": 3,
            "title": "Create Type-Safe useTranslation Hook and Translation Utilities",
            "description": "Implement a type-safe wrapper around react-i18next's useTranslation hook in src/hooks/useTranslation.ts with TypeScript support for translation keys and a Trans component helper for JSX interpolation.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Create src/types/i18n.ts with TypeScript type definitions:\n   - Define TranslationKey type based on JSON structure for autocomplete support\n   - Define supported languages type: 'en' | 'ko' | 'ja'\n\n2. Create src/hooks/useTranslation.ts:\n   - Re-export useTranslation from react-i18next with app-specific typing\n   - Export convenience function for namespace-scoped translations\n   - Add useLanguage hook returning current language and changeLanguage function\n   - Include typed t() function with key path support (e.g., 'menu.file.new')\n\n3. Create src/components/common/Trans.tsx:\n   - Wrapper around react-i18next Trans component\n   - Support for JSX interpolation in translations\n   - Type-safe props for translation keys\n\n4. Export all utilities from src/i18n/index.ts for convenient imports\n\n5. Add helper function formatTranslation() for dynamic key construction",
            "status": "done",
            "testStrategy": "Test useTranslation hook returns t function that resolves keys correctly. Test TypeScript catches invalid translation keys at compile time. Test useLanguage hook returns correct current language. Test Trans component renders JSX interpolation properly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:36:52.685Z"
          },
          {
            "id": 4,
            "title": "Integrate Language Selector in Settings Dialog with Persistence",
            "description": "Add language selection dropdown to GeneralSettings panel (from Task 16) that triggers immediate UI language change, persists selection to settingsStore, and syncs with i18n instance on app initialization.",
            "dependencies": [
              3
            ],
            "details": "1. Update GeneralSettings.tsx (from Task 16 subtask 4):\n   - Add language dropdown with options: English, 한국어, 日本語\n   - Each option has value ('en', 'ko', 'ja') and display label in native language\n   - On change, call i18n.changeLanguage(lng) for immediate UI update\n   - Update settingsStore.pendingChanges.language\n\n2. Update AppSettings interface in settingsStore.ts:\n   - Add language: 'en' | 'ko' | 'ja' field with default 'en'\n   - Include language in persistence via save_app_settings command\n\n3. Update settings.rs Tauri command (from Task 16 subtask 2):\n   - Include language field in AppSettings struct\n   - Persist to settings.json\n\n4. Create language sync on app startup:\n   - In App.tsx or useEffect in MainLayout, read language from settingsStore\n   - Call i18n.changeLanguage(storedLanguage) to sync\n   - Ensure this runs after settingsStore loads from Tauri\n\n5. Handle language change side effects:\n   - Update document lang attribute for accessibility\n   - Consider right-to-left support flag for future languages",
            "status": "done",
            "testStrategy": "Test language dropdown shows all 3 options with native labels. Test selecting a language immediately updates all visible UI text. Test language persists after app restart via Tauri storage. Test initial app load respects stored language preference over browser detection.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:36:52.691Z"
          },
          {
            "id": 5,
            "title": "Apply Translations to All UI Components and Create Usage Guidelines",
            "description": "Systematically replace hardcoded strings in all UI components (MenuBar, Toolbar, StatusBar, Dialogs, Panels, Settings) with translation keys using the t() function, and document i18n usage patterns for future development.",
            "dependencies": [
              3,
              4
            ],
            "details": "1. Update MenuBar.tsx (from Task 11):\n   - Replace all menu labels with t('menu.file.label'), t('menu.file.new'), etc.\n   - Update all keyboard shortcut tooltips\n\n2. Update Toolbar.tsx (from Task 11):\n   - Replace button tooltips with translations\n   - Use t() for icon button aria-labels\n\n3. Update StatusBar.tsx (from Task 11):\n   - Replace status text: t('status.running'), t('status.stopped'), etc.\n   - Translate connection status messages\n\n4. Update all Dialog components:\n   - NewProjectDialog, OpenProjectDialog: titles, labels, buttons\n   - SettingsDialog: section titles, field labels\n   - Use t() for all user-visible text\n\n5. Update Panel components:\n   - Panel headers, tab labels, placeholder text\n   - Context menu items\n\n6. Create src/docs/i18n-guide.md (internal documentation):\n   - Usage patterns: t('key'), t('key', { variable }), <Trans> component\n   - Adding new translation keys checklist\n   - Testing translations locally\n   - Naming conventions for translation keys\n\n7. Add eslint rule or comments to flag untranslated strings in future PRs",
            "status": "done",
            "testStrategy": "Test switching language updates MenuBar, Toolbar, StatusBar text immediately. Test error messages display with interpolated values (e.g., file paths). Test all dialogs show translated titles and button labels. Test no hardcoded user-visible strings remain in UI components. Test fallback to English for any missing keys shows key path (development warning).",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T05:36:59.590Z"
          }
        ],
        "updatedAt": "2026-01-27T05:36:59.590Z"
      },
      {
        "id": "19",
        "title": "Create Layout Persistence and Preset System",
        "description": "Implement layout serialization for save/restore, built-in layout presets (Default, Compact, Debug, Memory Focus), and user custom preset management.",
        "details": "1. Define layout serialization format in `src/types/layout.ts`:\n   ```typescript\n   interface LayoutConfig {\n     name: string;\n     grid: { columns: string[], rows: string[] };\n     panels: {\n       id: string;\n       type: PanelType;\n       gridArea: string;\n       tabs?: { type: PanelType, title: string }[];\n     }[];\n     sidebar: { visible: boolean, width: number, activePanel: string };\n     isBuiltIn?: boolean; // Cannot be deleted if true\n   }\n   ```\n\n2. Create built-in layout presets:\n   - **Default**: 2x2 grid with Ladder Editor (top-left), Memory Visualizer (top-right), One Canvas (bottom-left), Console (bottom-right)\n   - **Compact**: Single panel area with all panels as tabs\n   - **Debug**: 2 rows - main panels top, Console expanded bottom (70/30 split)\n   - **Memory Focus**: Large Memory Visualizer (80% width), Properties panel side\n\n3. Add layout management to panelStore:\n   ```typescript\n   // Additional state and actions:\n   currentLayoutName: string;\n   savedLayouts: LayoutConfig[];\n   saveLayout: (name: string) => void;\n   loadLayout: (name: string) => void;\n   deleteLayout: (name: string) => void;\n   resetToDefault: () => void;\n   exportLayout: (name: string) => LayoutConfig;\n   importLayout: (config: LayoutConfig) => void;\n   getAvailableLayouts: () => LayoutConfig[];\n   ```\n\n4. Create Tauri commands for layout persistence:\n   - In `src-tauri/src/commands/layout.rs`:\n     - `#[tauri::command] save_layout(name: String, config: LayoutConfig) -> Result<(), String>`\n     - `#[tauri::command] load_layout(name: String) -> Result<LayoutConfig, String>`\n     - `#[tauri::command] list_layouts() -> Result<Vec<String>, String>`\n     - `#[tauri::command] delete_layout(name: String) -> Result<(), String>`\n   - Store in app data directory as `layouts.json`\n\n5. Add layout menu in View menu:\n   - Submenu with list of available presets (built-in + user)\n   - Checkmark on currently active layout\n   - Separator line between built-in and user layouts\n   - 'Save Current Layout As...' opens name input dialog\n   - 'Reset Layout' restores Default preset\n\n6. Auto-save layout on application close:\n   - Listen to Tauri window close event\n   - Save current layout as '_lastSession' special preset\n   - On app start, optionally restore last session layout\n\n7. Create `src/components/layout/SaveLayoutDialog.tsx`:\n   - Modal with name input\n   - Shows preview of layout (simplified grid visualization)\n   - Warn if name conflicts with existing",
        "testStrategy": "1. Test saveLayout stores all panel positions and grid config\n2. Test loadLayout restores exact panel arrangement\n3. Test built-in presets (Default, Compact, etc.) apply correct layouts\n4. Test layout persists across app restarts via Tauri storage\n5. Test delete only works for user layouts, not built-in\n6. Test last session layout restored on startup when enabled",
        "priority": "medium",
        "dependencies": [
          "13",
          "16"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Layout Types and Serialization Format",
            "description": "Create TypeScript interfaces for layout configuration in src/types/layout.ts and corresponding Rust structs in src-tauri/src/types/layout.rs for serialization.",
            "dependencies": [],
            "details": "Create src/types/layout.ts with the following interfaces:\n\n1. LayoutConfig interface:\n   - name: string (layout preset name)\n   - grid: { columns: string[], rows: string[] } (CSS grid template definitions)\n   - panels: array of panel configurations with id, type (PanelType), gridArea, and optional tabs\n   - sidebar: { visible: boolean, width: number, activePanel: string }\n   - isBuiltIn?: boolean (prevents deletion if true)\n\n2. Supporting types:\n   - PanelLayoutConfig: { id: string, type: PanelType, gridArea: string, tabs?: TabConfig[] }\n   - TabConfig: { type: PanelType, title: string }\n   - GridConfig: { columns: string[], rows: string[] }\n   - SidebarConfig: { visible: boolean, width: number, activePanel: string }\n\n3. Create corresponding Rust structs in src-tauri/src/types/layout.rs:\n   - LayoutConfig with #[derive(Serialize, Deserialize, Clone)]\n   - PanelLayoutConfig, TabConfig, GridConfig, SidebarConfig\n   - Ensure field names match TypeScript (use serde rename if needed)\n\n4. Export types from src/types/index.ts for easy importing throughout the application.",
            "status": "pending",
            "testStrategy": "Unit test that LayoutConfig can be serialized to JSON and deserialized back correctly. Test that all required fields are present. Test TypeScript compilation catches missing required fields. Test Rust structs serialize/deserialize with serde_json. Verify round-trip serialization preserves all data.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Built-in Layout Presets",
            "description": "Define the four built-in layout presets (Default, Compact, Debug, Memory Focus) as constant configurations with isBuiltIn flag set to true.",
            "dependencies": [
              1
            ],
            "details": "Create src/config/layoutPresets.ts with the following presets:\n\n1. DEFAULT_LAYOUT:\n   - 2x2 grid: columns ['1fr', '1fr'], rows ['1fr', '1fr']\n   - Panels: Ladder Editor (top-left, gridArea: '1/1/2/2'), Memory Visualizer (top-right, gridArea: '1/2/2/3'), One Canvas (bottom-left, gridArea: '2/1/3/2'), Console (bottom-right, gridArea: '2/2/3/3')\n   - Sidebar: visible=true, width=250, activePanel='explorer'\n   - isBuiltIn=true\n\n2. COMPACT_LAYOUT:\n   - 1x1 grid: columns ['1fr'], rows ['1fr']\n   - Single panel with all panels as tabs array\n   - isBuiltIn=true\n\n3. DEBUG_LAYOUT:\n   - 2-row split (70/30): columns ['1fr'], rows ['70fr', '30fr']\n   - Main panels as tabs (top), Console expanded (bottom)\n   - isBuiltIn=true\n\n4. MEMORY_FOCUS_LAYOUT:\n   - 2-column split (80/20): columns ['80fr', '20fr'], rows ['1fr']\n   - Large Memory Visualizer (left), Properties panel (right)\n   - isBuiltIn=true\n\n5. Export BUILT_IN_LAYOUTS array containing all presets\n6. Export getPresetByName(name: string) helper function",
            "status": "pending",
            "testStrategy": "Test each preset has isBuiltIn=true. Test DEFAULT_LAYOUT has exactly 4 panels in correct grid positions. Test COMPACT_LAYOUT has single panel with 4 tabs. Test DEBUG_LAYOUT has 70/30 split ratio. Test MEMORY_FOCUS_LAYOUT has 80/20 split. Test getPresetByName returns correct preset or undefined for unknown names.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Tauri Commands for Layout Persistence",
            "description": "Create Rust Tauri commands for saving, loading, listing, and deleting layouts with file-based persistence in the app data directory.",
            "dependencies": [
              1
            ],
            "details": "Create src-tauri/src/commands/layout.rs with the following commands:\n\n1. #[tauri::command] pub async fn save_layout(app: AppHandle, name: String, config: LayoutConfig) -> Result<(), String>\n   - Validate name is not empty and doesn't contain invalid characters\n   - Load existing layouts.json from app_data_dir\n   - Add/update layout in the list\n   - Write back to layouts.json with pretty formatting\n   - Handle file creation if doesn't exist\n\n2. #[tauri::command] pub async fn load_layout(app: AppHandle, name: String) -> Result<LayoutConfig, String>\n   - Read layouts.json from app_data_dir\n   - Find layout by name, return error if not found\n   - Return the LayoutConfig\n\n3. #[tauri::command] pub async fn list_layouts(app: AppHandle) -> Result<Vec<String>, String>\n   - Read layouts.json, return list of layout names\n   - Return empty vec if file doesn't exist\n\n4. #[tauri::command] pub async fn delete_layout(app: AppHandle, name: String) -> Result<(), String>\n   - Check isBuiltIn flag, return error if true\n   - Remove layout from list and save\n\n5. Register commands in src-tauri/src/lib.rs tauri::Builder\n6. Use tauri::path::BaseDirectory::AppData for storage location\n7. Create LayoutStorage struct to encapsulate file operations",
            "status": "pending",
            "testStrategy": "Test save_layout creates layouts.json if not exists. Test load_layout returns error for non-existent layout. Test list_layouts returns empty vec for new installation. Test delete_layout fails for built-in layouts with appropriate error message. Test save then load returns identical config. Test concurrent saves don't corrupt file. Integration test with actual Tauri app context.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Extend panelStore with Layout Management Actions",
            "description": "Add layout management state and actions to the existing panelStore including save, load, delete, export, import, and preset selection functionality.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Extend src/stores/panelStore.ts with layout management:\n\n1. Add new state properties:\n   - currentLayoutName: string (name of currently active layout)\n   - savedLayouts: LayoutConfig[] (cached list of user layouts)\n   - isLayoutModified: boolean (track unsaved changes)\n\n2. Add new actions:\n   - saveLayout: (name: string) => Promise<void> - serialize current state, call Tauri save_layout\n   - loadLayout: (name: string) => Promise<void> - call Tauri load_layout, apply to state\n   - deleteLayout: (name: string) => Promise<void> - call Tauri delete_layout, refresh savedLayouts\n   - resetToDefault: () => void - load DEFAULT_LAYOUT preset\n   - exportLayout: (name: string) => LayoutConfig - return current state as LayoutConfig\n   - importLayout: (config: LayoutConfig) => void - apply external config to state\n   - getAvailableLayouts: () => LayoutConfig[] - return built-in + user layouts\n   - refreshSavedLayouts: () => Promise<void> - reload from Tauri storage\n   - setLayoutModified: (modified: boolean) => void\n\n3. Helper functions:\n   - serializeCurrentLayout(): LayoutConfig - convert current store state to config\n   - applyLayoutConfig(config: LayoutConfig): void - apply config to store state\n\n4. Initialize savedLayouts on store creation by calling refreshSavedLayouts\n5. Track layout modifications by subscribing to relevant state changes",
            "status": "pending",
            "testStrategy": "Test saveLayout calls Tauri command with serialized state. Test loadLayout applies config to panels, grid, and sidebar state. Test deleteLayout removes from savedLayouts cache. Test resetToDefault applies DEFAULT_LAYOUT. Test getAvailableLayouts returns combined built-in and user layouts. Test isLayoutModified becomes true when panels change. Test export/import round-trip preserves layout. Mock Tauri invoke for unit tests.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create SaveLayoutDialog and View Menu Integration",
            "description": "Implement the SaveLayoutDialog modal component and integrate layout selection/management into the View menu with auto-save on close functionality.",
            "dependencies": [
              2,
              4
            ],
            "details": "1. Create src/components/layout/SaveLayoutDialog.tsx:\n   - Modal with name input field (validate non-empty, no special chars)\n   - Show simplified grid preview of current layout\n   - Warning message if name conflicts with existing layout\n   - Checkbox for 'Replace existing' when name exists\n   - Save and Cancel buttons\n   - Call panelStore.saveLayout on confirm\n\n2. Update MenuBar View menu (src/components/layout/MenuBar.tsx):\n   - Add 'Layouts' submenu\n   - List built-in presets with separator (Default, Compact, Debug, Memory Focus)\n   - List user layouts below separator (from panelStore.savedLayouts)\n   - Checkmark on currentLayoutName\n   - 'Save Current Layout As...' opens SaveLayoutDialog\n   - 'Reset Layout' calls panelStore.resetToDefault()\n   - 'Manage Layouts...' submenu with delete options for user layouts\n\n3. Implement auto-save on close:\n   - Listen to Tauri window close-requested event in App.tsx\n   - Save current layout as '_lastSession' before closing\n   - On app start, check settings for 'restoreLastSession' flag\n   - If enabled, call loadLayout('_lastSession')\n\n4. Add keyboard shortcut Ctrl+Shift+S for 'Save Layout As...' in layoutStore shortcuts\n5. Create src/components/layout/LayoutPreview.tsx for simplified grid visualization in dialog",
            "status": "pending",
            "testStrategy": "Test SaveLayoutDialog validates empty name shows error. Test name conflict shows warning message. Test Save button calls saveLayout with entered name. Test Cancel closes dialog without saving. Test View menu shows all built-in presets. Test checkmark appears on active layout. Test clicking preset calls loadLayout. Test auto-save triggers on window close event. Test '_lastSession' layout restores on startup when enabled. E2E test: create layout, restart app, verify restored.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "20",
        "title": "Implement ModbusMemory Struct with Memory Map",
        "description": "Create Rust ModbusMemory struct managing Coils, Discrete Inputs, Holding Registers, and Input Registers with thread-safe access and CSV snapshot support.",
        "details": "1. Add dependencies to `src-tauri/Cargo.toml`:\n   ```toml\n   bitvec = \"1\"\n   parking_lot = \"0.12\"\n   ```\n\n2. Create modbus module structure in `src-tauri/src/modbus/`:\n   ```\n   modbus/\n   ├── mod.rs\n   ├── memory.rs\n   ├── server.rs\n   ├── tcp.rs\n   ├── rtu.rs\n   ├── protocol.rs\n   └── types.rs\n   ```\n\n3. Create `src-tauri/src/modbus/memory.rs`:\n   ```rust\n   use bitvec::prelude::*;\n   use parking_lot::RwLock;\n\n   pub struct ModbusMemory {\n       coils: RwLock<BitVec<u8, Msb0>>,\n       discrete_inputs: RwLock<BitVec<u8, Msb0>>,\n       holding_registers: RwLock<Vec<u16>>,\n       input_registers: RwLock<Vec<u16>>,\n       config: MemoryMapSettings,\n   }\n   ```\n\n4. Implement memory access methods:\n   ```rust\n   impl ModbusMemory {\n     pub fn new(config: &MemoryMapSettings) -> Self;\n\n     // Coils (Function codes 0x01, 0x05, 0x0F)\n     pub fn read_coils(&self, start: u16, count: u16) -> Result<Vec<bool>, MemoryError>;\n     pub fn write_coil(&self, address: u16, value: bool) -> Result<(), MemoryError>;\n     pub fn write_coils(&self, start: u16, values: &[bool]) -> Result<(), MemoryError>;\n\n     // Discrete Inputs (Function code 0x02)\n     pub fn read_discrete_inputs(&self, start: u16, count: u16) -> Result<Vec<bool>, MemoryError>;\n     pub fn write_discrete_input(&self, address: u16, value: bool) -> Result<(), MemoryError>; // Internal use\n\n     // Holding Registers (Function codes 0x03, 0x06, 0x10)\n     pub fn read_holding_registers(&self, start: u16, count: u16) -> Result<Vec<u16>, MemoryError>;\n     pub fn write_holding_register(&self, address: u16, value: u16) -> Result<(), MemoryError>;\n     pub fn write_holding_registers(&self, start: u16, values: &[u16]) -> Result<(), MemoryError>;\n\n     // Input Registers (Function code 0x04)\n     pub fn read_input_registers(&self, start: u16, count: u16) -> Result<Vec<u16>, MemoryError>;\n     pub fn write_input_register(&self, address: u16, value: u16) -> Result<(), MemoryError>; // Internal use\n   }\n   ```\n\n5. Add bounds checking and error handling:\n   ```rust\n   #[derive(Error, Debug)]\n   pub enum MemoryError {\n     #[error(\"Address out of range: {address} (valid: {start}-{end})\")]\n     AddressOutOfRange { address: u16, start: u16, end: u16 },\n     #[error(\"Count exceeds available range: requested {count} from {address}, available {available}\")]\n     CountExceedsRange { address: u16, count: u16, available: u16 },\n   }\n   ```\n\n6. Implement CSV snapshot:\n   ```rust\n   pub fn save_to_csv(&self, path: &Path) -> Result<(), std::io::Error>;\n   pub fn load_from_csv(&self, path: &Path) -> Result<(), std::io::Error>;\n   // Format: address,type,value (e.g., '0,coil,1' or '40001,holding,1234')\n   ```",
        "testStrategy": "1. Unit test read/write for each memory type at various addresses\n2. Test boundary conditions (address=0, address=max-1, count spanning end)\n3. Test error returned for out-of-range address access\n4. Test CSV save and load roundtrip preserves all data\n5. Test concurrent read/write with multiple threads using RwLock\n6. Test memory initialized with correct size from MemoryMapSettings",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Modbus Module Structure and Dependencies",
            "description": "Create the modbus module directory structure under src-tauri/src/modbus/ and add required dependencies (bitvec, parking_lot, thiserror) to Cargo.toml.",
            "dependencies": [],
            "details": "1. Add dependencies to src-tauri/Cargo.toml:\n   - bitvec = \"1\" (for efficient bit vector storage of coils and discrete inputs)\n   - parking_lot = \"0.12\" (for high-performance RwLock)\n   - thiserror = \"1\" (for error type derivation)\n\n2. Create the modbus module directory structure:\n   - src-tauri/src/modbus/mod.rs (module entry point with pub mod declarations)\n   - src-tauri/src/modbus/memory.rs (ModbusMemory struct)\n   - src-tauri/src/modbus/types.rs (shared types including MemoryError)\n\n3. In mod.rs, declare public modules:\n   ```rust\n   pub mod memory;\n   pub mod types;\n   ```\n\n4. Ensure the modbus module is declared in src-tauri/src/lib.rs or main.rs.",
            "status": "done",
            "testStrategy": "Verify Cargo.toml compiles successfully with new dependencies. Verify module structure is correct by running 'cargo check' in src-tauri directory.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:45:30.092Z"
          },
          {
            "id": 2,
            "title": "Define MemoryError Type and Memory Configuration Types",
            "description": "Create the MemoryError enum with thiserror for address out-of-range and count exceeded errors, plus any configuration types needed for memory initialization.",
            "dependencies": [
              1
            ],
            "details": "1. Create src-tauri/src/modbus/types.rs with:\n   ```rust\n   use thiserror::Error;\n\n   #[derive(Error, Debug)]\n   pub enum MemoryError {\n       #[error(\"Address out of range: {address} (valid: {start}-{end})\")]\n       AddressOutOfRange { address: u16, start: u16, end: u16 },\n       #[error(\"Count exceeds available range: requested {count} from {address}, available {available}\")]\n       CountExceedsRange { address: u16, count: u16, available: u16 },\n       #[error(\"Invalid count: {count} (must be > 0)\")]\n       InvalidCount { count: u16 },\n   }\n   ```\n\n2. Define MemoryMapSettings struct (or reference from project config module if already exists from Task 3):\n   ```rust\n   pub struct MemoryMapSettings {\n       pub coil_count: u16,\n       pub discrete_input_count: u16,\n       pub holding_register_count: u16,\n       pub input_register_count: u16,\n   }\n   ```\n\n3. Implement Default trait for MemoryMapSettings with sensible defaults (e.g., 65536 for each).",
            "status": "done",
            "testStrategy": "Unit test that MemoryError can be created and displays correct error messages. Test Default implementation for MemoryMapSettings returns expected values.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:45:30.100Z"
          },
          {
            "id": 3,
            "title": "Implement ModbusMemory Struct with Core Read/Write Methods",
            "description": "Create the ModbusMemory struct with RwLock-protected fields for all four memory types and implement all read/write methods with proper bounds checking.",
            "dependencies": [
              2
            ],
            "details": "1. Create src-tauri/src/modbus/memory.rs with:\n   ```rust\n   use bitvec::prelude::*;\n   use parking_lot::RwLock;\n   use super::types::{MemoryError, MemoryMapSettings};\n\n   pub struct ModbusMemory {\n       coils: RwLock<BitVec<u8, Msb0>>,\n       discrete_inputs: RwLock<BitVec<u8, Msb0>>,\n       holding_registers: RwLock<Vec<u16>>,\n       input_registers: RwLock<Vec<u16>>,\n       config: MemoryMapSettings,\n   }\n   ```\n\n2. Implement constructor:\n   - pub fn new(config: &MemoryMapSettings) -> Self\n   - Initialize all vectors/bitvecs to config sizes with zeros\n\n3. Implement Coil methods (Function codes 0x01, 0x05, 0x0F):\n   - pub fn read_coils(&self, start: u16, count: u16) -> Result<Vec<bool>, MemoryError>\n   - pub fn write_coil(&self, address: u16, value: bool) -> Result<(), MemoryError>\n   - pub fn write_coils(&self, start: u16, values: &[bool]) -> Result<(), MemoryError>\n\n4. Implement Discrete Input methods (Function code 0x02):\n   - pub fn read_discrete_inputs(&self, start: u16, count: u16) -> Result<Vec<bool>, MemoryError>\n   - pub fn write_discrete_input(&self, address: u16, value: bool) -> Result<(), MemoryError> // Internal use\n\n5. Implement Holding Register methods (Function codes 0x03, 0x06, 0x10):\n   - pub fn read_holding_registers(&self, start: u16, count: u16) -> Result<Vec<u16>, MemoryError>\n   - pub fn write_holding_register(&self, address: u16, value: u16) -> Result<(), MemoryError>\n   - pub fn write_holding_registers(&self, start: u16, values: &[u16]) -> Result<(), MemoryError>\n\n6. Implement Input Register methods (Function code 0x04):\n   - pub fn read_input_registers(&self, start: u16, count: u16) -> Result<Vec<u16>, MemoryError>\n   - pub fn write_input_register(&self, address: u16, value: u16) -> Result<(), MemoryError> // Internal use\n\n7. All methods must validate bounds and return appropriate MemoryError variants.",
            "status": "done",
            "testStrategy": "Unit test read/write for each memory type at address 0, middle addresses, and max-1. Test boundary conditions where count spans end of range. Test error returned for out-of-range addresses. Test concurrent read/write with multiple threads using RwLock.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:45:30.106Z"
          },
          {
            "id": 4,
            "title": "Implement CSV Snapshot Save and Load Functionality",
            "description": "Add save_to_csv and load_from_csv methods to ModbusMemory for persisting and restoring memory state with format: address,type,value per line.",
            "dependencies": [
              3
            ],
            "details": "1. Add CSV format handling to memory.rs:\n   - Format: 'address,type,value' per line\n   - Types: 'coil', 'discrete', 'holding', 'input'\n   - Values: 0/1 for bits, 0-65535 for registers\n   - Example lines:\n     - '0,coil,1'\n     - '40001,holding,1234'\n     - '10000,discrete,0'\n     - '30001,input,5678'\n\n2. Implement save_to_csv:\n   ```rust\n   pub fn save_to_csv(&self, path: &Path) -> Result<(), std::io::Error>\n   ```\n   - Acquire read locks on all memory sections\n   - Write header line (optional): 'address,type,value'\n   - Iterate through all non-zero values and write to CSV\n   - Or write all values for complete snapshot (configurable)\n\n3. Implement load_from_csv:\n   ```rust\n   pub fn load_from_csv(&self, path: &Path) -> Result<(), std::io::Error>\n   ```\n   - Parse CSV file line by line\n   - Validate address ranges before writing\n   - Clear existing memory or merge (configurable)\n   - Handle parsing errors gracefully\n\n4. Add helper method for address-to-type mapping if using Modbus addressing convention:\n   - 0x0000-0xFFFF: Coils\n   - 1x0000-1xFFFF: Discrete Inputs\n   - 3x0000-3xFFFF: Input Registers\n   - 4x0000-4xFFFF: Holding Registers",
            "status": "done",
            "testStrategy": "Test CSV save creates valid file with correct format. Test CSV load restores all data correctly. Test save/load roundtrip preserves all data types and values. Test load handles missing file gracefully. Test load validates address ranges and rejects invalid entries.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:45:30.112Z"
          },
          {
            "id": 5,
            "title": "Add Unit Tests for ModbusMemory Module",
            "description": "Create comprehensive unit tests covering all ModbusMemory functionality including concurrent access, boundary conditions, error cases, and CSV operations.",
            "dependencies": [
              4
            ],
            "details": "1. Create test module in memory.rs or separate test file:\n   ```rust\n   #[cfg(test)]\n   mod tests {\n       use super::*;\n       use std::sync::Arc;\n       use std::thread;\n   }\n   ```\n\n2. Test memory initialization:\n   - Test new() creates memory with correct sizes from config\n   - Test all values initialized to zero\n\n3. Test read operations:\n   - Read single value at start, middle, end of range\n   - Read multiple values\n   - Read entire range\n\n4. Test write operations:\n   - Write single value\n   - Write multiple values\n   - Write at boundary addresses\n\n5. Test error conditions:\n   - Address out of range (> max)\n   - Count exceeds available range\n   - Zero count handling\n\n6. Test concurrent access:\n   - Multiple readers simultaneously\n   - Reader and writer simultaneously\n   - Multiple writers (sequential due to exclusive lock)\n   - Use Arc<ModbusMemory> with thread::spawn\n\n7. Test CSV operations:\n   - Save to temporary file\n   - Load from saved file\n   - Roundtrip preserves all values\n   - Handle malformed CSV gracefully\n\n8. Test with MemoryMapSettings variations:\n   - Default settings\n   - Minimum sizes (1 element each)\n   - Maximum practical sizes",
            "status": "done",
            "testStrategy": "Run 'cargo test' in src-tauri directory. All tests should pass. Test coverage should include all public methods, error paths, and concurrent access patterns. Consider using proptest or quickcheck for property-based testing of boundary conditions.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T00:45:30.117Z"
          }
        ],
        "updatedAt": "2026-01-27T00:45:30.117Z"
      },
      {
        "id": "21",
        "title": "Implement Modbus TCP Server",
        "description": "Create Modbus TCP server using tokio-modbus handling standard Function Codes (0x01-0x06, 0x0F, 0x10) with connection tracking and graceful shutdown.",
        "details": "1. Add tokio-modbus dependency to `src-tauri/Cargo.toml`:\n   ```toml\n   tokio-modbus = \"0.9\"\n   ```\n\n2. Create `src-tauri/src/modbus/tcp.rs`:\n   ```rust\n   use tokio_modbus::server::tcp::Server;\n   use std::sync::Arc;\n   use parking_lot::RwLock;\n   use tokio::sync::oneshot;\n\n   pub struct ModbusTcpServer {\n       config: TcpConfig,\n       memory: Arc<ModbusMemory>,\n       server_handle: Option<tokio::task::JoinHandle<()>>,\n       shutdown_tx: Option<oneshot::Sender<()>>,\n       connections: Arc<RwLock<Vec<ConnectionInfo>>>,\n   }\n\n   pub struct ConnectionInfo {\n       pub address: std::net::SocketAddr,\n       pub connected_at: chrono::DateTime<chrono::Utc>,\n   }\n   ```\n\n3. Implement ModbusTcpServer methods:\n   ```rust\n   impl ModbusTcpServer {\n     pub fn new(config: TcpConfig, memory: Arc<ModbusMemory>) -> Self;\n     pub async fn start(&mut self) -> Result<(), ModbusError>;\n     pub async fn stop(&mut self) -> Result<(), ModbusError>;\n     pub fn is_running(&self) -> bool;\n     pub fn get_connection_count(&self) -> usize;\n     pub fn get_connections(&self) -> Vec<ConnectionInfo>;\n   }\n   ```\n\n4. Implement Modbus service handler:\n   ```rust\n   struct ModbusService {\n       memory: Arc<ModbusMemory>,\n       connections: Arc<RwLock<Vec<ConnectionInfo>>>,\n       app_handle: tauri::AppHandle,\n   }\n\n   impl tokio_modbus::server::Service for ModbusService {\n     type Request = Request;\n     type Response = Response;\n     type Error = std::io::Error;\n     type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send>>;\n\n     fn call(&self, req: Self::Request) -> Self::Future {\n       // Handle function codes:\n       // 0x01: Read Coils -> memory.read_coils()\n       // 0x02: Read Discrete Inputs -> memory.read_discrete_inputs()\n       // 0x03: Read Holding Registers -> memory.read_holding_registers()\n       // 0x04: Read Input Registers -> memory.read_input_registers()\n       // 0x05: Write Single Coil -> memory.write_coil()\n       // 0x06: Write Single Register -> memory.write_holding_register()\n       // 0x0F: Write Multiple Coils -> memory.write_coils()\n       // 0x10: Write Multiple Registers -> memory.write_holding_registers()\n     }\n   }\n   ```\n\n5. Add connection tracking:\n   - Track connected clients in connections Vec\n   - Emit 'modbus:connection' event on connect/disconnect via app_handle\n   - Update connection list on new connection and cleanup\n\n6. Implement graceful shutdown:\n   - shutdown_tx sends signal to stop accepting\n   - Wait for active requests to complete (timeout 5s)\n   - Clean up all resources",
        "testStrategy": "1. Test server starts and binds to configured port (verify with netstat)\n2. Test server stops and releases port (rebind possible)\n3. Test each function code with external client (pymodbus, ModbusPoll)\n4. Test concurrent client connections up to limit\n5. Test connection events emitted on connect/disconnect\n6. Test graceful shutdown completes pending requests",
        "priority": "high",
        "dependencies": [
          "20"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add tokio-modbus Dependency and Create TCP Module Structure",
            "description": "Add tokio-modbus = \"0.9\" dependency to src-tauri/Cargo.toml and create the tcp.rs file in src-tauri/src/modbus/ directory with basic imports and module structure.",
            "dependencies": [],
            "details": "Add tokio-modbus = \"0.9\" to the [dependencies] section in src-tauri/Cargo.toml. Create src-tauri/src/modbus/tcp.rs with necessary imports: tokio_modbus::server::tcp::Server, std::sync::Arc, parking_lot::RwLock, tokio::sync::oneshot, std::net::SocketAddr. Also add chrono = \"0.4\" dependency if not present for timestamp tracking. Export the tcp module from src-tauri/src/modbus/mod.rs. Run 'cargo check' to verify dependencies resolve correctly.",
            "status": "done",
            "testStrategy": "Run 'cargo check' in src-tauri directory to verify tokio-modbus compiles and all imports resolve. Verify module is properly exported in mod.rs.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:12:56.926Z"
          },
          {
            "id": 2,
            "title": "Define TcpConfig and ConnectionInfo Types",
            "description": "Create the TcpConfig struct for TCP server configuration and ConnectionInfo struct for tracking connected clients with their metadata.",
            "dependencies": [
              1
            ],
            "details": "In src-tauri/src/modbus/types.rs or tcp.rs, define: TcpConfig struct with fields: bind_address (String), port (u16), unit_id (u8), max_connections (usize), timeout_ms (u64). Add Default implementation with bind_address=\"0.0.0.0\", port=502, unit_id=1, max_connections=10, timeout_ms=3000. Define ConnectionInfo struct with address (std::net::SocketAddr) and connected_at (chrono::DateTime<chrono::Utc>) fields. Derive Serialize, Deserialize, Clone, Debug for both structs.",
            "status": "done",
            "testStrategy": "Unit test TcpConfig::default() returns expected values. Test ConnectionInfo can be created with SocketAddr and current timestamp. Verify serialization roundtrip works correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:12:56.933Z"
          },
          {
            "id": 3,
            "title": "Implement ModbusTcpServer Struct with Core Methods",
            "description": "Create the ModbusTcpServer struct with config, memory reference, server handle, shutdown channel, and connections tracking, plus implement constructor and lifecycle methods.",
            "dependencies": [
              2
            ],
            "details": "Define ModbusTcpServer struct with fields: config (TcpConfig), memory (Arc<ModbusMemory>), server_handle (Option<tokio::task::JoinHandle<()>>), shutdown_tx (Option<oneshot::Sender<()>>), connections (Arc<RwLock<Vec<ConnectionInfo>>>), running (Arc<std::sync::atomic::AtomicBool>). Implement: new(config: TcpConfig, memory: Arc<ModbusMemory>) -> Self constructor. Implement is_running(&self) -> bool using AtomicBool. Implement get_connection_count(&self) -> usize and get_connections(&self) -> Vec<ConnectionInfo> using the connections RwLock.",
            "status": "done",
            "testStrategy": "Unit test new() creates server in non-running state. Test is_running() returns false initially. Test get_connection_count() returns 0 on fresh server. Test get_connections() returns empty Vec initially.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:12:56.939Z"
          },
          {
            "id": 4,
            "title": "Implement ModbusService Handler with Function Code Processing",
            "description": "Create the ModbusService struct implementing tokio_modbus::server::Service trait to handle all Modbus function codes (0x01-0x06, 0x0F, 0x10) by delegating to ModbusMemory.",
            "dependencies": [
              3
            ],
            "details": "Create ModbusService struct with memory (Arc<ModbusMemory>), connections (Arc<RwLock<Vec<ConnectionInfo>>>), and optionally app_handle (tauri::AppHandle) for events. Implement tokio_modbus::server::Service trait with Request, Response, Error, and Future associated types. In the call() method, match on Request variants: ReadCoils -> memory.read_coils(), ReadDiscreteInputs -> memory.read_discrete_inputs(), ReadHoldingRegisters -> memory.read_holding_registers(), ReadInputRegisters -> memory.read_input_registers(), WriteSingleCoil -> memory.write_coil(), WriteSingleRegister -> memory.write_holding_register(), WriteMultipleCoils -> memory.write_coils(), WriteMultipleRegisters -> memory.write_holding_registers(). Return appropriate Response variants or error responses for invalid operations.",
            "status": "done",
            "testStrategy": "Unit test each function code handler with mock ModbusMemory. Test ReadCoils returns correct bit values. Test WriteMultipleRegisters writes and returns correct response. Test invalid address ranges return exception responses.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:12:56.946Z"
          },
          {
            "id": 5,
            "title": "Implement Server Start/Stop with Connection Tracking and Graceful Shutdown",
            "description": "Implement the start() and stop() async methods for ModbusTcpServer with proper TCP listener setup, connection accept loop, connection tracking with events, and graceful shutdown with timeout.",
            "dependencies": [
              4
            ],
            "details": "Implement async start(&mut self) -> Result<(), ModbusError>: bind TCP listener to config.bind_address:config.port, create shutdown oneshot channel, spawn async task for accept loop that processes connections using ModbusService, track new connections in connections Vec with ConnectionInfo, update running AtomicBool to true. Implement async stop(&mut self) -> Result<(), ModbusError>: send shutdown signal via shutdown_tx, wait for server_handle with tokio::time::timeout(Duration::from_secs(5)), clean up connections list, update running to false. Add connection tracking: when client connects, push ConnectionInfo to connections and emit 'modbus:connection' event with event_type='connected'. On disconnect, remove from Vec and emit event_type='disconnected'. Ensure all resources are cleaned up even on error paths.",
            "status": "done",
            "testStrategy": "Test server starts and binds to configured port (verify with netstat or TcpStream::connect). Test server stops and releases port (rebind immediately succeeds). Test connection events emit on connect/disconnect using mock app_handle. Test graceful shutdown waits for pending requests (up to 5s timeout). Test concurrent connection limit is enforced.",
            "parentId": "undefined",
            "updatedAt": "2026-01-27T03:12:56.954Z"
          }
        ],
        "updatedAt": "2026-01-27T03:12:56.954Z"
      },
      {
        "id": "22",
        "title": "Implement Modbus RTU Server",
        "description": "Create Modbus RTU server for serial communication using tokio-serial with port enumeration, configurable parameters, and proper RTU framing with CRC validation.",
        "details": "1. Add dependencies to `src-tauri/Cargo.toml`:\n   ```toml\n   tokio-serial = \"5\"\n   serialport = \"4\"  # For port enumeration\n   ```\n\n2. Create `src-tauri/src/modbus/rtu.rs`:\n   ```rust\n   use tokio_serial::{SerialPortBuilderExt, SerialStream};\n\n   pub struct ModbusRtuServer {\n       config: RtuConfig,\n       memory: Arc<ModbusMemory>,\n       port: Option<SerialStream>,\n       running: Arc<AtomicBool>,\n       task_handle: Option<tokio::task::JoinHandle<()>>,\n   }\n\n   pub struct RtuConfig {\n       pub com_port: String,\n       pub baud_rate: u32,\n       pub parity: Parity,\n       pub stop_bits: StopBits,\n       pub data_bits: DataBits,\n       pub unit_id: u8,\n   }\n   ```\n\n3. Implement port enumeration:\n   ```rust\n   pub fn list_available_ports() -> Result<Vec<PortInfo>, std::io::Error> {\n     let ports = serialport::available_ports()?;\n     Ok(ports.into_iter().map(|p| PortInfo {\n       name: p.port_name,\n       port_type: match p.port_type {\n         SerialPortType::UsbPort(_) => \"USB\",\n         SerialPortType::BluetoothPort => \"Bluetooth\",\n         _ => \"Unknown\"\n       }.to_string(),\n       description: /* extract from port_type */,\n     }).collect())\n   }\n   ```\n\n4. Implement ModbusRtuServer methods:\n   ```rust\n   impl ModbusRtuServer {\n     pub fn new(config: RtuConfig, memory: Arc<ModbusMemory>) -> Self;\n     pub async fn start(&mut self) -> Result<(), ModbusError>;\n     pub async fn stop(&mut self) -> Result<(), ModbusError>;\n     pub fn is_running(&self) -> bool;\n   }\n   ```\n\n5. Implement RTU frame handling:\n   ```rust\n   async fn rtu_loop(port: &mut SerialStream, memory: Arc<ModbusMemory>, running: Arc<AtomicBool>) {\n     let mut buffer = [0u8; 256];\n     loop {\n       // Read frame with proper timing (3.5 character silence detection)\n       // Parse RTU frame: [Unit ID (1)] [Function Code (1)] [Data (N)] [CRC (2)]\n       // Validate CRC-16 (Modbus polynomial)\n       // Extract request, process with same logic as TCP\n       // Build response frame with CRC\n       // Write response to serial port\n     }\n   }\n   ```\n\n6. CRC-16 implementation:\n   ```rust\n   fn calculate_crc(data: &[u8]) -> u16 {\n     // Modbus CRC-16 polynomial: 0xA001\n     let mut crc: u16 = 0xFFFF;\n     for byte in data {\n       crc ^= *byte as u16;\n       for _ in 0..8 {\n         if crc & 0x0001 != 0 {\n           crc = (crc >> 1) ^ 0xA001;\n         } else {\n           crc >>= 1;\n         }\n       }\n     }\n     crc\n   }\n   ```\n\n7. Configure serial parameters in open:\n   - Baud rate: 9600, 19200, 38400, 57600, 115200\n   - Data bits: 7, 8\n   - Parity: None, Odd, Even\n   - Stop bits: 1, 2\n\n8. Handle serial port errors:\n   - Port disconnection detection\n   - Framing errors recovery\n   - Parity errors logging",
        "testStrategy": "1. Test port enumeration returns available ports with correct info\n2. Test server opens and configures serial port correctly\n3. Test CRC validation rejects bad frames\n4. Test with virtual COM port pair (com0com on Windows)\n5. Test serial parameter combinations (baud, parity, stop bits)\n6. Test error handling on port disconnect during operation",
        "priority": "medium",
        "dependencies": [
          "20",
          "21"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add RTU dependencies and create module structure",
            "description": "Add tokio-serial and serialport dependencies to Cargo.toml and create the rtu.rs module file with basic imports and type definitions.",
            "dependencies": [],
            "details": "Add to src-tauri/Cargo.toml:\n- tokio-serial = \"5\" for async serial communication\n- serialport = \"4\" for port enumeration\n\nCreate src-tauri/src/modbus/rtu.rs with:\n- Imports: tokio_serial::{SerialPortBuilderExt, SerialStream}, serialport, std::sync::Arc, parking_lot::RwLock, std::sync::atomic::{AtomicBool, Ordering}\n- RtuConfig struct with fields: com_port (String), baud_rate (u32), parity (Parity enum), stop_bits (StopBits enum), data_bits (DataBits enum), unit_id (u8)\n- PortInfo struct for enumeration results: name (String), port_type (String), description (Option<String>)\n- ModbusRtuServer struct skeleton with config, memory, port, running, task_handle fields\n- Update mod.rs to include pub mod rtu;",
            "status": "pending",
            "testStrategy": "Verify Cargo.toml compiles with new dependencies. Verify rtu.rs module is accessible from parent module. Check all type definitions are properly declared with required derives (Debug, Clone, Serialize where needed).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement serial port enumeration function",
            "description": "Create the list_available_ports function that discovers available COM ports with detailed metadata about each port type.",
            "dependencies": [
              1
            ],
            "details": "Implement in src-tauri/src/modbus/rtu.rs:\n\npub fn list_available_ports() -> Result<Vec<PortInfo>, std::io::Error> {\n  let ports = serialport::available_ports()?;\n  Ok(ports.into_iter().map(|p| {\n    let (port_type, description) = match &p.port_type {\n      SerialPortType::UsbPort(info) => (\n        \"USB\".to_string(),\n        Some(format!(\"{} {}\", info.manufacturer.as_deref().unwrap_or(\"\"), info.product.as_deref().unwrap_or(\"\")).trim().to_string())\n      ),\n      SerialPortType::BluetoothPort => (\"Bluetooth\".to_string(), None),\n      SerialPortType::PciPort => (\"PCI\".to_string(), None),\n      SerialPortType::Unknown => (\"Unknown\".to_string(), None),\n    };\n    PortInfo { name: p.port_name, port_type, description }\n  }).collect())\n}\n\nAdd #[derive(Serialize)] to PortInfo for Tauri command exposure.",
            "status": "pending",
            "testStrategy": "Unit test that list_available_ports returns Ok on systems with no ports. Manual test on Windows with COM ports to verify USB port info extraction. Test that returned PortInfo contains expected fields.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement CRC-16 calculation and RTU frame validation",
            "description": "Create CRC-16 Modbus calculation function and frame validation utilities for RTU protocol framing.",
            "dependencies": [
              1
            ],
            "details": "Implement in src-tauri/src/modbus/rtu.rs:\n\nfn calculate_crc(data: &[u8]) -> u16 {\n  let mut crc: u16 = 0xFFFF;\n  for byte in data {\n    crc ^= *byte as u16;\n    for _ in 0..8 {\n      if crc & 0x0001 != 0 {\n        crc = (crc >> 1) ^ 0xA001;\n      } else {\n        crc >>= 1;\n      }\n    }\n  }\n  crc\n}\n\nfn validate_frame(frame: &[u8]) -> bool {\n  if frame.len() < 4 { return false; }  // Min: unit_id + fc + crc(2)\n  let data_len = frame.len() - 2;\n  let received_crc = u16::from_le_bytes([frame[data_len], frame[data_len + 1]]);\n  calculate_crc(&frame[..data_len]) == received_crc\n}\n\nfn build_response_frame(unit_id: u8, response: &[u8]) -> Vec<u8> {\n  let mut frame = Vec::with_capacity(response.len() + 3);\n  frame.push(unit_id);\n  frame.extend_from_slice(response);\n  let crc = calculate_crc(&frame);\n  frame.extend_from_slice(&crc.to_le_bytes());\n  frame\n}",
            "status": "pending",
            "testStrategy": "Unit test calculate_crc with known test vectors from Modbus specification. Test validate_frame rejects frames with bad CRC. Test validate_frame rejects frames shorter than 4 bytes. Test build_response_frame produces valid CRC that passes validation.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement ModbusRtuServer core methods and serial port handling",
            "description": "Implement the ModbusRtuServer struct methods for lifecycle management including new(), start(), stop(), and is_running() with proper serial port configuration.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement in src-tauri/src/modbus/rtu.rs:\n\nimpl ModbusRtuServer {\n  pub fn new(config: RtuConfig, memory: Arc<ModbusMemory>) -> Self {\n    Self { config, memory, port: None, running: Arc::new(AtomicBool::new(false)), task_handle: None }\n  }\n\n  pub async fn start(&mut self) -> Result<(), ModbusError> {\n    if self.running.load(Ordering::SeqCst) { return Err(ModbusError::AlreadyRunning); }\n    let builder = tokio_serial::new(&self.config.com_port, self.config.baud_rate)\n      .parity(self.config.parity)\n      .stop_bits(self.config.stop_bits)\n      .data_bits(self.config.data_bits);\n    let port = builder.open_native_async()?;\n    self.port = Some(port);\n    self.running.store(true, Ordering::SeqCst);\n    // Spawn RTU loop task (implemented in subtask 5)\n    Ok(())\n  }\n\n  pub async fn stop(&mut self) -> Result<(), ModbusError> {\n    self.running.store(false, Ordering::SeqCst);\n    if let Some(handle) = self.task_handle.take() { handle.abort(); }\n    self.port = None;\n    Ok(())\n  }\n\n  pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }\n}",
            "status": "pending",
            "testStrategy": "Test new() creates server in stopped state. Test start() on invalid port returns appropriate error. Test start() when already running returns AlreadyRunning error. Test stop() sets running to false. Test is_running() reflects actual state. Integration test with virtual COM port pair (com0com on Windows).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement RTU communication loop with frame handling and error recovery",
            "description": "Create the async RTU loop that reads frames from serial port, validates them, processes requests through shared ModbusMemory, and sends responses with proper inter-frame timing.",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement in src-tauri/src/modbus/rtu.rs:\n\nasync fn rtu_loop(mut port: SerialStream, memory: Arc<ModbusMemory>, running: Arc<AtomicBool>, unit_id: u8) {\n  let mut buffer = [0u8; 256];\n  let mut frame_buffer = Vec::with_capacity(256);\n  let char_time_us = 11_000_000 / 9600; // Adjust based on baud rate\n  let t35_timeout = Duration::from_micros((char_time_us * 35).max(1750)); // 3.5 char or 1.75ms min\n\n  while running.load(Ordering::SeqCst) {\n    match timeout(t35_timeout, port.read(&mut buffer)).await {\n      Ok(Ok(n)) if n > 0 => frame_buffer.extend_from_slice(&buffer[..n]),\n      Ok(Ok(_)) | Err(_) => {\n        // Frame complete (timeout) - process if we have data\n        if frame_buffer.len() >= 4 && validate_frame(&frame_buffer) {\n          if frame_buffer[0] == unit_id {\n            let response = process_request(&frame_buffer[1..frame_buffer.len()-2], &memory);\n            let response_frame = build_response_frame(unit_id, &response);\n            let _ = port.write_all(&response_frame).await;\n          }\n        }\n        frame_buffer.clear();\n      }\n      Ok(Err(e)) => {\n        log::error!(\"Serial read error: {}\", e);\n        frame_buffer.clear();\n        // Consider reconnection logic for persistent errors\n      }\n    }\n  }\n}\n\nIntegrate with start() method to spawn this loop as a tokio task.",
            "status": "pending",
            "testStrategy": "Test with virtual COM port pair sending valid Modbus RTU frames. Test frame reassembly across multiple reads. Test 3.5 character timeout triggers frame processing. Test invalid CRC frames are silently discarded. Test frames addressed to wrong unit_id are ignored. Test serial error recovery does not crash the loop.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "23",
        "title": "Create Modbus Tauri Commands",
        "description": "Implement Tauri command handlers for Modbus server control (start/stop TCP/RTU) and memory access (read/write coils and registers) with proper state management.",
        "details": "1. Create `src-tauri/src/commands/modbus.rs`:\n\n2. Define ModbusState for Tauri managed state:\n   ```rust\n   pub struct ModbusState {\n       pub memory: Arc<ModbusMemory>,\n       pub tcp_server: Mutex<Option<ModbusTcpServer>>,\n       pub rtu_server: Mutex<Option<ModbusRtuServer>>,\n   }\n   ```\n\n3. Implement server control commands:\n   ```rust\n   #[tauri::command]\n   pub async fn modbus_start_tcp(\n       state: State<'_, ModbusState>,\n       port: u16\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn modbus_stop_tcp(\n       state: State<'_, ModbusState>\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn modbus_start_rtu(\n       state: State<'_, ModbusState>,\n       config: RtuConfig\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn modbus_stop_rtu(\n       state: State<'_, ModbusState>\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn modbus_get_status(\n       state: State<'_, ModbusState>\n   ) -> Result<ModbusStatus, String>;\n\n   #[tauri::command]\n   pub async fn modbus_list_serial_ports() -> Result<Vec<PortInfo>, String>;\n   ```\n\n4. Implement memory access commands:\n   ```rust\n   #[tauri::command]\n   pub async fn modbus_read_coils(\n       state: State<'_, ModbusState>,\n       start: u16,\n       count: u16\n   ) -> Result<Vec<bool>, String>;\n\n   #[tauri::command]\n   pub async fn modbus_write_coil(\n       state: State<'_, ModbusState>,\n       address: u16,\n       value: bool\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn modbus_read_registers(\n       state: State<'_, ModbusState>,\n       register_type: String, // \"holding\" | \"input\"\n       start: u16,\n       count: u16\n   ) -> Result<Vec<u16>, String>;\n\n   #[tauri::command]\n   pub async fn modbus_write_register(\n       state: State<'_, ModbusState>,\n       address: u16,\n       value: u16\n   ) -> Result<(), String>;\n\n   #[tauri::command]\n   pub async fn modbus_bulk_write(\n       state: State<'_, ModbusState>,\n       operations: Vec<WriteOperation>\n   ) -> Result<(), String>;\n   ```\n\n5. Define supporting types:\n   ```rust\n   #[derive(Serialize)]\n   pub struct ModbusStatus {\n       tcp_running: bool,\n       tcp_port: Option<u16>,\n       tcp_connections: usize,\n       rtu_running: bool,\n       rtu_port: Option<String>,\n   }\n\n   #[derive(Deserialize)]\n   pub struct WriteOperation {\n       register_type: String,\n       address: u16,\n       value: u16,\n   }\n   ```\n\n6. Register commands and state in main.rs:\n   ```rust\n   .manage(ModbusState {\n       memory: Arc::new(ModbusMemory::new(&MemoryMapSettings::default())),\n       tcp_server: Mutex::new(None),\n       rtu_server: Mutex::new(None),\n   })\n   .invoke_handler(tauri::generate_handler![\n       modbus_start_tcp, modbus_stop_tcp,\n       modbus_start_rtu, modbus_stop_rtu,\n       modbus_get_status, modbus_list_serial_ports,\n       modbus_read_coils, modbus_write_coil,\n       modbus_read_registers, modbus_write_register,\n       modbus_bulk_write,\n   ])\n   ```",
        "testStrategy": "1. Test each command returns correct data type\n2. Test error handling for invalid parameters (negative address, etc.)\n3. Test commands work both when server running and stopped\n4. Test memory read returns values written by memory write\n5. Test bulk_write applies all operations atomically\n6. Integration test commands from frontend via invoke",
        "priority": "high",
        "dependencies": [
          "21",
          "22"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create modbus.rs Command Module Structure with ModbusState Definition",
            "description": "Set up the Tauri commands module for Modbus by creating src-tauri/src/commands/modbus.rs with the ModbusState managed state struct and necessary imports.",
            "dependencies": [],
            "details": "Create src-tauri/src/commands/modbus.rs file with all required imports: std::sync::Arc, tauri::State, tokio::sync::Mutex (or parking_lot::Mutex), serde::{Serialize, Deserialize}. Define the ModbusState struct containing: memory: Arc<ModbusMemory>, tcp_server: Mutex<Option<ModbusTcpServer>>, rtu_server: Mutex<Option<ModbusRtuServer>>. Add the modbus module to src-tauri/src/commands/mod.rs with 'pub mod modbus;' and re-export public items. Ensure ModbusState derives or implements Default if needed for Tauri managed state initialization. This struct will be the central state container that all Modbus Tauri commands access.",
            "status": "pending",
            "testStrategy": "Run 'cargo check' in src-tauri directory to verify the module compiles. Verify ModbusState can be instantiated with default values. Check that the modbus module is properly exported from commands/mod.rs.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement TCP Server Control Commands (start/stop)",
            "description": "Create the modbus_start_tcp and modbus_stop_tcp Tauri command handlers for controlling the TCP server lifecycle with proper async handling.",
            "dependencies": [
              1
            ],
            "details": "Implement #[tauri::command] pub async fn modbus_start_tcp(state: State<'_, ModbusState>, port: u16) -> Result<(), String> that: acquires lock on tcp_server mutex, checks if server already running (return error if so), creates new ModbusTcpServer with shared memory Arc, calls server.start().await, stores server in Option. Implement #[tauri::command] pub async fn modbus_stop_tcp(state: State<'_, ModbusState>) -> Result<(), String> that: acquires lock, extracts server from Option with take(), calls server.stop().await if Some, returns Ok. Use map_err(|e| e.to_string()) to convert errors for Tauri. Handle edge cases: starting when already started, stopping when not running.",
            "status": "pending",
            "testStrategy": "Test start_tcp succeeds and sets tcp_server to Some. Test start_tcp returns error when already running. Test stop_tcp succeeds when running. Test stop_tcp returns Ok (no-op) when not running. Integration test with actual TCP binding on available port.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement RTU Server Control Commands and Serial Port Listing",
            "description": "Create modbus_start_rtu, modbus_stop_rtu, and modbus_list_serial_ports Tauri commands for RTU server control and COM port enumeration.",
            "dependencies": [
              1
            ],
            "details": "Define RtuConfig struct (derive Deserialize) with fields: port_name: String, baud_rate: u32, data_bits: u8, parity: String, stop_bits: u8, unit_id: u8, timeout_ms: u64. Implement #[tauri::command] pub async fn modbus_start_rtu(state: State<'_, ModbusState>, config: RtuConfig) -> Result<(), String> with same pattern as TCP. Implement #[tauri::command] pub async fn modbus_stop_rtu(state: State<'_, ModbusState>) -> Result<(), String>. Define PortInfo struct (derive Serialize) with fields: name: String, port_type: String (USB, PCI, etc.), manufacturer: Option<String>, product: Option<String>. Implement #[tauri::command] pub async fn modbus_list_serial_ports() -> Result<Vec<PortInfo>, String> using serialport::available_ports() to enumerate COM ports.",
            "status": "pending",
            "testStrategy": "Test list_serial_ports returns Ok even with no ports. Test start_rtu with valid config succeeds on systems with serial ports. Test stop_rtu when running. Mock serial port for unit testing. Manual test on Windows with USB-to-Serial adapter.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Memory Access Commands (read/write coils and registers)",
            "description": "Create Tauri commands for reading and writing Modbus memory including coils and holding/input registers with proper parameter validation.",
            "dependencies": [
              1
            ],
            "details": "Implement #[tauri::command] pub async fn modbus_read_coils(state: State<'_, ModbusState>, start: u16, count: u16) -> Result<Vec<bool>, String> that calls memory.read_coils(). Implement #[tauri::command] pub async fn modbus_write_coil(state: State<'_, ModbusState>, address: u16, value: bool) -> Result<(), String>. Implement #[tauri::command] pub async fn modbus_read_registers(state: State<'_, ModbusState>, register_type: String, start: u16, count: u16) -> Result<Vec<u16>, String> where register_type is 'holding' or 'input' - match on string to call appropriate memory method. Implement #[tauri::command] pub async fn modbus_write_register(state: State<'_, ModbusState>, address: u16, value: u16) -> Result<(), String> for holding registers only (input registers are read-only). Add validation for count > 0 and address + count <= max_address.",
            "status": "pending",
            "testStrategy": "Test read_coils returns correct bool array. Test write_coil updates memory. Test read_registers with both 'holding' and 'input' types. Test write_register updates holding register. Test error on invalid register_type. Test boundary conditions (address 0, address 65535, count spanning end).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Status Query and Bulk Write Commands with main.rs Registration",
            "description": "Create modbus_get_status and modbus_bulk_write commands, define supporting types, and register all commands and state in main.rs.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Define ModbusStatus struct (derive Serialize) with fields: tcp_running: bool, tcp_port: Option<u16>, tcp_connections: usize, rtu_running: bool, rtu_port: Option<String>. Implement #[tauri::command] pub async fn modbus_get_status(state: State<'_, ModbusState>) -> Result<ModbusStatus, String> that queries both servers for status. Define WriteOperation struct (derive Deserialize) with fields: register_type: String, address: u16, value: u16. Implement #[tauri::command] pub async fn modbus_bulk_write(state: State<'_, ModbusState>, operations: Vec<WriteOperation>) -> Result<(), String> that applies all write operations, supporting both coils (value != 0 = true) and holding registers. In main.rs: add .manage(ModbusState { memory: Arc::new(ModbusMemory::new(&MemoryMapSettings::default())), tcp_server: Mutex::new(None), rtu_server: Mutex::new(None) }) and register all 11 commands with tauri::generate_handler![].",
            "status": "pending",
            "testStrategy": "Test get_status returns correct running states. Test bulk_write applies all operations. Test bulk_write with mixed coil and register operations. Test bulk_write rolls back or errors appropriately on failure. Verify all commands registered in main.rs by running app and calling from frontend. Integration test complete workflow: start server, write memory, read back, stop server.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "24",
        "title": "Implement Modbus Event System",
        "description": "Create event emission system for memory changes and connection status using Tauri events, with support for change batching and address range subscriptions.",
        "details": "1. Define event types in `src-tauri/src/modbus/types.rs`:\n   ```rust\n   #[derive(Serialize, Clone)]\n   pub struct MemoryChangeEvent {\n       pub register_type: String, // \"coil\" | \"discrete\" | \"holding\" | \"input\"\n       pub address: u16,\n       pub old_value: serde_json::Value, // bool or u16\n       pub new_value: serde_json::Value,\n       pub source: String, // \"internal\" | \"external\" | \"simulation\"\n   }\n\n   #[derive(Serialize, Clone)]\n   pub struct ConnectionEvent {\n       pub event_type: String, // \"connected\" | \"disconnected\"\n       pub protocol: String, // \"tcp\" | \"rtu\"\n       pub client_addr: String,\n       pub timestamp: String, // ISO8601\n   }\n\n   #[derive(Serialize, Clone)]\n   pub struct MemoryBatchChangeEvent {\n       pub changes: Vec<MemoryChangeEvent>,\n   }\n   ```\n\n2. Add event emission to ModbusMemory:\n   ```rust\n   pub struct ModbusMemory {\n       // ... existing fields\n       app_handle: Option<tauri::AppHandle>,\n       change_buffer: RwLock<Vec<MemoryChangeEvent>>,\n       buffer_timeout: Duration, // default 50ms\n   }\n\n   impl ModbusMemory {\n     pub fn set_app_handle(&mut self, handle: tauri::AppHandle);\n\n     fn emit_change(&self, change: MemoryChangeEvent) {\n       // Add to buffer, flush if timeout elapsed\n       // Or emit immediately for single changes\n     }\n\n     fn flush_changes(&self) {\n       // Emit batched event: \"modbus:memory-batch-changed\"\n     }\n   }\n   ```\n\n3. Update write methods to emit events:\n   ```rust\n   pub fn write_coil(&self, address: u16, value: bool) -> Result<(), MemoryError> {\n     let old_value = self.read_coils(address, 1)?[0];\n     // ... actual write\n     self.emit_change(MemoryChangeEvent {\n       register_type: \"coil\".into(),\n       address,\n       old_value: json!(old_value),\n       new_value: json!(value),\n       source: \"internal\".into(),\n     });\n     Ok(())\n   }\n   ```\n\n4. Add connection events to servers:\n   - In TCP server on_connect callback: emit \"modbus:connection\" event\n   - In TCP server on_disconnect callback: emit \"modbus:connection\" event\n   - Include client address in event payload\n\n5. Implement event batching for bulk operations:\n   ```rust\n   pub fn write_coils(&self, start: u16, values: &[bool]) -> Result<(), MemoryError> {\n     // Start batch mode\n     self.start_batch();\n     for (i, value) in values.iter().enumerate() {\n       // ... write with emit_change (buffered)\n     }\n     // End batch, emit single batched event\n     self.end_batch();\n   }\n   ```\n\n6. Create subscription management (optional, for performance):\n   ```rust\n   pub struct MemorySubscription {\n       id: String,\n       register_type: String,\n       start: u16,\n       count: u16,\n   }\n\n   // Only emit events for subscribed ranges\n   fn should_emit(&self, change: &MemoryChangeEvent) -> bool;\n   ```\n\n7. Frontend event listening setup documentation:\n   ```typescript\n   import { listen } from '@tauri-apps/api/event';\n\n   listen('modbus:memory-changed', (event) => {\n     const change = event.payload as MemoryChangeEvent;\n     // Update UI\n   });\n\n   listen('modbus:memory-batch-changed', (event) => {\n     const batch = event.payload as MemoryBatchChangeEvent;\n     // Batch update UI\n   });\n\n   listen('modbus:connection', (event) => {\n     const conn = event.payload as ConnectionEvent;\n     // Update connection status\n   });\n   ```",
        "testStrategy": "1. Test single memory write emits single change event\n2. Test event contains correct old_value and new_value\n3. Test bulk write emits batched event with all changes\n4. Test connection events fire on client connect/disconnect\n5. Test event batching reduces event count for bulk operations\n6. Frontend integration test receives events correctly",
        "priority": "medium",
        "dependencies": [
          "23"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Event Type Structs in types.rs",
            "description": "Create MemoryChangeEvent, ConnectionEvent, and MemoryBatchChangeEvent structs with Serialize and Clone derives for Tauri event emission.",
            "dependencies": [],
            "details": "Add three event structs to `src-tauri/src/modbus/types.rs`:\n\n1. `MemoryChangeEvent` with fields:\n   - `register_type: String` (\"coil\" | \"discrete\" | \"holding\" | \"input\")\n   - `address: u16`\n   - `old_value: serde_json::Value` (to handle both bool and u16)\n   - `new_value: serde_json::Value`\n   - `source: String` (\"internal\" | \"external\" | \"simulation\")\n\n2. `ConnectionEvent` with fields:\n   - `event_type: String` (\"connected\" | \"disconnected\")\n   - `protocol: String` (\"tcp\" | \"rtu\")\n   - `client_addr: String`\n   - `timestamp: String` (ISO8601 format)\n\n3. `MemoryBatchChangeEvent` with fields:\n   - `changes: Vec<MemoryChangeEvent>`\n\nAll structs must derive `Serialize, Clone` and use `#[derive(serde::Serialize, Clone)]`. Add `serde_json` to dependencies in Cargo.toml if not present.",
            "status": "pending",
            "testStrategy": "Unit test that each struct can be serialized to JSON correctly. Test MemoryChangeEvent with both bool (coil) and u16 (register) values serialize properly via serde_json::Value. Verify Clone trait works for all structs.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Event Infrastructure to ModbusMemory",
            "description": "Extend ModbusMemory struct with AppHandle storage, change buffer, and buffer timeout configuration for event batching support.",
            "dependencies": [
              1
            ],
            "details": "Modify `ModbusMemory` struct in `src-tauri/src/modbus/memory.rs` to include:\n\n1. Add fields:\n   - `app_handle: Option<tauri::AppHandle>` - stores Tauri handle for event emission\n   - `change_buffer: RwLock<Vec<MemoryChangeEvent>>` - buffers changes for batching\n   - `buffer_timeout: Duration` - configurable timeout (default 50ms)\n   - `batch_mode: RwLock<bool>` - tracks if in batch operation\n\n2. Add methods:\n   - `pub fn set_app_handle(&mut self, handle: tauri::AppHandle)` - setter for app handle\n   - `fn emit_change(&self, change: MemoryChangeEvent)` - adds to buffer or emits immediately\n   - `fn flush_changes(&self)` - emits batched event \"modbus:memory-batch-changed\"\n   - `pub fn start_batch(&self)` - enables batch mode\n   - `pub fn end_batch(&self)` - disables batch mode and flushes\n\nThe emit_change method should check batch_mode: if true, add to buffer; if false, emit single \"modbus:memory-changed\" event immediately.",
            "status": "pending",
            "testStrategy": "Test set_app_handle stores handle correctly. Test emit_change in non-batch mode triggers immediate event (mock app_handle). Test start_batch/end_batch toggle batch_mode correctly. Test flush_changes clears buffer after emitting.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate Event Emission into Memory Write Operations",
            "description": "Update all ModbusMemory write methods (write_coil, write_coils, write_register, write_registers) to capture old values and emit change events.",
            "dependencies": [
              2
            ],
            "details": "Modify each write method in ModbusMemory to emit events:\n\n1. `write_coil(address, value)` - Single coil write:\n   - Read old value before write: `let old = self.read_coils(address, 1)?[0];`\n   - Perform actual write\n   - Call `emit_change(MemoryChangeEvent { register_type: \"coil\".into(), address, old_value: json!(old), new_value: json!(value), source: \"internal\".into() })`\n\n2. `write_coils(start, values)` - Bulk coil write:\n   - Call `start_batch()`\n   - For each value, read old, write new, emit_change (buffered)\n   - Call `end_batch()` to flush single batched event\n\n3. `write_register(address, value)` - Single holding register:\n   - Same pattern as write_coil but register_type: \"holding\"\n\n4. `write_registers(start, values)` - Bulk register write:\n   - Same batch pattern as write_coils\n\nNote: Discrete inputs and input registers are typically read-only in Modbus, but if write methods exist, apply same pattern.",
            "status": "pending",
            "testStrategy": "Test single write_coil emits one MemoryChangeEvent with correct old/new values. Test write_coils(start, 5 values) emits one MemoryBatchChangeEvent containing 5 changes. Test event contains correct register_type for each memory type. Test source field is \"internal\" for these operations.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Connection Events in TCP and RTU Servers",
            "description": "Add connection event emission to ModbusTcpServer and ModbusRtuServer for client connect/disconnect tracking with proper timestamps.",
            "dependencies": [
              1
            ],
            "details": "Modify TCP and RTU server implementations to emit ConnectionEvent:\n\n1. In `ModbusTcpServer` (src-tauri/src/modbus/tcp.rs):\n   - Add `app_handle: Option<tauri::AppHandle>` field\n   - Add `set_app_handle(&mut self, handle)` method\n   - In connection accept loop, on new connection emit:\n     ```rust\n     ConnectionEvent {\n       event_type: \"connected\".into(),\n       protocol: \"tcp\".into(),\n       client_addr: peer_addr.to_string(),\n       timestamp: chrono::Utc::now().to_rfc3339(),\n     }\n     ```\n   - On connection close/drop, emit with event_type: \"disconnected\"\n   - Emit to \"modbus:connection\" event channel\n\n2. In `ModbusRtuServer` (src-tauri/src/modbus/rtu.rs):\n   - Same pattern but protocol: \"rtu\"\n   - client_addr could be the port name or \"serial\" for RTU\n\nAdd `chrono` crate dependency for timestamp formatting if not present.",
            "status": "pending",
            "testStrategy": "Test TCP server emits 'connected' event on client connect with correct client_addr. Test 'disconnected' event fires when client drops connection. Test timestamp is valid ISO8601 format. Test RTU server emits connection event with protocol: \"rtu\". Mock app_handle to capture emitted events.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Subscription Management and Frontend Documentation",
            "description": "Implement optional MemorySubscription system for performance optimization and create TypeScript type definitions with usage documentation for frontend event listeners.",
            "dependencies": [
              3,
              4
            ],
            "details": "1. Create subscription management in `src-tauri/src/modbus/events.rs`:\n   ```rust\n   pub struct MemorySubscription {\n       pub id: String,\n       pub register_type: String,\n       pub start: u16,\n       pub count: u16,\n   }\n   \n   pub struct SubscriptionManager {\n       subscriptions: RwLock<Vec<MemorySubscription>>,\n   }\n   ```\n   - Add `fn should_emit(&self, change: &MemoryChangeEvent) -> bool` that checks if change falls within any subscription range\n   - Integrate into ModbusMemory.emit_change() to filter events\n\n2. Create TypeScript types in `src/types/modbus-events.ts`:\n   ```typescript\n   export interface MemoryChangeEvent {\n     register_type: 'coil' | 'discrete' | 'holding' | 'input';\n     address: number;\n     old_value: boolean | number;\n     new_value: boolean | number;\n     source: 'internal' | 'external' | 'simulation';\n   }\n   // ... ConnectionEvent, MemoryBatchChangeEvent\n   ```\n\n3. Add documentation/example in `src/hooks/useModbusEvents.ts` showing:\n   - How to listen with `listen('modbus:memory-changed', handler)`\n   - How to listen to batch events\n   - How to handle connection events\n   - Cleanup with unlisten on component unmount",
            "status": "pending",
            "testStrategy": "Test SubscriptionManager.should_emit returns true for changes within subscribed range. Test returns false for changes outside all subscriptions. Test empty subscriptions list allows all events (no filtering). Frontend: verify TypeScript types compile without errors. Integration test: frontend receives events emitted from Rust backend correctly.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "25",
        "title": "Create Frontend Modbus Integration",
        "description": "Implement TypeScript service layer, Zustand store, and React hooks for Modbus server control and memory monitoring with real-time event updates.",
        "details": "1. Create `src/services/modbusService.ts`:\n   ```typescript\n   import { invoke } from '@tauri-apps/api/core';\n\n   export const modbusService = {\n     // Server control\n     startTcp: (port: number) => invoke('modbus_start_tcp', { port }),\n     stopTcp: () => invoke('modbus_stop_tcp'),\n     startRtu: (config: RtuConfig) => invoke('modbus_start_rtu', { config }),\n     stopRtu: () => invoke('modbus_stop_rtu'),\n     getStatus: () => invoke<ModbusStatus>('modbus_get_status'),\n     listSerialPorts: () => invoke<PortInfo[]>('modbus_list_serial_ports'),\n\n     // Memory access\n     readCoils: (start: number, count: number) =>\n       invoke<boolean[]>('modbus_read_coils', { start, count }),\n     writeCoil: (address: number, value: boolean) =>\n       invoke('modbus_write_coil', { address, value }),\n     readRegisters: (type: RegisterType, start: number, count: number) =>\n       invoke<number[]>('modbus_read_registers', { registerType: type, start, count }),\n     writeRegister: (address: number, value: number) =>\n       invoke('modbus_write_register', { address, value }),\n   };\n   ```\n\n2. Create `src/stores/modbusStore.ts` with Zustand:\n   ```typescript\n   interface ModbusStore {\n     status: ModbusStatus | null;\n     isConnecting: boolean;\n     error: string | null;\n     coilCache: Map<number, boolean>;\n     registerCache: Map<number, number>;\n     connections: ConnectionInfo[];\n\n     fetchStatus: () => Promise<void>;\n     setStatus: (status: ModbusStatus) => void;\n     updateCoilCache: (address: number, value: boolean) => void;\n     updateRegisterCache: (address: number, value: number) => void;\n     setConnections: (conns: ConnectionInfo[]) => void;\n   }\n   ```\n\n3. Create `src/hooks/useModbus.ts`:\n   ```typescript\n   export function useModbus() {\n     const store = useModbusStore();\n\n     const startTcp = async (port: number) => {\n       try {\n         await modbusService.startTcp(port);\n         await store.fetchStatus();\n       } catch (error) {\n         // Handle error, show toast\n       }\n     };\n\n     const stopTcp = async () => { /* similar */ };\n\n     return {\n       status: store.status,\n       startTcp,\n       stopTcp,\n       // ... other operations\n     };\n   }\n   ```\n\n4. Create `src/hooks/useModbusMemory.ts`:\n   ```typescript\n   export function useModbusMemory(\n     type: RegisterType,\n     start: number,\n     count: number\n   ) {\n     const [values, setValues] = useState<number[] | boolean[]>([]);\n\n     useEffect(() => {\n       // Initial load\n       const load = async () => {\n         if (type === 'coil') {\n           setValues(await modbusService.readCoils(start, count));\n         } else {\n           setValues(await modbusService.readRegisters(type, start, count));\n         }\n       };\n       load();\n\n       // Subscribe to changes\n       const unlisten = listen('modbus:memory-changed', (event) => {\n         const change = event.payload as MemoryChangeEvent;\n         if (isInRange(change.address, start, count) && change.registerType === type) {\n           setValues(prev => {\n             const updated = [...prev];\n             updated[change.address - start] = change.newValue;\n             return updated;\n           });\n         }\n       });\n\n       return () => { unlisten.then(fn => fn()); };\n     }, [type, start, count]);\n\n     return values;\n   }\n   ```\n\n5. Create `src/types/modbus.ts`:\n   ```typescript\n   export type RegisterType = 'coil' | 'discrete' | 'holding' | 'input';\n\n   export interface ModbusStatus {\n     tcpRunning: boolean;\n     tcpPort: number | null;\n     tcpConnections: number;\n     rtuRunning: boolean;\n     rtuPort: string | null;\n   }\n\n   export interface RtuConfig {\n     comPort: string;\n     baudRate: number;\n     parity: 'none' | 'odd' | 'even';\n     stopBits: 1 | 2;\n   }\n\n   export interface PortInfo {\n     name: string;\n     portType: string;\n     description: string;\n   }\n\n   export interface MemoryChangeEvent {\n     registerType: RegisterType;\n     address: number;\n     oldValue: boolean | number;\n     newValue: boolean | number;\n     source: string;\n   }\n\n   export interface ConnectionEvent {\n     eventType: 'connected' | 'disconnected';\n     protocol: 'tcp' | 'rtu';\n     clientAddr: string;\n     timestamp: string;\n   }\n   ```\n\n6. Update ModbusPanel in sidebar:\n   - Show TCP/RTU server status (running/stopped with colored indicator)\n   - Start/Stop buttons for each server type\n   - TCP port configuration input\n   - Connection count display\n   - Quick memory overview (total coils, registers with counts)",
        "testStrategy": "1. Mock invoke for unit testing service methods\n2. Test useModbusMemory updates state on memory change events\n3. Test server start/stop functions update status correctly\n4. Test useModbus hook error handling shows toast\n5. Integration test with running Modbus server\n6. E2E test: start server, write value, verify UI updates",
        "priority": "high",
        "dependencies": [
          "24",
          "12"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Modbus TypeScript Type Definitions",
            "description": "Define all TypeScript interfaces and types for Modbus functionality in src/types/modbus.ts including RegisterType, ModbusStatus, RtuConfig, PortInfo, MemoryChangeEvent, ConnectionEvent, and WriteOperation types.",
            "dependencies": [],
            "details": "Create src/types/modbus.ts with the following type definitions:\n\n1. RegisterType union type: 'coil' | 'discrete' | 'holding' | 'input'\n\n2. ModbusStatus interface with nested tcp and rtu objects:\n   - tcp: { running: boolean, port: number | null, connections: number }\n   - rtu: { running: boolean, comPort: string | null, baudRate: number | null }\n\n3. RtuConfig interface:\n   - comPort: string\n   - baudRate: number (9600, 19200, 38400, 57600, 115200)\n   - parity: 'none' | 'odd' | 'even'\n   - stopBits: 1 | 2\n   - dataBits?: 7 | 8\n\n4. PortInfo interface:\n   - name: string\n   - portType: string\n   - description: string\n\n5. MemoryChangeEvent interface:\n   - registerType: RegisterType\n   - address: number\n   - oldValue: boolean | number\n   - newValue: boolean | number\n   - source: 'internal' | 'external' | 'simulation'\n\n6. ConnectionEvent interface:\n   - eventType: 'connected' | 'disconnected'\n   - protocol: 'tcp' | 'rtu'\n   - clientAddr: string\n   - timestamp: string\n\n7. WriteOperation interface:\n   - type: 'coil' | 'holding_register'\n   - address: number\n   - value: number | boolean\n\nExport all types with proper JSDoc comments for IDE support.",
            "status": "pending",
            "testStrategy": "Verify all types compile without TypeScript errors. Test that types are correctly exported and can be imported in other modules. Ensure type guards work for discriminated unions (RegisterType). Validate that interfaces match the Rust backend Tauri command signatures from PRD_Unit3_ModServer.md.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Modbus Service Layer with Tauri Invoke Wrappers",
            "description": "Create src/services/modbusService.ts that wraps all Tauri invoke commands for Modbus server control (start/stop TCP/RTU) and memory access operations (read/write coils and registers).",
            "dependencies": [
              1
            ],
            "details": "Create src/services/modbusService.ts with the following structure:\n\n1. Import invoke from '@tauri-apps/api/core' and types from '../types/modbus'\n\n2. Export modbusService object with server control methods:\n   - startTcp(port: number): Promise<void> - invoke('modbus_start_tcp', { port })\n   - stopTcp(): Promise<void> - invoke('modbus_stop_tcp')\n   - startRtu(config: RtuConfig): Promise<void> - invoke('modbus_start_rtu', { config })\n   - stopRtu(): Promise<void> - invoke('modbus_stop_rtu')\n   - getStatus(): Promise<ModbusStatus> - invoke('modbus_get_status')\n   - listSerialPorts(): Promise<PortInfo[]> - invoke('modbus_list_serial_ports')\n\n3. Memory access methods:\n   - readCoils(start: number, count: number): Promise<boolean[]> - invoke('modbus_read_coils', { start, count })\n   - writeCoil(address: number, value: boolean): Promise<void> - invoke('modbus_write_coil', { address, value })\n   - readRegisters(type: RegisterType, start: number, count: number): Promise<number[]> - invoke('modbus_read_registers', { registerType: type, start, count })\n   - writeRegister(address: number, value: number): Promise<void> - invoke('modbus_write_register', { address, value })\n   - bulkWrite(operations: WriteOperation[]): Promise<void> - invoke('modbus_bulk_write', { operations })\n\n4. Add proper error typing and async/await patterns for all methods.",
            "status": "pending",
            "testStrategy": "Mock @tauri-apps/api/core invoke function using vitest/jest. Test each service method calls invoke with correct command name and parameters. Test error handling by mocking invoke to reject. Verify TypeScript types are correctly applied to return values. Test that RegisterType parameter is properly transformed to registerType in the invoke call.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create Zustand Store for Modbus State Management",
            "description": "Implement src/stores/modbusStore.ts using Zustand to manage Modbus server status, connection state, error handling, and memory caches for coils and registers with appropriate actions.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create src/stores/modbusStore.ts with Zustand:\n\n1. Install zustand if not present: npm install zustand\n\n2. Define ModbusStore interface:\n   - status: ModbusStatus | null\n   - isConnecting: boolean\n   - error: string | null\n   - coilCache: Map<number, boolean>\n   - registerCache: Map<number, number>\n   - connections: ConnectionInfo[] (where ConnectionInfo = { clientAddr: string, connectedAt: string, protocol: 'tcp' | 'rtu' })\n\n3. Implement actions:\n   - fetchStatus: async () => Promise<void> - calls modbusService.getStatus() and updates status\n   - setStatus: (status: ModbusStatus) => void - directly set status (for event updates)\n   - setError: (error: string | null) => void\n   - setConnecting: (connecting: boolean) => void\n   - updateCoilCache: (address: number, value: boolean) => void\n   - updateRegisterCache: (address: number, value: number) => void\n   - clearCache: () => void - resets both caches\n   - addConnection: (conn: ConnectionInfo) => void\n   - removeConnection: (clientAddr: string) => void\n   - setConnections: (conns: ConnectionInfo[]) => void\n\n4. Use immer middleware for immutable updates on Map operations\n\n5. Export useModbusStore hook and selector helpers:\n   - selectStatus, selectIsConnecting, selectError, selectTcpRunning, selectRtuRunning",
            "status": "pending",
            "testStrategy": "Test store initializes with correct default values (status: null, isConnecting: false, error: null, empty caches). Test fetchStatus updates status state. Test setStatus directly updates status. Test coilCache and registerCache Map operations (update, clear). Test connection list management (add, remove, set). Test selectors return correct derived state. Test immer integration preserves immutability.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement useModbus Hook for Server Control Operations",
            "description": "Create src/hooks/useModbus.ts React hook that provides server control functions (start/stop TCP/RTU) with loading states, error handling, toast notifications, and automatic status updates.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create src/hooks/useModbus.ts:\n\n1. Import modbusService, useModbusStore, and toast notification library (e.g., sonner or react-hot-toast)\n\n2. Export useModbus hook that returns:\n   - status: ModbusStatus | null (from store)\n   - isConnecting: boolean (from store)\n   - error: string | null (from store)\n   - tcpRunning: boolean (derived from status)\n   - rtuRunning: boolean (derived from status)\n   - connectionCount: number (derived from status)\n\n3. Implement async action functions with error handling:\n   - startTcp: async (port: number) => Promise<boolean>\n     - Set isConnecting true, clear error\n     - Call modbusService.startTcp(port)\n     - On success: fetchStatus(), show success toast, return true\n     - On error: setError(message), show error toast, return false\n     - Finally: setConnecting(false)\n\n   - stopTcp: async () => Promise<boolean> - similar pattern\n\n   - startRtu: async (config: RtuConfig) => Promise<boolean> - similar pattern\n\n   - stopRtu: async () => Promise<boolean> - similar pattern\n\n   - refreshStatus: async () => Promise<void> - call fetchStatus() with error handling\n\n   - listSerialPorts: async () => Promise<PortInfo[]> - wrapped with error handling\n\n4. Use useCallback for all functions to prevent unnecessary re-renders\n\n5. Optionally add useEffect for initial status fetch on mount",
            "status": "pending",
            "testStrategy": "Test startTcp calls service and updates store on success. Test startTcp shows error toast and sets error on failure. Test isConnecting state transitions (true during operation, false after). Test stopTcp/startRtu/stopRtu follow same patterns. Test refreshStatus fetches and updates status. Test listSerialPorts returns port list. Integration test: verify hook works with actual store updates. Test useCallback memoization prevents function reference changes.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement useModbusMemory Hook for Real-time Memory Monitoring",
            "description": "Create src/hooks/useModbusMemory.ts React hook that subscribes to Modbus memory changes for a specific register type and address range, with initial data loading and Tauri event-based real-time updates.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create src/hooks/useModbusMemory.ts:\n\n1. Import listen from '@tauri-apps/api/event', modbusService, and types\n\n2. Define hook signature:\n   function useModbusMemory(type: RegisterType, start: number, count: number): {\n     values: (boolean | number)[];\n     isLoading: boolean;\n     error: string | null;\n     refresh: () => Promise<void>;\n   }\n\n3. Implement hook:\n   - useState for values, isLoading, error\n   - useCallback for refresh function that loads data based on type:\n     - If type === 'coil': await modbusService.readCoils(start, count)\n     - Else: await modbusService.readRegisters(type, start, count)\n\n4. useEffect for initial load and event subscription:\n   - Set isLoading true, call refresh()\n   - Subscribe to 'modbus:memory-changed' event using listen()\n   - Event handler checks if change is in range:\n     ```typescript\n     const isInRange = (address: number) => address >= start && address < start + count;\n     if (event.payload.registerType === type && isInRange(event.payload.address)) {\n       setValues(prev => {\n         const updated = [...prev];\n         updated[event.payload.address - start] = event.payload.newValue;\n         return updated;\n       });\n     }\n     ```\n   - Return cleanup function that calls unlisten\n\n5. Add dependencies array: [type, start, count]\n\n6. Handle type coercion: coil values are boolean[], register values are number[]\n\n7. Optional: integrate with modbusStore cache for performance optimization",
            "status": "pending",
            "testStrategy": "Test initial load fetches correct data based on RegisterType (coils vs registers). Test isLoading state transitions during fetch. Test error state is set on failed fetch. Test event listener updates values when memory-changed event fires within range. Test event listener ignores events outside subscribed range. Test event listener ignores events for different register types. Test cleanup function unsubscribes from events on unmount. Test refresh function reloads data. Test values array updates correctly at the right index (address - start).",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "26",
        "title": "Set Up End-to-End Testing Infrastructure",
        "description": "Configure Playwright for E2E testing with Tauri app launch support, create test utilities, fixtures, and initial test suites for project, layout, and Modbus functionality.",
        "details": "1. Install Playwright:\n   ```bash\n   npm install -D @playwright/test\n   npx playwright install\n   ```\n\n2. Create `playwright.config.ts`:\n   ```typescript\n   import { defineConfig } from '@playwright/test';\n\n   export default defineConfig({\n     testDir: './tests/e2e',\n     timeout: 60000,\n     retries: process.env.CI ? 2 : 0,\n     use: {\n       trace: 'on-first-retry',\n       screenshot: 'only-on-failure',\n       video: 'on-first-retry',\n     },\n     projects: [\n       { name: 'tauri', use: { /* Tauri-specific config */ } }\n     ],\n   });\n   ```\n\n3. Create test utilities in `tests/e2e/utils/`:\n   - `app.ts`: Tauri app lifecycle helpers\n     ```typescript\n     export async function launchApp() {\n       // Use @playwright/test with custom launch for Tauri\n       // May need tauri-driver or webview2 approach on Windows\n     }\n     export async function closeApp(app) { /* cleanup */ }\n     ```\n   - `selectors.ts`: Common element selectors\n     ```typescript\n     export const selectors = {\n       menuBar: '[data-testid=\"menu-bar\"]',\n       newProjectBtn: '[data-testid=\"new-project-btn\"]',\n       projectNameInput: '[data-testid=\"project-name-input\"]',\n       // ...\n     };\n     ```\n   - `helpers.ts`: Common test operations\n     ```typescript\n     export async function createNewProject(page, name: string) {\n       await page.click(selectors.newProjectBtn);\n       await page.fill(selectors.projectNameInput, name);\n       await page.click(selectors.createBtn);\n     }\n     ```\n\n4. Create test fixtures in `tests/e2e/fixtures/`:\n   - Sample .mop files for testing (valid and intentionally corrupted)\n   - Mock project configurations\n   - Test data for memory values\n\n5. Write initial E2E test suites:\n   - `tests/e2e/project.spec.ts`:\n     ```typescript\n     test('creates new project', async ({ page }) => {\n       await page.click('[data-testid=\"menu-file\"]');\n       await page.click('[data-testid=\"menu-new-project\"]');\n       await page.fill('[data-testid=\"project-name\"]', 'TestProject');\n       // ... folder selection\n       await page.click('[data-testid=\"create-btn\"]');\n       await expect(page.locator('[data-testid=\"project-header\"]')).toContainText('TestProject');\n     });\n\n     test('opens existing project', async ({ page }) => { /* */ });\n     test('saves project', async ({ page }) => { /* */ });\n     ```\n\n   - `tests/e2e/layout.spec.ts`:\n     ```typescript\n     test('toggles sidebar with Ctrl+B', async ({ page }) => {\n       const sidebar = page.locator('[data-testid=\"sidebar\"]');\n       await expect(sidebar).toBeVisible();\n       await page.keyboard.press('Control+b');\n       await expect(sidebar).not.toBeVisible();\n       await page.keyboard.press('Control+b');\n       await expect(sidebar).toBeVisible();\n     });\n\n     test('resizes panels', async ({ page }) => { /* */ });\n     test('switches sidebar tabs', async ({ page }) => { /* */ });\n     ```\n\n   - `tests/e2e/modbus.spec.ts`:\n     ```typescript\n     test('starts and stops Modbus TCP server', async ({ page }) => {\n       await page.click('[data-testid=\"modbus-start-tcp\"]');\n       await expect(page.locator('[data-testid=\"tcp-status\"]')).toContainText('Running');\n       await page.click('[data-testid=\"modbus-stop-tcp\"]');\n       await expect(page.locator('[data-testid=\"tcp-status\"]')).toContainText('Stopped');\n     });\n\n     test('displays memory values', async ({ page }) => { /* */ });\n     ```\n\n6. Add npm scripts:\n   ```json\n   \"scripts\": {\n     \"test:e2e\": \"playwright test\",\n     \"test:e2e:ui\": \"playwright test --ui\",\n     \"test:e2e:headed\": \"playwright test --headed\"\n   }\n   ```\n\n7. Add data-testid attributes to components:\n   - Update existing components to include data-testid for reliable selection\n   - Create naming convention: component-name or component-action",
        "testStrategy": "1. Verify Playwright installation and configuration works\n2. Test app launch/close utilities work reliably\n3. Run initial test suite and verify all tests pass\n4. Test screenshot capture on failure works\n5. Verify tests run in CI environment (if applicable)\n6. Test on Windows as primary target platform",
        "priority": "medium",
        "dependencies": [
          "15"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Playwright and Create Configuration File",
            "description": "Install @playwright/test package, run browser installation, and create playwright.config.ts with Tauri-specific settings for E2E testing.",
            "dependencies": [],
            "details": "Install Playwright dependencies: `npm install -D @playwright/test` and `npx playwright install`. Create `playwright.config.ts` in project root with: testDir set to './tests/e2e', timeout of 60000ms for Tauri app startup, retries set to 2 for CI and 0 locally, trace/screenshot/video capture on failure, and a 'tauri' project configuration. Add npm scripts to package.json: 'test:e2e' for headless runs, 'test:e2e:ui' for Playwright UI mode, and 'test:e2e:headed' for headed browser execution. Configure webServer to build and launch the Tauri app before tests using 'npm run tauri dev' command.",
            "status": "pending",
            "testStrategy": "Verify Playwright installation by running 'npx playwright --version'. Test configuration by running 'npx playwright test --list' to confirm test directory is recognized. Verify npm scripts execute without errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Test Utilities for Tauri App Lifecycle and Element Selection",
            "description": "Implement test utility modules for Tauri application launch/close helpers, common element selectors, and reusable test operations.",
            "dependencies": [
              1
            ],
            "details": "Create `tests/e2e/utils/` directory structure. Implement `app.ts` with launchApp() function that handles Tauri/WebView2 app startup on Windows, closeApp() for cleanup, and waitForAppReady() that waits for main window to be interactive. Create `selectors.ts` with data-testid based selectors for: menu bar components (menu-bar, menu-file, menu-new-project), project operations (new-project-btn, project-name-input, create-btn, project-header), sidebar elements (sidebar, sidebar-tab-*), panel system (panel-container, panel-header, resize-handle), and Modbus controls (modbus-start-tcp, tcp-status). Create `helpers.ts` with common test operations: createNewProject(page, name), openProject(page, path), toggleSidebar(page), switchSidebarTab(page, tab).",
            "status": "pending",
            "testStrategy": "Unit test selector constants are properly exported. Test app lifecycle helpers launch and close a minimal Tauri app without errors. Verify helper functions work with mock page objects.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create Test Fixtures with Sample Project Files",
            "description": "Create test fixture directory with sample .mop project files (valid and corrupted), mock project configurations, and test data for memory values.",
            "dependencies": [
              1
            ],
            "details": "Create `tests/e2e/fixtures/` directory. Generate sample .mop files: 'valid-project.mop' as a properly structured ZIP archive containing config.yml with project metadata, plc_csv/ directory with sample PLC data, and memory snapshots. Create 'corrupted-project.mop' with intentionally invalid ZIP structure for error handling tests. Create 'minimal-project.mop' with only required files for quick loading tests. Add 'mock-config.yml' with sample project configuration. Create 'test-memory-values.json' containing predefined coil and register values for Modbus testing (addresses 0-99 with various values). Add 'expected-layouts.json' defining expected panel positions after layout operations.",
            "status": "pending",
            "testStrategy": "Verify .mop files can be opened by the application without errors. Test corrupted file triggers appropriate error handling. Validate JSON fixtures parse correctly and contain expected data structures.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Write Initial E2E Test Suites for Project, Layout, and Modbus",
            "description": "Implement three E2E test specification files covering project operations, layout manipulation, and Modbus server functionality.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create `tests/e2e/project.spec.ts` with tests: 'creates new project' (click menu, fill name, select folder, verify header shows project name), 'opens existing project' (use fixture .mop file, verify project loads), 'saves project' (modify content, save, reopen to verify persistence), 'handles corrupted project file gracefully' (open corrupted fixture, verify error dialog). Create `tests/e2e/layout.spec.ts` with tests: 'toggles sidebar with Ctrl+B' (verify visibility change), 'resizes panels using drag handle' (drag handle, verify size changes), 'switches sidebar tabs' (click each tab, verify content changes), 'remembers layout after restart' (modify layout, restart app, verify layout restored). Create `tests/e2e/modbus.spec.ts` with tests: 'starts and stops Modbus TCP server' (click start, verify status shows Running, click stop, verify Stopped), 'displays memory values' (start server, write values, verify display updates), 'handles server errors gracefully' (attempt invalid port, verify error message).",
            "status": "pending",
            "testStrategy": "Run full test suite with 'npm run test:e2e' and verify all tests pass. Check screenshot capture works on intentional failures. Verify tests are isolated and can run in any order.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add data-testid Attributes to Application Components",
            "description": "Update existing React components to include data-testid attributes following a consistent naming convention for reliable E2E test element selection.",
            "dependencies": [
              4
            ],
            "details": "Establish naming convention: component-name or component-action format (e.g., 'menu-bar', 'new-project-btn', 'sidebar-tab-explorer'). Update MenuBar component: add data-testid='menu-bar', 'menu-file', 'menu-edit', 'menu-view', 'menu-new-project', 'menu-open-project', 'menu-save'. Update Sidebar component: add data-testid='sidebar', 'sidebar-toggle', 'sidebar-tab-explorer', 'sidebar-tab-search', 'sidebar-tab-modbus', 'sidebar-tab-settings'. Update Panel components: add data-testid='panel-container', 'panel-{id}', 'panel-header-{id}', 'resize-handle-horizontal', 'resize-handle-vertical'. Update Project UI: add data-testid='project-header', 'project-name-input', 'project-folder-select', 'create-btn', 'cancel-btn'. Update Modbus components: add data-testid='modbus-start-tcp', 'modbus-stop-tcp', 'tcp-status', 'tcp-port-input', 'memory-visualizer'. Document all data-testid values in selectors.ts for synchronization.",
            "status": "pending",
            "testStrategy": "Verify all selectors from selectors.ts can locate corresponding elements in the running application. Run E2E test suite to confirm all element selections work correctly. Check no duplicate data-testid values exist in the component tree.",
            "parentId": "undefined"
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-27T05:36:59.590Z",
      "taskCount": 26,
      "completedCount": 17,
      "tags": [
        "master"
      ]
    }
  }
}