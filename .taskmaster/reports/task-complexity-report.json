{
	"meta": {
		"generatedAt": "2026-01-29T18:01:23.164Z",
		"tasksAnalyzed": 30,
		"totalTasks": 126,
		"analysisCount": 30,
		"thresholdScore": 5,
		"projectName": "Taskmaster",
		"usedResearch": true
	},
	"complexityAnalysis": [
		{
			"taskId": 97,
			"taskTitle": "Implement ScenarioExecutor Core Structure in Rust",
			"complexityScore": 7,
			"recommendedSubtasks": 0,
			"expansionPrompt": "Task 97 is already fully implemented with all 5 subtasks marked as done. The ScenarioExecutor with ScenarioState enum, ScheduledEvent with BinaryHeap ordering, PendingRelease struct, ScenarioStatus, and core methods (new(), load(), get_status()) are all implemented in src-tauri/src/scenario/executor.rs (868 lines). No further expansion needed.",
			"reasoning": "Verified in executor.rs: ScenarioState (lines 23-43), ScheduledEvent with Ord/PartialOrd (lines 49-78), PendingRelease (lines 84-93), ScenarioStatus (lines 99-133), and ScenarioExecutor with all required fields and methods. All 5 subtasks are done - this task is complete."
		},
		{
			"taskId": 98,
			"taskTitle": "Implement Scenario Execution Engine Run/Stop Logic",
			"complexityScore": 8,
			"recommendedSubtasks": 0,
			"expansionPrompt": "Task 98 is already fully implemented. The run() async method (lines 424-557), execute_event() (lines 559-592), stop() (lines 376-409), parse_modbus_address() (lines 684-711), process_releases() (lines 594-617), and read/write_from_memory() (lines 619-677) are all implemented. The 5 subtasks are still marked pending but the code is complete.",
			"reasoning": "Analysis of executor.rs shows complete implementation: run() handles main execution loop with elapsed time calculation, event processing via BinaryHeap, Tauri event emission for 'scenario:event-executed' and 'scenario:status-changed', loop handling with restart logic, and proper async/await patterns. All 5 subtasks describe functionality that is already present in the codebase."
		},
		{
			"taskId": 99,
			"taskTitle": "Implement Scenario Pause/Resume and Loop Execution",
			"complexityScore": 6,
			"recommendedSubtasks": 0,
			"expansionPrompt": "Task 99 is already implemented. pause() (lines 339-353), resume() (lines 355-374), loop handling in run() (lines 511-542), and process_releases() (lines 594-617) are all present. Pause/resume properly track paused_duration, and loop logic correctly reloads event queue and emits loop-completed events.",
			"reasoning": "Verified in executor.rs: pause() validates Running state, records pause_time; resume() calculates paused_duration; run() loop checks for loop_enabled/loop_count and handles loop iteration with delay. PendingRelease tracking for persist=false events is implemented in execute_event(). The 5 subtasks describe already-implemented functionality."
		},
		{
			"taskId": 100,
			"taskTitle": "Create Scenario Execution Tauri Commands",
			"complexityScore": 5,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Implement Tauri commands in src-tauri/src/commands/scenario.rs: 1) Create ScenarioExecutorState struct with Arc<Mutex<Option<ScenarioExecutor>>> following SimState pattern. 2) Implement scenario_run command that initializes executor, loads scenario, and spawns async run task. 3) Implement scenario_pause, scenario_resume, scenario_stop commands with state access. 4) Implement scenario_get_status returning ScenarioStatus. 5) Register commands and state in lib.rs invoke_handler and .manage(). Reference existing sim.rs commands for patterns.",
			"reasoning": "Partially implemented - commands/scenario.rs exists (490 lines) but needs verification of ScenarioExecutorState integration. Following established patterns from sim.rs (SimState), modbus commands, and other Tauri command modules. Medium complexity as it builds on existing infrastructure with well-defined patterns."
		},
		{
			"taskId": 101,
			"taskTitle": "Create useScenarioExecution React Hook",
			"complexityScore": 5,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Create src/components/ScenarioEditor/hooks/useScenarioExecution.ts: 1) Define TypeScript types for ScenarioStatus matching Rust struct. 2) Implement Tauri event listeners using listen() for scenario:status-changed, scenario:event-executed, scenario:completed, scenario:error with proper cleanup via UnlistenFn refs. 3) Implement run/pause/resume/stop/seek functions using invoke() calls. 4) Add computed properties (isRunning, isPaused, isCompleted) derived from status.state. 5) Update ScenarioToolbar and ExecutionProgress components to consume the hook. Follow useSimulation.ts pattern (479 lines) for event listener setup.",
			"reasoning": "A useScenarioExecution.ts may already exist but needs Tauri integration. The pattern is well-established in useSimulation.ts which uses listen() for events, invoke() for commands, useRef for cleanup, and useState for status. Medium complexity with clear template to follow."
		},
		{
			"taskId": 102,
			"taskTitle": "Integrate Scenario Execution with ScenarioToolbar UI",
			"complexityScore": 4,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Update src/components/ScenarioEditor/ScenarioToolbar.tsx: 1) Import and use useScenarioExecution hook to get isRunning, isPaused, run, pause, resume, stop, error. 2) Modify play button to call run() when idle, pause() when running, resume() when paused. 3) Add stop button that calls stop() and is enabled only when running or paused. 4) Add status display showing elapsed time, events executed/total, and loop count from status. 5) Add error display for execution errors with red styling. Integrate with existing toolbar button patterns.",
			"reasoning": "Straightforward UI integration task. ScenarioToolbar.tsx exists and the execution hook provides all needed state and actions. Following existing toolbar patterns from other editors. Lower complexity as it's primarily connecting hook outputs to UI elements."
		},
		{
			"taskId": 103,
			"taskTitle": "Implement Undo/Redo System for Ladder Editor",
			"complexityScore": 4,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Review and enhance ladderStore.ts undo/redo: 1) Audit undo() implementation (lines 1015-1037) - fix boundary check logic and snapshot restoration. 2) Audit redo() implementation (lines 1039-1057) - verify index calculation and snapshot access order. 3) Refactor repeated history push pattern (13+ occurrences) into reusable pushHistorySnapshot() helper. 4) Create useCanUndo/useCanRedo custom hooks wrapping selectors for cleaner component consumption. 5) Add comprehensive integration tests for all undo/redo scenarios including edge cases. Note: History system already exists (lines 99-108, 161-167), this task is about verification and enhancement.",
			"reasoning": "Undo/redo is ALREADY IMPLEMENTED in ladderStore.ts (1371 lines). History snapshots (line 53-69), history state (lines 99-108), undo/redo actions (lines 1015-1057), pushHistory pattern (13+ occurrences), and canUndo/canRedo selectors (lines 1366-1371) all exist. Task is about auditing, fixing potential issues, and adding tests - not building from scratch."
		},
		{
			"taskId": 104,
			"taskTitle": "Implement Command Registry and Palette Core",
			"complexityScore": 6,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Create src/components/CommandPalette/ directory: 1) Create types.ts with CommandCategory union type and Command interface (id, category, label, description, icon, shortcut, keywords, when, execute). 2) Implement CommandRegistry class in commandRegistry.ts with Map storage, register/unregister/get/getAll methods. 3) Add recent commands tracking with addToRecent(), getRecent() and MAX_RECENT=10 limit. 4) Implement search() method with fuzzy matching on label, keywords, category, description. 5) Create useCommandRegistry hook with subscription support for React component re-rendering on registry changes. Consider using fuse.js for advanced fuzzy search.",
			"reasoning": "No CommandPalette exists in codebase (glob returned empty). New feature requiring command pattern implementation with registry, search, and recent tracking. Common pattern but requires careful design for extensibility. Medium-high complexity for greenfield feature."
		},
		{
			"taskId": 105,
			"taskTitle": "Create CommandPalette UI Component",
			"complexityScore": 5,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Build CommandPalette React components: 1) Create CommandItem.tsx subcomponent with icon, label, shortcut display, hover/selected states matching neutral-700/600 styling. 2) Create CommandSection.tsx for grouped display with category headers (Recent, File, Edit, etc.). 3) Build main CommandPalette.tsx modal with backdrop (bg-black/50), search input with Search icon, 600px width, 400px max-height. 4) Implement keyboard navigation: ArrowUp/Down for selection, Enter for execution, Escape for close, with scrollIntoView for selected item. 5) Implement useMemo-based search filtering and command grouping by category, showing recent commands when query is empty.",
			"reasoning": "Standard modal component with established patterns from SettingsDialog and SearchPanel. Requires keyboard navigation, fuzzy search integration, and category grouping. Medium complexity with clear design requirements."
		},
		{
			"taskId": 106,
			"taskTitle": "Register Application Commands and Global Shortcut",
			"complexityScore": 5,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Register commands across the application: 1) Create fileCommands.ts with file.new, file.open, file.save, file.close commands using projectService. 2) Create editCommands.ts with edit.undo, edit.redo, edit.cut, edit.copy, edit.paste referencing ladderStore/canvasStore. 3) Create simulationCommands.ts with simulation.start (F5), stop, pause, step using sim Tauri commands with when() conditions. 4) Create viewCommands.ts, ladderCommands.ts, canvasCommands.ts, scenarioCommands.ts, etc. 5) Create commands/index.ts with registerAllCommands() and integrate in App.tsx with global Ctrl+Shift+P keydown listener opening command palette.",
			"reasoning": "Integration task requiring coordination across multiple stores and services. Commands need to reference existing actions from ladderStore, canvasStore, panelStore, and Tauri commands. Medium complexity due to breadth of integration points but each command follows simple pattern."
		},
		{
			"taskId": 107,
			"taskTitle": "Implement ScopeEngine in Rust Backend",
			"complexityScore": 7,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Create src-tauri/src/canvas/scope.rs: 1) Define TriggerMode, TriggerEdge, RunMode enums and ScopeSettings struct with serde serialization. 2) Implement ChannelBuffer with VecDeque for ring buffer samples and TriggerState for trigger detection state machine. 3) Create ScopeEngine struct with channels Vec, settings, sample_rate, buffer_size, trigger_state and implement new() constructor. 4) Implement add_sample() with ring buffer management and check_trigger() with rising/falling edge detection based on trigger_level. 5) Implement get_display_data() returning ScopeDisplayData with normalized points, min/max/average calculations, and trigger info. Update canvas/mod.rs to export module.",
			"reasoning": "New subsystem requiring real-time signal processing concepts: ring buffers, trigger detection, waveform display. No existing scope.rs in codebase. High complexity due to precision timing requirements and signal processing logic, but well-defined mathematical operations."
		},
		{
			"taskId": 108,
			"taskTitle": "Create Scope Tauri Commands and Canvas Integration",
			"complexityScore": 6,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Implement scope commands in src-tauri/src/commands/canvas.rs: 1) Create ScopeState with RwLock<HashMap<String, ScopeEngine>> for multi-scope management. 2) Implement scope_create, scope_get_data commands following existing command patterns. 3) Implement scope_update_settings, scope_add_sample, scope_run_stop commands. 4) Extend canvas_sync.rs with scope_mappings to feed voltage samples from circuit ports to scope engines during simulation. 5) Register commands and ScopeState in mod.rs and lib.rs invoke_handler. Follow SimState and CanvasSyncState patterns.",
			"reasoning": "Integration task connecting ScopeEngine to Tauri command system and canvas simulation. Follows established patterns from other state-managed commands. Medium-high complexity due to real-time sample feeding integration with canvas_sync."
		},
		{
			"taskId": 109,
			"taskTitle": "Enhance ScopeBlock Component with Real-time Waveform Display",
			"complexityScore": 5,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Update src/components/OneCanvas/components/blocks/ScopeBlock.tsx: 1) Define ScopeDisplayData TypeScript types matching Rust structs in types/onesim.ts. 2) Create useScopeData hook that polls scope_get_data at 20 FPS (50ms interval) when simulation is running, with proper cleanup. 3) Implement waveformRenderer.ts with drawGrid(), drawChannel(), drawTriggerMarker(), drawWaveform() canvas functions using CHANNEL_COLORS. 4) Replace SVG rendering with Canvas element and useEffect for drawing when displayData updates. 5) Add ScopeExpandedView modal for double-click expand with larger canvas and detailed controls.",
			"reasoning": "ScopeBlock.tsx exists (uses SVG currently). Need to add Canvas 2D rendering with polling hook. Medium complexity - Canvas API work with established polling patterns from other hooks. Real-time update at 20 FPS is straightforward."
		},
		{
			"taskId": 110,
			"taskTitle": "Create ScopeExpandedView Modal Component",
			"complexityScore": 4,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Create src/components/OneCanvas/components/blocks/ScopeExpandedView.tsx: 1) Define props and types for expanded view including scopeId, settings, onClose. 2) Implement waveform drawing utility reusing waveformRenderer.ts functions with larger canvas (640x480). 3) Create ChannelControl subcomponent with scale selector, offset control, coupling toggle, color indicator. 4) Build main modal with toolbar (Run/Stop, time base, trigger mode selectors), canvas area, channel sidebar (40px wide), measurements bar. 5) Add Tauri integration for polling data and updating settings via invoke(), with useEffect for data polling and cleanup.",
			"reasoning": "Extension of ScopeBlock with more controls. Modal pattern exists in SettingsDialog. Medium complexity as it reuses waveform rendering and follows established modal patterns. Primarily UI composition work."
		},
		{
			"taskId": 111,
			"taskTitle": "Create Tauri Window Commands Module",
			"complexityScore": 3,
			"recommendedSubtasks": 0,
			"expansionPrompt": "Task 111 is ALREADY FULLY IMPLEMENTED. src-tauri/src/commands/window.rs exists (286 lines) with: WindowBounds struct, FloatingWindowInfo struct, FloatingWindowRegistry with register/unregister/get/update_bounds/list methods, and all Tauri commands: window_create_floating, window_close_floating, window_update_bounds, window_focus_floating, window_list_floating, window_get_floating_info, window_minimize_floating, window_maximize_floating, window_floating_exists. Event emissions for floating-window-created, floating-window-closed, floating-window-focused are implemented.",
			"reasoning": "Verified complete implementation in window.rs: WindowBounds (lines 12-19), FloatingWindowInfo (lines 21-28), FloatingWindowRegistry class (lines 30-68), FloatingWindowState type (line 71), and all 9 Tauri commands (lines 73-285). No expansion needed - task is complete."
		},
		{
			"taskId": 112,
			"taskTitle": "Implement Tauri Window Event System",
			"complexityScore": 2,
			"recommendedSubtasks": 0,
			"expansionPrompt": "Task 112 is ALREADY IMPLEMENTED as part of Task 111. Event emissions exist in window.rs: floating-window-created (line 120), floating-window-closed (line 152), floating-window-focused (line 201). Window resize event listener setup can be added to lib.rs setup if needed, but core event system is complete.",
			"reasoning": "Event emissions are already in window.rs commands. The Tauri event system is integrated via app.emit() calls in window_create_floating, window_close_floating, and window_focus_floating. This task's requirements are satisfied by the existing implementation."
		},
		{
			"taskId": 113,
			"taskTitle": "Create Window Types and State Management Types",
			"complexityScore": 2,
			"recommendedSubtasks": 0,
			"expansionPrompt": "Task 113 is PARTIALLY IMPLEMENTED. src/types/window.ts exists (116 lines) with Bounds, FloatingWindowState, WindowRegistryState interfaces. src/types/panel.ts exists (56 lines). Need to verify and potentially add windowId, isFloating, floatingBounds properties to PanelState in panel.ts, and add FloatingWindowLayoutConfig to layout.ts for layout persistence.",
			"reasoning": "Core types exist in types/window.ts (Bounds, FloatingWindowState). PanelState extension and layout types need verification. Minor enhancement task rather than greenfield development."
		},
		{
			"taskId": 114,
			"taskTitle": "Implement windowStore for Floating Window State Management",
			"complexityScore": 3,
			"recommendedSubtasks": 0,
			"expansionPrompt": "Task 114 is ALREADY IMPLEMENTED. src/stores/windowStore.ts exists (209 lines) with: floatingWindows Map, focusedWindowId, nextZIndex state; registerFloatingWindow, unregisterFloatingWindow, updateWindowBounds, setFocusedWindow, setWindowMinimized, setWindowMaximized, getWindowByPanelId, getAllFloatingWindows, clearAllWindows actions. Uses Zustand with devtools middleware.",
			"reasoning": "Verified windowStore.ts exists with complete implementation including Map-based window tracking, z-index management, and all CRUD operations. Task is complete."
		},
		{
			"taskId": 115,
			"taskTitle": "Extend panelStore with Floating Window Actions",
			"complexityScore": 5,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Extend src/stores/panelStore.ts: 1) Add undockPanel(panelId, bounds?) action that calls window_create_floating Tauri command, updates panel isFloating and windowId properties, removes from grid layout. 2) Add dockPanel(panelId, targetPanelId?, dropPosition?) that closes floating window, resets panel floating state, uses splitPanel or mergePanelAsTabs for placement. 3) Add updatePanelFloatingBounds(panelId, bounds) for tracking. 4) Add setPanelFloating(panelId, isFloating, windowId?) helper. 5) Add getFloatingPanels() and getDockedPanels() selectors filtering by isFloating property.",
			"reasoning": "panelStore.ts exists (686 lines) with extensive panel management. Need to add floating window integration connecting to windowStore and Tauri commands. Medium complexity due to coordination between stores and Tauri backend."
		},
		{
			"taskId": 116,
			"taskTitle": "Create Window Service for Tauri Communication",
			"complexityScore": 4,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Create src/services/windowService.ts: 1) Implement createFloatingWindow, closeFloatingWindow, updateFloatingWindowBounds, focusFloatingWindow, listFloatingWindows functions wrapping Tauri invoke() calls. 2) Add event listeners onWindowCreated, onWindowClosed, onWindowMoved, onWindowFocused using Tauri listen() returning UnlistenFn. 3) Handle event payload transformation from Tauri format to TypeScript types. 4) Export windowService object with all methods. 5) Add error handling and logging for failed invocations.",
			"reasoning": "Service layer following established pattern from modbusService, projectService. Straightforward wrapper around Tauri invoke() and listen() calls. Medium complexity with clear implementation pattern."
		},
		{
			"taskId": 117,
			"taskTitle": "Implement Window Boundary Detection Hook",
			"complexityScore": 5,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Create src/hooks/useWindowBoundary.ts: 1) Use Tauri Window API (getCurrent, innerPosition, innerSize) to get main window bounds on mount. 2) Add event listeners for window move/resize events to update bounds. 3) Implement checkPosition(clientX, clientY) that returns true if coordinates are outside main window bounds. 4) Implement getPositionRelativeToScreen(clientX, clientY) converting client coords to screen coords using main window position. 5) Return isOutsideMainWindow state, mainWindowBounds, checkPosition, getPositionRelativeToScreen. Handle async Tauri API calls properly.",
			"reasoning": "New hook requiring Tauri Window API integration for boundary detection. Uses availableMonitors, Window.getCurrent(), innerPosition/innerSize. Medium complexity due to coordinate system handling and async Tauri APIs."
		},
		{
			"taskId": 118,
			"taskTitle": "Extend PanelDndProvider for Floating Window Creation",
			"complexityScore": 6,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Update src/providers/PanelDndProvider.tsx: 1) Import and use useWindowBoundary hook to get checkPosition and getPositionRelativeToScreen. 2) Extend DragState with isOutsideMainWindow and screenPosition fields. 3) Modify handleDragOver to check window boundaries using checkPosition, update dragState when outside. 4) Modify handleDragEnd to call undockPanel with screen position when isOutsideMainWindow is true. 5) Update DragOverlay styling to show different border color (purple) when outside main window. Reset drag state on completion.",
			"reasoning": "Integration of boundary detection with existing drag-drop system. PanelDndProvider exists with established drag handling. Medium-high complexity due to coordinate handling and integration with undock flow."
		},
		{
			"taskId": 119,
			"taskTitle": "Create Floating Window React Components",
			"complexityScore": 5,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Create src/components/floating/ directory: 1) Create FloatingWindowHeader.tsx with title, dock, minimize, maximize, close buttons using lucide-react icons, data-tauri-drag-region for dragging. 2) Create FloatingWindowContent.tsx that retrieves panel from panelStore by panelId, renders PanelContent component, handles dock and close actions. 3) Create FloatingWindowRenderer.tsx that sets up windowService event listeners (onWindowCreated, onWindowClosed, onWindowMoved, onWindowFocused) to sync with windowStore. 4) Add proper cleanup for all event listeners. 5) Create index.ts exporting all components.",
			"reasoning": "Component layer for floating windows. FloatingWindowHeader provides window controls, FloatingWindowContent renders panel, FloatingWindowRenderer manages event sync. Medium complexity following established component patterns."
		},
		{
			"taskId": 120,
			"taskTitle": "Add Undock Button to Panel Header",
			"complexityScore": 3,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Update panel header component: 1) Import ExternalLink icon from lucide-react and usePanelStore. 2) Add onUndock prop and canUndock prop (default true) to PanelHeaderProps. 3) Add Undock button in header action buttons area with ExternalLink icon, hover:bg-gray-700 styling, tooltip 'Undock to floating window'. 4) In Panel component, create handleUndock function that calculates default bounds (window.screenX + 100, window.screenY + 100, 600x400) and calls undockPanel. 5) Conditionally render Undock button when canUndock && !isFloating.",
			"reasoning": "Simple UI addition to existing panel header. Low-medium complexity as it's adding a button and connecting to existing undockPanel action."
		},
		{
			"taskId": 121,
			"taskTitle": "Implement Floating Window Entry Point and Routing",
			"complexityScore": 5,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Update src/main.tsx for floating window routing: 1) Parse URL query params to detect floating=true, windowId, panelId using URLSearchParams. 2) Create FloatingWindowProvider.tsx with minimal providers (ThemeProvider) needed for floating windows. 3) If floating window, render FloatingWindowContent with windowId and panelId props instead of MainApp. 4) Consider state synchronization between windows using Zustand persist or Tauri events. 5) Test that floating windows render correct panel content based on panelId.",
			"reasoning": "Entry point modification for separate window rendering. Query param routing is straightforward but state synchronization adds complexity. Medium complexity overall."
		},
		{
			"taskId": 122,
			"taskTitle": "Extend Layout Persistence for Floating Windows",
			"complexityScore": 5,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Extend layout persistence: 1) Add floatingWindows array to getCurrentLayout() in layoutService collecting FloatingWindowLayoutConfig from windowStore. 2) In restoreLayout(), iterate floatingWindowConfigs and call undockPanel for each with stored bounds. 3) Add error handling with fallback to docked panel if floating restoration fails. 4) Implement closeAllFloatingWindows() helper to clean up before layout switch. 5) Update Rust layout commands if needed to serialize/deserialize floatingWindows field.",
			"reasoning": "Extension of existing layout persistence system. layoutPersistenceStore exists. Medium complexity integrating floating window state into save/restore flow."
		},
		{
			"taskId": 123,
			"taskTitle": "Implement Multi-Monitor Support and Screen Boundary Handling",
			"complexityScore": 4,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Create src/utils/screenUtils.ts: 1) Implement getAvailableScreenBounds() using Tauri availableMonitors() API returning Bounds array. 2) Implement isPositionOnScreen(x, y) checking if point is within any screen bounds. 3) Implement correctWindowPosition(bounds) that checks visibility (50px minimum visible) and moves to primary screen if not visible. 4) Integrate correctWindowPosition into undockPanel and layout restore for floating windows. 5) Handle edge case of disconnected monitor where saved bounds are off-screen.",
			"reasoning": "Utility functions for multi-monitor handling using Tauri availableMonitors API. Medium complexity with straightforward geometry calculations but requires handling edge cases."
		},
		{
			"taskId": 124,
			"taskTitle": "Add Drag-to-Dock Functionality for Floating Windows",
			"complexityScore": 5,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Implement floating-to-dock drag: 1) In FloatingWindowHeader, make header draggable with onDragStart setting application/x-floating-panel data transfer type. 2) In MainLayout, add handleDragOver checking for floating-panel type and preventDefault to enable drop. 3) Add handleDrop parsing JSON payload and calling dockPanel with target position. 4) Integrate with existing drop zone visualization to show dock positions when dragging from floating window. 5) Alternative: use Tauri window startDragging() with detection of main window proximity.",
			"reasoning": "Reverse of undock flow using HTML5 drag API or Tauri window dragging. Medium complexity coordinating between floating window and main window drop handling."
		},
		{
			"taskId": 125,
			"taskTitle": "Implement State Synchronization Between Windows",
			"complexityScore": 7,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Create src/utils/stateSync.ts: 1) Define STATE_SYNC_EVENT constant and StateSyncPayload type with storeName, state, sourceWindowId. 2) Implement setupStateSync(storeName, getState, setState) using Tauri emit/listen for cross-window communication. 3) Integrate with panelStore wrapping actions to broadcast changes via stateSync. 4) Alternative: use Zustand persist with BroadcastChannel for same-origin window sync. 5) Add cleanup for state sync listeners and test bidirectional sync between main and floating windows.",
			"reasoning": "Complex synchronization problem - each Tauri window has separate JS context. Requires event-based sync or shared storage. High complexity due to race conditions, consistency, and cleanup requirements."
		},
		{
			"taskId": 126,
			"taskTitle": "Write Comprehensive Tests for Floating Window System",
			"complexityScore": 5,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Create tests for floating window system: 1) Unit tests for windowStore (register/unregister, bounds updates, zIndex management) in __tests__/windowStore.test.ts. 2) Component tests for FloatingWindowHeader (button clicks, callbacks) using React Testing Library. 3) Integration tests mocking Tauri invoke for panelStore undock/dock actions. 4) E2E tests using Playwright for undock button click, drag outside to create floating, layout save/restore with floating windows. 5) Add test utilities for mocking Tauri Window and invoke APIs.",
			"reasoning": "Comprehensive testing across unit, integration, and E2E levels. Medium complexity with established testing patterns but requires Tauri API mocking."
		}
	]
}